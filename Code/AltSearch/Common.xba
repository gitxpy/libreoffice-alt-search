<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="Common" script:language="StarBasic">option explicit

	type tParFind  &apos; tally variable for search the paragraphs \p
		txt as string
		attr as string
		bmin as integer
		bmax as integer
		emin as integer
		emax as integer
		mode as integer
	end type

	type tFind  &apos; tally variable for general search
		hled as string  &apos;searched string for findNext()
&apos;search the group of empty space:
		pmode as integer  &apos;0=nothing; -1=before the start of found; 1=after the end of found
		pmin as integer   &apos; minimal count of paragraph: 0..pmax
		pmax as integer   &apos; maximal count of paragraph: 1..max; -1=any count
		pgBreak as integer &apos; search the Break 0=nothing; 1=of page; 2=of column
		pstyl as string   &apos; for search of substring in URL
		chstyl as string  &apos; found text must be the entered character style
		lgrw as string     &apos; increase of selection after final found related to its start
		rgrw as string     &apos; decrease of selection after final found related to its end
		cmd as string     &apos; special command [::something::] - only for 1st item
		atr as integer   &apos; 0= search only changed properties   1=search the exact value
		&apos; 3= search definite text of entered char. style   4=search any part of entered char. style - only in 1st item
		&apos; 5= search only entered list style  6=search any list style including system one (for example for non-style lists, bullets...)    - only in 1st item
		&apos; 7= search only entered paragraph style  8=search any paragraph style except for Standard  - only in 1st item
		&apos; 9=search definite text selected as Index, entered name of Index 10=search any text selected as Index - only in 1st item
		skup as integer  &apos; 0=nothing; 1-9 the number of found group inside the brackets
		umode as integer  &apos; 0=normal; 1 this part of array searches any long group .+ or .* (min. count of characters n is in PMIN)
		&apos;-1 it signalizes that previous record was any long group of characters - other service to save of content of (previous) group
		nmode as byte  &apos; 0=nothing; 1 = flag of stretchy group that if isn&apos;t found is considered like found; for example [xy..z]*  z* and others.
	end type

	type tRepl &apos; tally variable for replacement
		nahr as string  &apos;found string or parameter of command
		cmd as string     &apos; special command [::something::] - only for 1st item
		&apos; it is valid for whole string, saved in  REPL(0).smaz .vloz
		smaz as byte &apos; 1 = delete; flag the text at the start of replacement need be deleted - but for example it can be undesirable at hyperlink if only part of URL is wanted to be changed
		vloz as byte &apos; 1 = there is used whole found string/object inside the replacement (delete to clipboard, it is needful further)
		form as byte &apos; 1 = enforce the inserting via clip, to keep the formatting for the inserting via &amp;
		textobs as byte &apos; 1 = the parameter is used \o = text content of object - don&apos;t needlessly convert the tables to text
		ppos as byte &apos; 0 nothing; 1 = inserting of paragraph to the end of replace string, after inserting in need move cursor to right before next text
	end type


Function addZero(variable as variant) as variant &apos;add ZeroWidthJoiner to start of string if one started &quot;&amp;&quot;; also for the items in array bug #74
	dim i&amp;, s$, v as variant
	v=VarType(variable)
	if v=8 then &apos;variable is string$
		if Left(variable, 1)=&quot;&amp;&quot; then variable=sZERO &amp; variable
	else &apos;variable should be array()
		for i=lbound(variable) to ubound(variable)
			s=variable(i)
			if Left(s, 1)=&quot;&amp;&quot; then variable(i)=sZERO &amp; s
		next i
	end if
	addZero=variable
End Function


function isDigit_(c as String) as Boolean
  isDigit_ = (instr(&quot;0123456789&quot;, c) &gt; 0)   &apos; TODO: use isNumeric() ?
end function

sub dbgVypisFind(pom())
	dim i
	for i = 0 to ubound(pom())
		msgbox &quot;Find: &quot; &amp; pom(i).hled &amp; &quot;   Cmd: &quot; &amp; pom(i).cmd &amp; chr(10) &amp; _
		&quot;Grow: &quot; &amp; pom(i).lgrw &amp; &quot;  &quot; &amp; pom(i).rgrw &amp; chr(10) &amp; _
		&quot;pmode:  &quot; &amp; pom(i).pmode &amp; &quot;  min: &quot; &amp; pom(i).pmin &amp; &quot;  max: &quot; &amp; pom(i).pmax &amp; &quot;  uMode: &quot; &amp; pom(i).umode &amp; &quot;  nMode: &quot; &amp; pom(i).nmode &amp; chr(10) &amp; _
		&quot;pgBreak:&quot; &amp; pom(i).pgBreak &amp; &quot;  Atr: &quot; &amp; pom(i).atr &amp; &quot;  Skupina(): &quot; &amp; pom(i).skup &amp; chr(10) &amp; _
		&quot;pstyl:  &quot; &amp; pom(i).pstyl &amp; &quot;  chstyl: &quot; &amp; pom(i).chstyl, 0 , &quot;Index: &quot; &amp; i
	next i
end sub


sub dbgVypisRepl(pom())
	dim i
	for i = 0 to ubound(pom())
		msgbox &quot;Repl: &quot; &amp; pom(i).nahr &amp; chr(10) &amp; _
		&quot;Cmd: &quot; &amp; pom(i).cmd &amp;  chr(10) &amp; _
		&quot;Smaz: &quot; &amp; pom(i).smaz &amp; &quot;  Vloz: &quot; &amp; pom(i).vloz &amp; &quot;  Form: &quot; &amp; pom(i).form &amp; &quot;  TextObsah: &quot; &amp; pom(i).textobs , 0 , &quot;Index: &quot; &amp; i
	next i
end sub


	&apos; the function try to find for parts all items of array FIND() in dependence of its parameters and parameters of searching from oDialog
	&apos; it starts search from FROMcur, in potentially block defined by cursor BLOCKcur.
	&apos;&apos; lgrow, rgrow increase/decrease found area: for example -1/+1 the move of start or end of selection about one character to left/right
	&apos;&apos; par - extend the area to start/end of current paragraph
	&apos; returned value: 0 = found, found part saved in prCURS
	&apos; -1/1 = the strt/end of limiting block is exceeded, in prCURS is limiting block
	&apos; -2/2 = not found from the start/end of document, in prCURS is mark of end/start of document
sub FindNextInBlock(find(), fromCur, blockCur as object, fcount as boolean, mark as boolean) as integer
	Dim HleDesc, found, hledjod, zac, kon, finzac, finkon, tmprange, lgrow, rgrow
	Dim oTmp, oAnch, tabIsIn  &apos; table inside the block
	Dim i, mistoChyby, maxfind
	Dim uskupB, uskupE &apos; the start and the end of unfinished block of text - with special service
	Dim n as long &apos; counter of following search: there must be correctly found all parts of array find() to correct find
	dim foundStr as string &apos; the string of found text
	dim nulSkupina as boolean &apos; flag that it is group with zero length for exception
	dim Enum1,Enum2, TextElement, TextPortion, stylNalezen, rejstrikNalezen, tCurs    &apos; for search of character style
	dim pomo

	if ERRcontrol then on error goto Errobsluha
	HleDesc = ALTsearchDOC.createReplaceDescriptor()

	if ALTsearchPARAMS.kcase = 1 then HleDesc.SearchCaseSensitive = true
	if ALTsearchPARAMS.word = 1 then HleDesc.SearchWords = true
	if ALTsearchPARAMS.styl = 1 then HleDesc.SearchStyles = true
	if ALTsearchPARAMS.reg = 1 then HleDesc.SearchRegularExpression = true
	if find(0).atr = 1 then
		HleDesc.ValueSearch = true &apos; = True searches the exact value prop; False searches only the occurrence of properties
	else
		HleDesc.ValueSearch = false
	end if

	if ubound(SRCHATR())&gt;=0 then
		HleDesc.SearchAll = true
		HleDesc.SearchStyles = true
		mistochyby = 3
		HleDesc.SetSearchAttributes(SRCHATR())  &apos; if the array for search according to attributes is empty then load one
	end if

	&apos; count the occurrences quickly, must not be a block
	FOUNDall = 0  &apos; set to zero, if the search will be used further then it will be the object
	if fcount and (ALTsearchPARAMS.csele = 0) then &apos; switch isn&apos;t active so search in block
		&apos; and must not be used spec. functions \p \m \c, groups, potentially according to styles (.atr=3)
		if (ubound(find())=0)and(find(0).pmode=0)and(find(0).pgBreak=0)and(find(0).pstyl=&quot;&quot;)and(find(0).atr&lt;3) then
			if ALTsearchPARAMS.zpet = 1 then HleDesc.SearchBackwards = true  &apos; moved more down
			HleDesc.SearchString = find(0).hled &apos; searched string
			FOUNDall = ALTsearchDOC.findAll(HleDesc) &apos; find all
			nCOUNT = nCOUNT+FOUNDall.count
			FindNextInBlock = 9  &apos; end, prCURS isn&apos;t defined
			exit sub
		end if
	end if

	&apos; show warning about the interruption of highlight before 1st use
	if fcount and mark and WARNING then
		if isUsedCharBackColor then
			if 6 &lt;&gt; hlaseni(7) then
				FindNextInBlock = -999  &apos; cancel, end
				exit sub
			end if
		end if
		ClearBackColor &apos; cancel potential previous help colors
		WARNING = false
	end if

	&apos; the data for the extension of found selection must be in 1st item
	lgrow = find(0).lgrw
	rgrow = find(0).rgrw

	if ALTsearchPARAMS.zpet = 1 then &apos; search reversed cursor at backward search
		fromCur.collapseToStart
	else
		fromCur.collapseToEnd
	end if

	finkon = fromCur.getStart()
	finzac = finkon

hledejBlokZnovu:

	redim ALTsearchSKUP(14) &apos; delete the array with groups
	if ALTsearchPARAMS.zpet = 1 then &apos; set for backward direction
		HleDesc.SearchBackwards = true
		finkon = finzac  &apos;for the case of non-found next parts at backward search
	end if

	n = 0
	maxfind = ubound(find())  &apos; last group of search
	do while n &lt;= maxfind
		HleDesc.SearchString = find(n).hled &apos; searched string
		nulSkupina = false

		if (find(n).hled = &quot;&quot;)and(n&gt;0)and(find(n).pmode=1) then
			&apos; empty cursor for stretched group
			Found = finkon.text.createTextCursorByRange(finkon)
		else
			Found =  ALTsearchDOC.findNext(finkon, HleDesc) &apos; search from cursor
		end if

		&apos; possibility to interrupt
		FINDCOUNTER =   FINDCOUNTER + 1  &apos; counter of repeated search
		if FINDCOUNTER &lt; 0 then
			FindNextInBlock = -999  &apos; cancel, end
			exit sub
		end if
		if (FINDCOUNTER mod 25) = 0 then
			vypisStatusInfo()
		end if

&apos;appraise the found:

		&apos; search of character style inside the found paragraph - .atr=4 - it finds any part of text of entered style, also the anchors and fields
		if (not IsNull(Found)) and (find(0).atr = 4) then  &apos; the next isn&apos;t found - end
			&apos; backward isn&apos;t supported
			if ALTsearchPARAMS.zpet = 1 then
				FindNextInBlock = -2
				exit sub
			end if

			&apos; problem: function find &quot;.*&quot; doesn&apos;t find the anchors at start nor at end
			tCurs = found.text.createTextCursor()   &apos; for sure new cursor - else there wasn&apos;t functional directly enumeration in tables
			tCurs.gotorange(found.getStart(),false) &apos; cursor at the start of found block = paragraph
			tmprange = tCurs.getStart()  &apos; the start inside the paragraph - cursor can be after the start of paragraph

			if FINDCOUNTER = 2 then

				mistoChyby = 4
				tCurs.gotorange(finkon,false) &apos; cursor to the position where the searching starts
				chybaCharStyle: &apos;continue at bug of region if the cursor was before table

				&apos; the search starts directly on anchor of text filed, end/footnote
				if isObject(tcurs.textfield) then tmprange = tcurs.textfield.anchor  &apos; the start will be set on anchor
				if isObject(tcurs.endnote) then tmprange = tcurs.endnote.anchor
				if isObject(tcurs.footnote) then tmprange = tcurs.footnote.anchor

			else  &apos; some from anchors can be directly on start of paragraph of repeated search - the find ignores the anchors at start
				&apos; move the start of tCurs to left to real start of paragraph
				if not tCurs.isStartOfParagraph then tCurs.gotoStartOfParagraph(false)
				tmprange = tCurs.getStart()  &apos; remember new start - including anchors of fields

			end if

			tCurs.gotorange(found.getEnd(),false)
			&apos; move the start of tCurs to left to real end of paragraph
			if not tCurs.isEndOfParagraph then tCurs.gotoEndOfParagraph(false)

			&apos; set new range - paragraph inluding the anchors at start and end
			tCurs.gotorange(tmprange,true)

			Enum1 = tCurs.createEnumeration
			if Enum1.hasMoreElements then
				TextElement = Enum1.nextElement
				Enum2 = TextElement.createEnumeration
				While Enum2.hasMoreElements       &apos; loop over all paragraph portions
					TextPortion = Enum2.nextElement

					if find(0).cmd = &quot;NotDefaultCharStyleName&quot; then  &apos; search any character style excluding &quot;Default&quot;
						If (TextPortion.CharStyleName &lt;&gt; &quot;&quot;)  Then
							if  (TextPortion.string=&quot;&quot;) and not isNull(TextPortion.DocumentIndexMark) then goto dalsi &apos; the problem does the anchor (mark) of Index that has zero length of string - ignore

							stylNalezen = true
							&apos; if it is count regime then set for the next search and find next occurrence
							&apos; so long while something is found
							if fcount then

								&apos; detect if we aren&apos;t behind the end of block
								if ALTsearchPARAMS.csele=1 then  &apos; search inside the block - after end of block = end
									if (-1 = blockCur.text.compareRegionEnds(TextPortion, blockCur.getEnd)) then goto konbloku
								end if

								nCOUNT = nCOUNT + 1
								if mark then TextPortion.CharBackColor = BCOLOR  &apos; highlight with color if highlighting is activated
							else
								found = TextPortion
								ALTsearchSKUP(12) = getDisplayChName(found.CharStyleName)  &apos; \O = name of style
								goto chstylNalezen
							end if
						End If

					else   &apos; search entered style
						If (TextPortion.CharStyleName = find(0).chstyl)  Then
							if  (TextPortion.string=&quot;&quot;) and not isNull(TextPortion.DocumentIndexMark) then goto dalsi &apos; the problem does the anchor (mark) of Index that has zero length of string - ignore
							stylNalezen = true
							&apos; if it is count regime then set for the next search and find next occurrence
							&apos; so long while something is found
							if fcount then

								&apos; detect if we aren&apos;t behind the end of block
								if ALTsearchPARAMS.csele=1 then  &apos; search inside the block - after end of block = end
									if (-1 = blockCur.text.compareRegionEnds(TextPortion, blockCur.getEnd)) then goto konbloku
								end if

								nCOUNT = nCOUNT + 1
								if mark then TextPortion.CharBackColor = BCOLOR  &apos; highlight with color if highlighting is activated
							else
								found = TextPortion
								ALTsearchSKUP(12) = getDisplayChName(found.CharStyleName)  &apos; \O = name of style
								goto chstylNalezen
							end if
						End If

					end if

dalsi:

				Wend

				&apos; end of paragraph - aren&apos;t at its end some anchors of fields end/footnote that can have the character style?

			end if
			&apos; no found, try to find next paragraph
			finkon = found.End
			finzac = finkon
			stylNalezen = false
		end if

chstylNalezen:

		&apos; the search of words selected for Index inside the fond paragraph - .atr = 10 - any part of text of current style (also of anchor or field) is searched
		if (not IsNull(Found)) and (find(0).atr = 10) then  &apos; the next isn&apos;t found - end
			&apos; backward isn&apos;t supported
			if ALTsearchPARAMS.zpet = 1 then
				FindNextInBlock = -2
				exit sub
			end if

			&apos; adopt from chstyle, maybe ins&apos;t need for Indexes
			&apos; problem: function find &quot;.*&quot; doesn&apos;t find the anchors at start nor at end
			tCurs = found.text.createTextCursor()   &apos; for sure new cursor - else there wasn&apos;t functional directly enumeration in tables
			tCurs.gotorange(found.getStart(),false) &apos; cursor at the start of found block = paragraph
			tmprange = tCurs.getStart()  &apos; the start inside the paragraph - cursor can be after the start of paragraph

			if FINDCOUNTER = 2 then

				mistoChyby = 5
				tCurs.gotorange(finkon,false) &apos; cursor to the position where the searching starts
				chybaRejstrikStyle: &apos;continue at bug of region if the cursor was before table

			else  &apos; some from anchors can be directly on start of paragraph of repeated search - the find ignores the anchors at start
				&apos; move the start of tCurs to left to real start of paragraph
				if not tCurs.isStartOfParagraph then tCurs.gotoStartOfParagraph(false)
				tmprange = tCurs.getStart()  &apos; remember new start - including anchors of fields

			end if

			tCurs.gotorange(found.getEnd(),false)
			&apos; move the start of tCurs to left to real end of paragraph
			if not tCurs.isEndOfParagraph then tCurs.gotoEndOfParagraph(false)

			tCurs.gotorange(finkon,false) &apos; cursor to the position where the searching starts
			tCurs.gotorange(found.getend,true) &apos; the end of area to the end of paragraph

			Enum1 = tCurs.createEnumeration

			if Enum1.hasMoreElements then
				TextElement = Enum1.nextElement

				Enum2 = TextElement.createEnumeration
				While Enum2.hasMoreElements       &apos; loop over all paragraph portions
					TextPortion = Enum2.nextElement

					if find(0).cmd = &quot;&quot; then  &apos; search any index
						If isObject(TextPortion.getstart.DocumentIndexMark) Then

							rejstrikNalezen = true
							&apos; if it is count regime then set for the next search and find next occurrence
							&apos; so long while something is found
							if fcount then

								&apos; detect if we aren&apos;t behind the end of block
								if ALTsearchPARAMS.csele=1 then  &apos; search inside the block - after end of block = end
									if (-1 = blockCur.text.compareRegionEnds(TextPortion, blockCur.getEnd)) then goto konbloku
								end if

								nCOUNT = nCOUNT + 1
								if mark then TextPortion.CharBackColor = BCOLOR  &apos; highlight with color if highlighting is activated
							else

								found.gotoRange(TextPortion.DocumentIndexMark.anchor.getstart(), false)
								found.gotoRange(TextPortion.DocumentIndexMark.anchor.getend(), true)
								mistoChyby = 6
								goto nRejstrikNalezen
							end if
						End If

					else   &apos; search entered style
						If (TextPortion.CharStyleName = find(0).chstyl)  Then
							if  (TextPortion.string=&quot;&quot;) and not isNull(TextPortion.DocumentIndexMark) then goto dalsi &apos; the problem does the anchor (mark) of Index that has zero length of string - ignore
							rejstrikNalezen = true
							&apos; if it is count regime then set for the next search and find next occurrence
							&apos; so long while something is found
							if fcount then

								&apos; detect if we aren&apos;t behind the end of block
								if ALTsearchPARAMS.csele=1 then  &apos; search inside the block - after end of block = end
									if (-1 = blockCur.text.compareRegionEnds(TextPortion, blockCur.getEnd)) then goto konbloku
								end if

								nCOUNT = nCOUNT + 1
								if mark then TextPortion.CharBackColor = BCOLOR  &apos; highlight with color if highlighting is activated
							else
								found = TextPortion
								goto nRejstrikNalezen
							end if
						End If

					end if

rdalsi:

				Wend

				&apos; end of paragraph - aren&apos;t at its end some anchors of fields end/footnote that can have the character style?

			end if
			&apos; no found, try to find next paragraph
			finkon = found.End
			finzac = finkon
			rejstrikNalezen = false
		end if

nRejstrikNalezen:

		&apos; next occurrence not found - detect if there isn&apos;t exception for stretched block x* or []* x? or \{0,nn}
		&apos; the exception isn&apos;t for single stretched group:      ... and (maxfind&gt;0), else could be eternal cycle
		if IsNull(Found) and (find(n).nmode = 1) and (maxfind&gt;0) then
VyjimkaNalezeno:
			prCURS = finkon.text.createTextCursor()  &apos; for sure new cursor
			zac = finkon &apos; remember original selection
			kon = finkon
			nulSkupina = true &apos; flag that it is group with zero length for exception
			foundStr = &quot;&quot;
			goto jakobyNalezeno
		end if

		&apos; the block was chosen and it is allowed the search in block, so alert to the end of block
		if ALTsearchPARAMS.csele=1 then

			mistoChyby=1 &apos;the distinguishing of place of bug of comparison of region 1=search in block; 2=search of parts
			if ALTsearchPARAMS.zpet = 1 then &apos; various comparison of region for backward search
				if IsNull(Found) then goto zacbloku: &apos; not found, start
				if (1 = blockCur.text.compareRegionStarts(Found, blockCur.getStart)) then
zacbloku:
					&apos; detect if there isn&apos;t exception for stretched block x* or []* x? or \{0,nn}
					&apos; nmode - is the flag of group that has exception at no found; umode - stretched group
					if (find(n).nmode = 1)and(find(n).umode &lt;&gt; 0) then goto VyjimkaNalezeno &apos; continue in search of next group

					prCURS = blockCur.text.createTextCursorByRange(blockCur)
					FindNextInBlock = -1  &apos; not found to the start of block
					exit sub
				end if
			else
				if IsNull(Found) then goto konbloku:  &apos; no found, end
				if (-1 = blockCur.text.compareRegionEnds(Found, blockCur.getEnd)) then
konbloku:
					&apos; detect if there isn&apos;t exception for stretched block x* or []* x? or \{0,nn}
					if (find(n).nmode = 1)and(find(n).umode &lt;&gt; 0) then goto VyjimkaNalezeno &apos; continue in search of next group

					prCURS = blockCur.text.createTextCursorByRange(blockCur)
					FindNextInBlock = 1  &apos; not found to the end of block
					exit sub
				end if
			end if
		end if

pokracujZaBlok:

		if (not IsNull(Found)) and (find(0).atr = 4) and (not stylNalezen) then goto hledejBlokZnovu    &apos; not found the character style in paragraph, so search in next paragraph

		if (not IsNull(Found)) and (find(0).atr = 10) and (not RejstrikNalezen) then goto hledejBlokZnovu    &apos; item of entered nema of Index in paragraph isn&apos;t found, search in next paragraph

		if IsNull(Found) then  &apos; the next isn&apos;t found - end
nofound:
			prCURS = ALTsearchDOC.text.createTextCursor()
			if ALTsearchPARAMS.zpet = 1 then &apos; search reversed cursor at backward search
				prCURS.gotorange(ALTsearchDOC.text.getEnd(),false) &apos; cursor to the end of document
				FindNextInBlock = -2
				exit sub
			else
				prCURS.gotorange(ALTsearchDOC.text.getStart(),false) &apos; cursor to the start of document
				FindNextInBlock = 2
				exit sub
			end if
		end if

		prCURS = found.text.createTextCursor()  &apos; for sure new cursor
		zac = found.getStart() &apos; remember original selection
		kon = found.getEnd()
		foundStr = found.string

		if find(n).pgBreak &gt; 0 then  &apos; search the Break of page/column
			if NoFoundBreak(found,find(n).pgBreak) then goto hledejDalsi
			if (HleDesc.SearchString=&quot;$&quot;)and(find(n).pgBreak=1) then &apos; if only the mark of paragraph is searched
				zac = found.getEnd   &apos; zero selection to let the cursor discover at the start of paragraph with Break
				&apos; but the search doesn&apos;t continue for the search at empty paragraphs
			end if

		end if

		if find(n).pmode &lt;&gt; 0 then  &apos; the process of paragraphs \p = extend the selection according the paragraphs
			if (find(n).pmode = -1) then  &apos;the paragraphs at the start: find the start of paragraph
				if NoFoundBlokOdst(zac, find(n).pmin, find(n).pmax, true) then goto hledejDalsi
				zac = prCURS.getStart()
			end if
			if (find(n).pmode = 1) then  &apos;paragraphs at the end: find the ends of paragraph
				if NoFoundBlokOdst(kon, find(n).pmin, find(n).pmax, false) then goto hledejBlokZnovu
				kon = prCURS.getStart()
			end if

			if (find(n).pmode = 16) then  &apos;single paragraph or group - without text
				if (find(n).pmin=1) and (find(n).pmax=1) then &apos; 1. non-empty paragraph
					prCURS.gotoRange(kon,false)
				else &apos; 2 or more empty paragraphs
					if HleDesc.SearchBackwards then &apos; backward - find 1. character of paragraph
						prCURS.gotoRange(zac,false) &apos; counted also 1st empty paragraph
						prCURS.goRight(1,false)     &apos; i.e. return to 1 back
						zac = prCURS.getStart()
						if NoFoundBlokOdst(zac, find(n).pmin, find(n).pmax, true) then
							zac = prCURS.getStart()
							goto hledejDalsi
						end if
						kon = prCURS.getStart()

					else   &apos; the direction is forward
						if NoFoundBlokOdst(zac, find(n).pmin, find(n).pmax, false) then goto hledejDalsi
						kon = prCURS.getStart()
					end if
				end if
			end if

		end if

jakobyNalezeno:
		&apos; found 1st passing
		if n = 0 then
			&apos; always forward direction for every next item in search
			HleDesc.SearchBackwards = false
			&apos; save the start and end of 1st found block
			finzac = zac &apos; zac = the start of currently found string
			finkon = kon &apos; kon = the end of currently found string
			if find(n).umode = 1 then  &apos; the part of text like non-ended group .+ or +*
				&apos; so there is found text till to the end if paragraph
				uskupB = zac &apos; remember the start of non-ended group
				uskupE = kon &apos; remember the end of non-ended group
				&apos;if there is found less count of characters than for group then it is the same like no found, so find further
				if len(foundStr) &lt; find(n).pmin  then goto hledejBlokZnovu &apos; search next after the end of last success found
				&apos; search next group after the minimal count of characters
				prCURS.gotoRange(zac,false)
				prCURS.goRight(find(n).pmin,false) &apos; move behind the minimum
				finkon = prCURS.getStart()   &apos; prepare for next search
			end if

		else  &apos; kazda dalsi nalezena cast musi nasledovat hned za predchozi
			&apos; konec predchoziho musí byt zacatkem nasledujiciho
			mistoChyby=2  &apos; the distinguishing of place of bug of comparison of region 1=search in block; 2=search of parts
			select case find(n).umode
			case 0  &apos; normalní ukoncena skupina
				if 0 = finkon.text.compareRegionStarts(finkon.getStart(),zac.getStart()) then
					finkon = kon  &apos;found.getEnd()  &apos; prepare for next search
				else  &apos; nesouhlasi, konec
					if find(n).nmode=1 then  &apos; pretend found if the zero length of section of text is enabled using * ? or \{0,nn}
						&apos; finkon = finkon
						foundStr = &quot;&quot;
					else
						goto hledejBlokZnovu &apos; search next after the end of last success found
					end if
				end if

			case 1  &apos; the part of text like non-ended group .+ or +*
				&apos; so there is found text till to the end if paragraph
				uskupB = zac &apos; remember the start of non-ended group
				uskupE = kon &apos; remember the end of non-ended group
				&apos;if there is found less count of characters than for group then it is the same like no found, so find further
				if len(foundStr) &lt; find(n).pmin  then goto hledejBlokZnovu &apos; search next after the end of last success found
				&apos; search next group after the minimal count of characters
				prCURS.gotoRange(zac,false)
				prCURS.goRight(find(n).pmin,false) &apos; move behind the minimum
				finkon = prCURS.getStart()   &apos; prepare for next search

			case -1 &apos; skupina nasledujicí za neukoncenou .+ or +*
				&apos; blok textu nalezeny ZA predchozi neukoncenou casti textu musi zacinat pred koncem teto skupiny nebo právě na jejím konci
				if finkon.text.compareRegionEnds(zac.getStart(),uskupE.getStart()) &gt;= 0 then
					&apos; build the string of non-ended (previous) part of text of group
					prCURS.gotoRange(uskupB,false)
					if nulSkupina then &apos; skupina nulove delky, vracena pri hledani uvnitr bloku
						prCURS.gotoRange(uskupE,true)
						kon = uskupE
					else
						prCURS.gotoRange(zac.getStart(),true)
					end if
					ALTsearchSKUP(find(n-1).skup) = ALTsearchSKUP(find(n-1).skup) &amp; prCURS.string
					finkon = kon  &apos;found.getEnd()  &apos; prepare for next search

				else  &apos; disagree next block starts after the end of previous one =&gt; end
					if find(n).nmode=1 then  &apos; pretend found if the zero length of section of text is enabled using * ? or \{0,nn}
						&apos; build the string of non-ended (previous) part of text of group
						prCURS.gotoRange(uskupB,false)
						prCURS.gotoRange(uskupE,true)
						ALTsearchSKUP(find(n-1).skup) = ALTsearchSKUP(find(n-1).skup) &amp; prCURS.string
						finkon = uskupE
						foundStr = &quot;&quot;
					else
						goto hledejBlokZnovu &apos; search next after the end of last success found
					end if

				end if

			end select

		end if

		&apos; build found groups
		if find(n).umode &lt;= 0 then
			ALTsearchSKUP(find(n).skup) = ALTsearchSKUP(find(n).skup) &amp; foundStr
		end if

		n = n+1
	loop

	&apos; really found

	&apos; build last non-ended group if the searched string ends with one
	if find(n-1).umode = 1 then &apos; last was non-ended block of text
		ALTsearchSKUP(find(n-1).skup) = ALTsearchSKUP(find(n-1).skup) &amp; foundStr
	end if

	&apos; if the hyperlink is found then detect the URL contains entered substring
	if find(0).pstyl&lt;&gt;&quot;&quot; then  &apos; searched substring saved in .pstyl
		if ALTsearchPARAMS.kcase=0 then &apos;bin=1 instr(,,bin) ignores case sensitivity, BIN=0 binary comparison
			n = instr(found.HyperLinkURL,find(0).pstyl)     &apos;not functional from version 2.4 with finkon  n = instr(finkon.HyperLinkURL,find(0).pstyl)
		else  &apos; respect case sensitivity
			n = instr(1,found.HyperLinkURL,find(0).pstyl,0)  &apos;not functional from version 2.4 with finkon  n = instr(1,finkon.HyperLinkURL,find(0).pstyl,0)
		end if
		if n&lt;1 then goto hledejBlokZnovu &apos; search next after the end of last success found
	end if

	if lgrow &lt;&gt; &quot;&quot; then  &apos; enlargement of selection from left
		prCURS.gotoRange(finzac,false)
		if lgrow=&quot;par&quot; then &apos; from the start of paragraph
			prCURS.gotoStartOfParagraph(false)
		else
			if val(lgrow)&gt;0 then
				prCURS.goLeft(val(lgrow),false)
			else
				prCURS.goRight(-1*val(lgrow),false)
			end if
		end if
		finzac = prCURS.getStart()
	end if

	if rgrow &lt;&gt; &quot;&quot; then  &apos; enlargement of selection from right
		prCURS.gotoRange(finkon,false)
		if rgrow=&quot;par&quot; then &apos; from the start of paragraph
			prCURS.gotoEndOfParagraph(false)
		else
			if val(rgrow)&gt;0 then
				prCURS.goRight(val(rgrow),false)
			else
				prCURS.goLeft(-1*val(rgrow),false)
			end if
		end if
		finkon = prCURS.getStart()
	end if

	&apos; set cursor
	prCURS.gotorange(finzac,false)   &apos; cursor to the start of found block
	prCURS.gotorange(finkon,true)    &apos; cursor to the end of found block and highlight

	chybaRejstrik:  &apos; experimental service

	&apos; was searched the text of definite character style?
	if find(0).atr = 3 then  &apos;agree the searched style?
		if prCURS.CharStyleName &lt;&gt; find(0).chstyl then  &apos;agree the searched style?
			goto hledejBlokZnovu
		end if
		ALTsearchSKUP(12) = getDisplayChName(prCURS.CharStyleName)
	end if

	&apos; was searched the text of definite list style?
	if find(0).atr = 5 then  &apos;agree the searched style?
		if prCURS.NumberingStyleName &lt;&gt; find(0).chstyl then goto hledejBlokZnovu &apos;agree the searched style?
		ALTsearchSKUP(12) = getDisplayNumName(prCURS.NumberingStyleName)
	end if

	&apos; was searched the text of any list style?
	if find(0).atr = 6 then  &apos;agree the searched style?
		if prCURS.NumberingStyleName = &quot;&quot; then goto hledejBlokZnovu &apos;agree the searched style?
		ALTsearchSKUP(12) = getDisplayNumName(prCURS.NumberingStyleName)
	end if

	&apos; was searched the text of definite paragraph style?
	if find(0).atr = 7 then  &apos;agree the searched style?
		if prCURS.ParaStyleName &lt;&gt; find(0).chstyl then goto hledejBlokZnovu &apos;agree the searched style?
		ALTsearchSKUP(12) = getDisplayPName(prCURS.ParaStyleName)
	end if

	&apos; was searched the text of any paragraph style except for &quot;Default&quot;?
	if find(0).atr = 8 then  &apos;
		if prCURS.ParaStyleName = &quot;Standard&quot; then goto hledejBlokZnovu &apos;ignore default
		ALTsearchSKUP(12) = getDisplayPName(prCURS.ParaStyleName)
	end if

	&apos; was search something to definite name of Index
	if find(0).atr = 9 then  &apos;
		if isObject(prCURS.getStart.DocumentIndexMark) then
			pomo = getNameOfIndex(prCURS.getStart.DocumentIndexMark) &apos; name of label of Index ()
			&apos; is it searched name of Index?
			if find(0).chstyl = &quot;&quot; then  &apos; without name = search all
				ALTsearchSKUP(12) = pomo &apos; nazev
				ALTsearchSKUP(11) = prCURS.getStart.DocumentIndexMark.anchor.string  &apos;whole string selected for index
			else
				if find(0).chstyl = pomo then  &apos; satisfy the entered name?
					ALTsearchSKUP(12) = pomo
					ALTsearchSKUP(11) = prCURS.getStart.DocumentIndexMark.anchor.string  &apos;whole string selected for index
				else
					goto hledejBlokZnovu   &apos; like no found
				end if
			end if

		else
			goto hledejBlokZnovu
		end if

	end if

	&apos; if it is count regime then set for the next search and find next occurrence
	&apos; so long while something is found
	if fcount then
		nCOUNT = nCOUNT + 1
		if mark then prCURS.CharBackColor = BCOLOR  &apos; highlight with color if highlighting is activated
		goto hledejBlokZnovu
	end if

	FindNextInBlock = 0
	&apos; zero group = all found
	ALTsearchSKUP(0) = prCURS.string
	&apos; 10 record of original URL address for \u
	ALTsearchSKUP(10) = prCURS.HyperLinkURL

	exit sub

hledejDalsi: &apos; it searches next occurrence if some condition isn&apos;t fulfilled (for examples the minimums) - during the search of paragraphs, Breaks?
	finzac = zac
	finkon = kon
	goto hledejBlokZnovu

	Errobsluha: &apos; error 1: bug of region = found outside of border of limiting block
	if (Err=1) or (Err=0) then
		select case  mistoChyby  &apos; the distinguishing of place of bug of comparison of region 1=search in block; 2=search of parts

		case 1 &apos;bug during search in block - bug of region;
			&apos; if found in table, is table inside the selection? If yes then continue search else end of block
			tabIsIn = false
			if not isNull(found) then
				if not isEmpty(found.TextTable) then
					oTmp = found.TextTable  &apos; object of table
					oAnch = getTextRangeOfTable(oTmp)  &apos; anchor back to the text
					&apos; obnovit původní rozsah
					oVCURS.gotoRange(ALTSiniSEL.getstart(),false) &apos;
					oVCURS.gotoRange(ALTSiniSEL.getEnd(),true) &apos;
					if isInsideOfSelection(oAnch) then tabIsIn = true
				end if
			end if

			if HleDesc.SearchBackwards then &apos; backward
				if tabIsIn then
					resume pokracujZaBlok
				else
					resume zacbloku
				end if

			else  &apos; search forward
				if tabIsIn then
					resume pokracujZaBlok
				else
					resume konbloku
				end if

			end if
		case 2 &apos;bug during the search for parts
			resume hledejBlokZnovu

		case 3 &apos; bug at loading the attribute of array SRCHATR()
			&apos; unsupported properties if search attributes
			hlaseni1(48, true, false, &quot;FindNextInBlock:  &quot; &amp; MSG(10)) &apos;  16=stop 32=? 48=! 64=info; may suppress; cancel the activities

		case 4 &apos;bug during the search of character style - the search starts at the end of paragraph before table
			resume chybaCharStyle  &apos; continue normally

		case 5 &apos;bug during the search of words of Index - the search starts at the end of paragraph before table
			resume chybaRejstrikStyle  &apos; continue normally

		end select

	else
		hlaseni1(48, true, false, &quot;FindNextInBlock:  Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error$ &amp; &quot; (line: &quot; &amp; Erl &amp; &quot;)&quot;) &apos;  16=stop 32=? 48=! 64=info; may suppress; cancel the activities
		resume next
	end if
end sub


	&apos; it searches the substring limiting PreString, PostString; if it doesn&apos;t find PostString then it returns the string from pre to the end
Function FindPartStr(BigString, PreString, PostString as String, SearchPos as Integer) as String
	Dim StartPos%, EndPos%
	Dim BigLen%, PreLen%, PostLen%
	StartPos = Instr(SearchPos,BigString,PreString)
	If StartPos &lt;&gt; 0 Then
		PreLen = Len(PreString)
		EndPos = Instr(StartPos + PreLen,BigString,PostString)
		BigLen = Len(BigString)
		If EndPos &lt;&gt; 0 Then
			PostLen = Len(PostString)
			SearchPos = EndPos + PostLen
			FindPartStr = Mid(BigString,StartPos + PreLen, EndPos - (StartPos + PreLen))
		Else &apos; uzaviraci nenalezen
			SearchPos = BigLen
			FindPartStr = Right(BigString, BigLen - StartPos - PreLen + 1)
		End If
	Else
		FindPartStr = &quot;&quot;
	End If
End Function


	&apos; it returns the number that determines the type of found string according to uppercases
	&apos; 1st UPPERcase, rest lowercase= 1
	&apos; all UPPERcase = 2
	&apos; the rest = 0
sub getCapitalType(pCurs as object) as byte
	dim pom, i, ch
	dim v, prvniVelke
	v = 0 : prvniVelke = false
	getCapitalType = 0
	on error goto konec
	pom = pCurs.string
	if pom = &quot;&quot; then exitsub
	if ALTsearchPARAMS.preservecap &lt;&gt; 1 then exit sub  &apos; not active the choice = away

	for i = 1 to len(pom)
		ch = mid(pom,i,1)
		if ch = ucase(ch) then
			v = v + 1 &apos; count of uppercases

			prvniVelke = (i = 1)
		end if

	next i

	if len(pom) = v then getCapitalType = 2
	if prvniVelke then getCapitalType = 1

konec:
end sub


	&apos; it returns the string of properties for search that are equal with entered cursor
sub getCharProperties(curs as object, value as boolean) as string
	dim prop  &apos; the array with the list of checked character properties
	prop = array(&quot;CharAutoEscapement&quot;,&quot;CharAutoKerning&quot;,&quot;CharBackColor&quot;,&quot;CharBackTransparent&quot;,&quot;CharCaseMap&quot;,&quot;CharColor&quot;,&quot;CharCombineIsOn&quot;,_
	&quot;CharCombinePrefix&quot;,&quot;CharCombineSuffix&quot;,&quot;CharContoured&quot;,&quot;CharCrossedOut&quot;,_
	&quot;CharEmphasis&quot;,&quot;CharEscapement&quot;,&quot;CharEscapementHeight&quot;,&quot;CharFlash&quot;,_
	&quot;CharFontName&quot;,&quot;CharHeight&quot;,&quot;CharHidden&quot;,&quot;CharKerning&quot;,_
	&quot;CharLocale&quot;,&quot;CharNoHyphenation&quot;,&quot;CharPosture&quot;,&quot;CharRelief&quot;,&quot;CharRotation&quot;,_
	&quot;CharRotationIsFitToLine&quot;,&quot;CharScaleWidth&quot;,&quot;CharShadowed&quot;,&quot;CharStrikeout&quot;,&quot;CharUnderline&quot;,_
	&quot;CharUnderlineColor&quot;,&quot;CharUnderlineHasColor&quot;,&quot;CharWeight&quot;,&quot;CharWordMode&quot;)

	dim cursor, oPStyl as object
	dim parStState, sezn, para, st, vl
	dim i,nam

	Cursor = oVCURS.getEnd &apos;pointer to the end, visible cursor

	&apos; get paragraph style
	parStState = cursor.getPropertyState(&quot;ParaStyleName&quot;)

	para=cursor.getPropertyValue(&quot;ParaStyleName&quot;)
	&apos; object of current paragraph style
	oPStyl = ALTsearchDOC.StyleFamilies.getByName(&quot;ParagraphStyles&quot;).getByName(para)

	sezn=&quot;&quot; &apos; result string
	for i = LBound(Prop) to UBound(Prop)
		nam=prop(i) &apos; the name of tested property
		st=cursor.getPropertyState(nam) &apos; the state of this property in the place of cursor
		vl=cursor.getPropertyValue(nam) &apos; value of property
		if (st&lt;&gt;1) then
			if value then nam=nam &amp; &quot;=&quot; &amp; cstr(vl) &apos; add the value of property
			if sezn=&quot;&quot; then
				sezn = nam
			else
				sezn = sezn &amp; &quot;|&quot; &amp; nam  &apos;
			end if

		else &apos; still verify if the paragraph style is seamless
			if  not isSameProperties(parStState,nam,cursor,oPStyl) then
				if value then nam=nam &amp; &quot;=&quot; &amp; cstr(vl) &apos; add the value of property
				if sezn=&quot;&quot; then
					sezn = nam
				else
					sezn = sezn &amp; &quot;|&quot; &amp; nam  &apos;
				end if

			end if

		end if

	next i

	if sezn = &quot;&quot; then
		sezn = &quot;CharWeight&quot;
		if value then sezn=sezn &amp; &quot;=&quot; &amp; cstr(cursor.getPropertyValue(sezn)) &apos; add the value of property
	end if
	getCharProperties = sezn
end sub


	&apos; fill the variables cmd = if starts with &quot;[::&quot; and ends with &quot;::]&quot;;
	&apos; rest = the rest after &quot;::]&quot;
sub getCmdRest(prikaz,cmd,rest)
	dim p as long
	p = instr(prikaz,&quot;[::&quot;)
	if p &lt;&gt; 1 then goto nic &apos; command at the start of string
	p = instr(prikaz,&quot;::]&quot;)
	if p &lt;= 3 then goto nic &apos; no closed string
	cmd = left(prikaz,p+2)
	rest = right(prikaz, len(prikaz)-p-2)
	exit sub
nic:
	cmd = &quot;&quot;
	rest = prikaz
end sub


	&apos; return the localized name of character style
sub getDisplayChName(styleName) as string
	dim oStyles
	getDisplayChName = &quot;&quot;
	on error goto konec
	&apos; rodina stylu
	oStyles = ALTsearchDOC.StyleFamilies.getByName(&quot;CharacterStyles&quot;,)
	getDisplayChName = oStyles.getByName(styleName).DisplayName

konec:
end sub


	&apos; return the localized name of character style
sub getDisplayNumName(styleName) as string
	dim oStyles
	getDisplayNumName = &quot;&quot;
	on error goto konec
	&apos; rodina stylu
	oStyles = ALTsearchDOC.StyleFamilies.getByName(&quot;NumberingStyles&quot;,)
	getDisplayNumName = oStyles.getByName(styleName).DisplayName

konec:
end sub


	&apos; return the localized name of paragraph style
sub getDisplayPName(styleName) as string
	dim oStyles
	getDisplayPName = &quot;&quot;
	on error goto konec
	&apos; rodina stylu
	oStyles = ALTsearchDOC.StyleFamilies.getByName(&quot;ParagraphStyles&quot;)
	getDisplayPName = oStyles.getByName(styleName).DisplayName

konec:
end sub


	&apos;analyze the found string completely and return the input array for FindNextInBlock
function getFindArray(byval find as string, skupiny as boolean) as  tFind
	dim pom(0) as tFind
	dim pp(), cmd, rest
	dim  i, n, nMode as long
	dim cr1, pomo as string
	dim attrnames()
	dim chstyles   &apos; work variable for the checking of searched styles
	dim sStyle$

	redim SRCHATR() &apos; empty array of search of attribute
	pom(0).atr = 0
	&apos; cr1 = chr(182) &apos;182 for debugging, for real 13
	cr1 = chr(13)

	&apos;1. search of the single (block) paragraphs:  .hled = &quot;$&quot;   .pmode = 16  + .pmin a .pmax
	&apos;2. search of blocks of paragraphs after 1st or between texts:  .hled = &quot;&quot;   .pmode = 1  + .pmin a .pmax
	&apos;3. search of blocks of paragraphs before 1st text:  .hled = &quot;text&quot;   .pmode = -1  + .pmin a .pmax
	&apos;4. search the Break of page/column: .hled = &quot;text on Break&quot; nebo .hled = &quot;$&quot; any paragraph;  .pgBreak = 1 or 2

	if ALTsearchPARAMS.reg &lt;&gt; 1 then &apos; no regexps
		pom(0).hled = find
		getFindArray() = removeZero( pom() ) &apos; bug #74
		exit function
	end if

	&apos;1. fond out the GROW
	pp() = getGrow(find)
	pom(0).lgrw = pp(1)
	pom(0).rgrw = pp(2)

	&apos;2. special commands at the start of line
	getCmdRest(pp(0),cmd,find) &apos; put values of cmd to the 2nd and 3rd variableand a rest of text for search
	pom(0).cmd = cmd

	&apos;3. search according to attributes
	if 1 = instr(cmd,&quot;[:::&quot;) then
		i = instr(cmd,&quot;::]&quot;)
		if i &gt; 8 then  &apos;attributes are entered
			cmd = mid(cmd,5,i-5)  &apos;in the form command1=value1|command2..|....

			&apos;special service for search of Character Styles
			if left(cmd,13) = &quot;CharStyleName&quot; then
				pom(0).cmd = &quot;&quot;
				chstyles = ALTsearchDOC.StyleFamilies.getByName(&quot;CharacterStyles&quot;)
				pomo = rightpast(cmd,&quot;CharStyleName=&quot;)  &apos;name of found style
				&apos;style exists?
				sStyle=getRealStyleName(&quot;CharacterStyles&quot;, pomo) &apos;get .Name if found name of style is .DisplayName
				if sStyle&lt;&gt;&quot;&quot; then &apos;yes
					pom(0).chstyl = chstyles.getByName(sStyle).name  &apos;save the .Name of style (no .DisplayName)
					if chstyles.ElementNames(0) = pom(0).chstyl then pom(0).chstyl = &quot;&quot;
				else &apos;non-existing name of style
					&apos;message about bug? - provisionally let original unsupported
					pom(0).chstyl = pomo
					if pomo = &quot;&quot; then  &apos;find all styles instead of &quot;Deafult&quot;
						pom(0).cmd = &quot;NotDefaultCharStyleName&quot;
					end if
				end if

				if find = &quot;&quot; then &apos; 4=find whatever part of entered Character Style
					pom(0).atr = 4
					pom(0).hled = &quot;.*&quot;
				else  &apos; 3=find definite text of entered Character Style
					pom(0).atr = 3
				end if
				goto preskocAtr  &apos;jumpover the rest - for now: probably isn&apos;t possible to combine
			end if

			&apos; special service for search of words highlighted for Index
			if left(cmd,17) = &quot;DocumentIndexMark&quot; then
				pom(0).cmd = &quot;&quot;

				pomo = rightpast(cmd,&quot;DocumentIndexMark=&quot;)  &apos; name of searched Index
&apos; it could be good to detect if exists, but I don&apos;t know how so:
				pom(0).chstyl = pomo

				if find = &quot;&quot; then &apos; 10=search any part of entered character name of Index
					pom(0).atr = 10
					pom(0).hled = &quot;.*&quot;
				else  &apos; 9= search definite entered text of entered name of Index
					pom(0).atr = 9
				end if

				goto preskocAtr  &apos; jump the rest - probably it isn&apos;t possible to combine it for now
			end if

			&apos; special service for search of numbering - bullets
			if left(cmd,18) = &quot;NumberingStyleName&quot; then
				pom(0).cmd = &quot;&quot;
				if find = &quot;&quot; then
					if ALTsearchPARAMS.zpet = 1 then
						find = &quot;^.*&quot; &apos; search whole paragraph if isn&apos;t entered
					else
						find = &quot;.*&quot; &apos; search whole paragraph if isn&apos;t entered
					end if
				end if
				chstyles = ALTsearchDOC.StyleFamilies.getByName(&quot;NumberingStyles&quot;)
				pomo = rightpast(cmd,&quot;NumberingStyleName=&quot;)  &apos; the name of searched style
				&apos; does this style exist ?
				sStyle=getRealStyleName(&quot;NumberingStyles&quot;, pomo) &apos;get .Name if found name of style is .DisplayName
				if sStyle&lt;&gt;&quot;&quot; then &apos;yes
					pom(0).chstyl = chstyles.getByName(sStyle).name  &apos; save then name of searched style (no displayname)
					pom(0).atr = 5
				else &apos;non existed name of style or without the name of style = any included system ones
					pom(0).chstyl = pomo
					pom(0).atr = 6
				end if

				goto preskocAtr  &apos; jump the rest - probably it isn&apos;t possible to combine it for now
			end if

			&apos; special service for search of paragraph styles
			if left(cmd,13) = &quot;ParaStyleName&quot; then
				pom(0).cmd = &quot;&quot;
				if find = &quot;&quot; then
					if ALTsearchPARAMS.zpet = 1 then
						find = &quot;^.*&quot; &apos; search whole paragraph if isn&apos;t entered
					else
						find = &quot;.*&quot; &apos; search whole paragraph if isn&apos;t entered
					end if
				end if
				chstyles = ALTsearchDOC.StyleFamilies.getByName(&quot;ParagraphStyles&quot;)
				pomo = rightpast(cmd,&quot;ParaStyleName=&quot;)  &apos; the name of searched style
				&apos; does this style exist ?
				sStyle=getRealStyleName(&quot;ParagraphStyles&quot;, pomo) &apos;get .Name if found name of style is .DisplayName
				if sStyle&lt;&gt;&quot;&quot; then &apos;yes
					pom(0).chstyl = chstyles.getByName(sStyle).name  &apos; save then name of searched style (no displayname)
					pom(0).atr = 7
				else &apos;non-existed name of style or without one = any except of default
					pom(0).chstyl = pomo
					pom(0).atr = 8
				end if

				goto preskocAtr  &apos; jump the rest - probably it isn&apos;t possible to combine it for now
			end if

			pom(0).atr = 0  &apos;1 is for search of exact values
			&apos; create array for attributtes here
			attrnames() = ArrayOutOfString_(cmd, &quot;|&quot;)
			dim SrchAtrTmp(ubound(attrnames())) as new com.sun.star.beans.PropertyValue
			for i = 0 to ubound(attrnames())
				n = instr(attrnames(i),&quot;=&quot;) &apos; find out if also the values are entered
				if n&gt;0 then &apos; yes, name of attribute and also value
					pomo = right(attrnames(i),len(attrnames(i))-n) &apos; value
					pom(0).atr = 1  &apos;1 is for search of exact values = 1 &apos; search exact value
					SrchAtrTmp(i).Name = left(attrnames(i),n-1)
					SrchAtrTmp(i).Value = getPrValue(pomo)  &apos; return the relevant data type for value
					&apos; the exception for search of substring in Url of hyperlink
					if SrchAtrTmp(i).Name = &quot;HyperLinkURL&quot; then
						pom(0).atr = 0  &apos; search only generally the all hyperlinks
						pom(0).pstyl = SrchAtrTmp(i).Value &apos; if is non-empty then search the substring in addition
						SrchAtrTmp(i).Value = &quot;&quot;
					end if

				else  &apos; only the name of attribute
					SrchAtrTmp(i).Name = attrnames(i)
				end if

			next i
			SRCHATR() = SrchAtrTmp()
			pom(0).cmd = &quot;&quot;
		end if
	end if

	rem fix: bug #59 https://github.com/gitxpy/libreoffice-alt-search/issues/59
	if 1 = instr(cmd,&quot;[::&quot;) then goto noReplace &apos;there is searching of [::SomeObject::]
	
preskocAtr:
	&apos; find = replace_(find,&quot;\\&quot;,&quot;\x005C&quot;)  &apos; substitute the special character to hexa codes
	&apos; find = replace_(find,&quot;\\&quot;,&quot;\&quot;)  &apos; substitute the special character to hexa codes
	find = replace_(find,&quot;\(&quot;,&quot;\x0028&quot;)  &apos; normal brackets, not for groups ()
	find = replace_(find,&quot;\)&quot;,&quot;\x0029&quot;)  &apos; normal brackets, not for groups ()
	find = replace_(find,&quot;\^&quot;,&quot;\x005E&quot;)  &apos; character ^
	find = replace_(find,&quot;\+&quot;,&quot;\x002B&quot;)  &apos; character +
	find = replace_(find,&quot;\*&quot;,&quot;\x002A&quot;)  &apos; character *
	find = replace_(find,&quot;\|&quot;,&quot;\x007C&quot;)  &apos; separator OR
	find = replaceC(find,&quot;\S&quot;,chr(160))   &apos; nbsp
	find = replaceC(find,&quot;\s&quot;,&quot;[ \xA0\x09\x0A]&quot;)   &apos;white spaces: tabulator,line-break, space, nbsp
	find = replace_(find,&quot;\[&quot;,&quot;\x005B&quot;)   &apos; left bracket [
	find = replaceC(find,&quot;\d&quot;,&quot;[0-9]&quot;)&apos; abbreviation for search of numbers
	find = replaceC(find,&quot;\l&quot;,&quot;[:alpha:]{1,1}&quot;)   &apos;abbreviation for some letter

	find = replDec2hex(find) &apos; substitution dec of assignment \d
	&apos;\n Line Break and \t tabulator don&apos;t need OOo does it automatically
	find = replaceC(find,&quot;\x000D&quot;,chr(13))   &apos; character of paragraph
	find = replaceC(find,&quot;\x000d&quot;,chr(13))   &apos; character of paragraph
	find = replaceC(find,&quot;\p&quot;,chr(13))   &apos; character the paragraph

	&apos; hook - already some years there isn&apos;t possible to search \x00AD (\#173) = soft hyphen
	&apos; replace directly with character - it was functional for now
	&apos; not possible to fix - if the regexps are active then it doesn&apos;t find nor \xAD, \u00AD, chr(173)
	&apos; find = replaceC(find,&quot;\x00AD&quot;,chr(173))

noReplace:

	if ICUcompatability then  find = replace_x2u(find)   &apos; use the syntax of ICU regexp (International Components for Unicode)  \xhhhh =&gt; \uhhhh

&apos;debug:
	&apos; find = replace_(find,&quot;\x000d&quot;,&quot;¶&quot;)   &apos; character of paragraph
	&apos; find = replace_(find,&quot;\p&quot;,&quot;¶&quot;)   &apos; character the paragraph

	&apos; the groups are turned off and the object is searched
	&apos; so recode back from hex to characters and end; not valid for NotDefaultCharStyleName = searchong of all character styles
	if (pom(0).cmd &lt;&gt; &quot;&quot;) and (not skupiny) and (not (pom(0).cmd = &quot;NotDefaultCharStyleName&quot;)) then
		pom(0).hled = prepis_hex(find)
		getFindArray() = removeZero( pom() ) &apos; bug #74
		exit function
	end if

	&apos; split the rest inside find to parts according to paragraphs \p and according to groups ()
	dim skup, uroven &apos; inside the group () and the level of nesting of brackets
	dim ch as string
	dim meta()
	dim lenFind, l,r as long

	&apos; emptying of outer brackets - OOo doesn&apos;t find correctly the start of paragraph &quot;^&quot; if there is bracket &quot;(&quot; before one
	&apos; remove outer brackets if the groups are turned off
	&apos; so (text1)(taxt2) - let it be, ((text1)(taxt2)) or (text1 text2) - remove outer brackets
	lenFind = len(find)
	if (left(find,1)=&quot;(&quot;) and (right(find,1)=&quot;)&quot;) and (lenFind&gt;2) and (not skupiny) then &apos; yes, there is &quot;(&quot; at start and &quot;)&quot; at the end
		for i = 2 to lenFind-1
			ch = mid(Find, i, 1)
			if ch = &quot;(&quot; then l = l+1
			if ch = &quot;)&quot; then r = r+1
			&apos; if the 1st is right bracket then it belongs to 1st left one and there mustn&apos;t change anything
			if (r = 1) and (l = 0) then goto nechat
			&apos; if the 1st if left bracket then the next are sublevels and it need revoke the outer brackets
			if (r = 0) and (l = 1) then exit for

		next i

		find = mid(find,2, lenFind-2)
nechat:

	end if

	&apos; problem with the anchor of start of paragraph: (^skup) not find OOo; ^(skup) not find AltSearch
	&apos; if the groups are turned on, it need move ^ to the inside of group
	if skupiny then
		find = replace_(find,&quot;^(&quot;,&quot;(^&quot;) &apos; the anchor of start of paragraph ^ move to the inside of group
	end if

	if not skupiny then uroven = 999
	rest = &quot;&quot;
	i = 1
	n = 0 &apos; index of group for search
	lenFind = len(find)
	nmode = 0
	do while i &lt;= lenFind
		ch = mid(Find, i, 1)
		select case nMode
		case 0 &apos;normal mode
			select case ch
			case &quot;\&quot;  &apos; escape mode
				nMode = 1
			case cr1  &apos; start of blocks of paragraphs
				nMode = 2
				if rest &lt;&gt; &quot;&quot; then &apos; the block of paragraphs after the text
					pom(n).hled = rest &apos; set previous text to search
					rest = &quot;&quot;
					n=n+1  &apos; new group of paragraphs for search
					redim preserve pom(n)
					pom(n).pmode = 1
					pom(n).pmin = 1
				else &apos;still no text before
					pom(n).pmode = 1  &apos; for now: mode 1, the definitive decision will be at the end of blockbloku
					pom(n).pmin = 1
				end if
				if uroven = 1 then pom(n).skup = skup &apos; index of current group, if the previous one was opened

			case &quot;.&quot; &apos; searched string interrupted with .
				if not skupiny then goto normalZnak &apos; turn off at groups that are turned off
				if (i+1)&gt;=lenFind then goto normalZnak &apos; if dot . is last or penultimate character then it hasn&apos;t sense to do something

				select case mid(Find, i+2, 1) &apos; what is 3rd character after .* or .+   ?
				case &quot;(&quot;
					if uroven &lt;&gt; 0 then goto normalZnak &apos; ignore immersed groups
					&apos; it should be the end of section between groups
				case &quot;)&quot;
					if uroven &lt;&gt; 1 then goto normalZnak &apos; ignore immersed groups
					&apos; it should be the end of groups of 1st level
				case else
					goto normalZnak

				end select

				&apos; detect the occurrence of * nebo + at next place
				dim opak
				opak = mid(Find, i+1, 1)
				select case opak
				case &quot;*&quot;, &quot;+&quot;  &apos; next character * or + = any length string
					if rest &lt;&gt; &quot;&quot; then &apos; if there is already some searched text then end and new group
						pom(n).hled = rest &apos; set previous text on search
						rest = &quot;&quot;
						n=n+1  &apos; new group of paragraphs for search
						redim preserve pom(n)
					end if
					if uroven = 1 then pom(n).skup = skup &apos; the index of current group if previous one was opened
					rest = &quot;.&quot; &amp; opak  &apos; must be set - it will be used at end
					pom(n).hled = rest &apos; set text on search
					pom(n).umode = 1 &apos; flag of any length block of text
					if opak = &quot;*&quot; then
						pom(n).pmin = 0 &apos; minimal length of block
					else
						pom(n).pmin = 1 &apos; minimal length of block
					end if

					if (i+1)&lt;lenFind then &apos; if something is following then establish new group
						if mid(Find, i+2, 1) &lt;&gt; &quot;)&quot; then &apos; if there isn&apos;t the end of group then new group
						n=n+1  &apos; new group for search
						redim preserve pom(n)
						if uroven = 1 then pom(n).skup = skup &apos; the index of current group if previous one was opened
						pom(n).umode = -1 &apos; flag of group that ensues after any long block of text
						rest = &quot;&quot;
					end if
				end if
				i = i+1

			case else
				goto normalZnak &apos; normal service of common character
			end select

		case &quot;(&quot; &apos; searched string interrupted with (
			uroven = uroven + 1 &apos; level of nesting of ()
			if uroven = 1 then
				if skup &lt; 9 then skup = skup + 1 &apos; number of group of brackets ()
				&apos; end the current group and start new one with index skup
				if i&gt;1 then
					pom(n).hled = rest &apos; set previous text to search
					rest = &quot;&quot;
					n=n+1  &apos; new group for search
					redim preserve pom(n)
					if pom(n-1).umode = 1 then pom(n).umode = -1  &apos; set flag of previous any long block

				end if
				pom(n).skup = skup &apos; index of current group

			else &apos; level = 1
				rest = rest  &amp;  ch
			end if

		case &quot;)&quot;
			uroven = uroven - 1
			if uroven = 0 then &apos; character is back on general level, end the group, start new one
				&apos; if next character is new opened bracket then don&apos;t end the group, one will be ended during open next group
				if (i &lt; lenFind)and(mid(Find,i+1,1)&lt;&gt;&quot;(&quot;) then &apos; searched string interrupted with )
					pom(n).hled = rest &apos; set previous text on search
					rest = &quot;&quot;
					n=n+1  &apos; new group for search
					redim preserve pom(n)
					if pom(n-1).umode = 1 then pom(n).umode = -1  &apos; set flag of previous any long block
				end if
			else
				rest = rest  &amp;  ch
			end if

		case else &apos;maybe the character to searched text
normalZnak:
			if (rest=&quot;&quot;) then
				if pom(n).pmode &lt;&gt; 0 then
					&apos; end the block of paragraphs, treat the maximum
					if (pom(n).pmin&gt;pom(n).pmax) and (pom(n).pmax&gt;=0) then pom(n).pmax=pom(n).pmin

					n=n+1  &apos; new group for search
					redim preserve pom(n)
					if uroven = 1 then pom(n).skup = skup &apos; the index of current group if previous one was opened
					rest = ch
				else
					&apos; search starts with text
					rest = ch
				end if

			else  &apos;maybe the character to searched text - pridat
				rest = rest &amp; ch
			end if

		end select
	case 1	&apos;Escape mode
		select case ch
		case &quot;m&quot;,&quot;M&quot;
			nMode = 0
			pom(n).pgBreak = 1

		case &quot;c&quot;,&quot;C&quot;
			nMode = 0
			pom(n).pgBreak = 2

		case else &apos; non-guarded parameter - rewrite
			nMode = 0
			if pom(n).pmode &lt;&gt; 0 then  &apos; end the block of paragraphs
				&apos; end the block of paragraphs, treat the maximum
				if (pom(n).pmin&gt;pom(n).pmax) and (pom(n).pmax&gt;=0) then pom(n).pmax=pom(n).pmin
				n=n+1  &apos; new group for search
				redim preserve pom(n)
			end if
			rest = rest &amp; &quot;\&quot; &amp; ch
		end select

	case 2	&apos;the block of paragraphs
		select case ch
		case cr1 &apos; next paragraph
			pom(n).pmin = pom(n).pmin + 1

		case &quot;?&quot;,&quot;+&quot;,&quot;*&quot;,&quot;{&quot;  &apos; counted metacharacters
			meta() = vyhodnotMetazn(find,i)
			nMode = 0
			pom(n).pmin = meta(1)
			pom(n).pmax = meta(2)
			if meta(0)&gt;0 then i = i + meta(0) &apos; position behind the end of metacharacter

		case &quot;(&quot;
			uroven = uroven + 1 &apos; level of nesting of ()
			if uroven = 1 then
				if skup &lt; 9 then skup = skup + 1 &apos; number of group of brackets ()
				&apos; end the current group and start new one with index skup
				rest = &quot;&quot;
				if (pom(n).pmin&gt;pom(n).pmax) and (pom(n).pmax&gt;=0) then pom(n).pmax=pom(n).pmin &apos; treat the maximum
				n=n+1  &apos; new group for search
				redim preserve pom(n)
				pom(n).skup = skup &apos; index of new group
				nMode = 0

			else
				rest = rest  &amp;  ch
			end if

		case &quot;)&quot;
			uroven = uroven - 1
			if uroven = 0 then &apos; character is back on general level, end the group, start new one
				if (i &lt; lenFind) then &apos; searched string interrupted by )
					pom(n).hled = rest &apos; set previous text on search
					rest = &quot;&quot;
					n=n+1  &apos; new group for search
					redim preserve pom(n)
					nMode = 0
				end if
			else
				rest = rest  &amp;  ch
			end if

		case else  &apos; maybe text or command - check in mode 0
			nMode = 0
			i = i - 1
		end select

	case else
		&apos;shouldn&apos;t happen
	end select

	i = i + 1
	loop

	&apos;ended with the blocks of paragraphs
	if pom(n).pmode&lt;&gt;0 then
		&apos; end the block of paragraphs, treat the maximum
		if (pom(n).pmin&gt;pom(n).pmax) and (pom(n).pmax&gt;=0) then pom(n).pmax=pom(n).pmin
	else
		pom(n).hled = rest
	end if

	&apos; if there is started with the blocks of paragraphs and something ensues
	&apos; (but by this is probably prepared to the problems of groups... 1st block started by other way than the others)
	if (pom(0).pmode&lt;&gt;0) and (ubound(pom())&gt;0) then
		if pom(0).skup &lt;&gt; pom(1).skup then goto HledatJenSamOstavec &apos; next is also paragraph - let it be
		pom(0).hled = pom(1).hled
		pom(0).pmode = -1
		if pom(0).pgBreak = 0 then pom(0).pgBreak = pom(1).pgBreak
		if pom(0).skup = 0 then pom(0).skup = pom(1).skup

		for i = 1 to ubound(pom())-1
			&apos;       pom(i) = pom(i+1) &apos; doesn&apos;t funct reliably during handing over to result
pom(i).hled = pom(i+1).hled &apos;search the group of empty space:
			pom(i).pmode = pom(i+1).pmode
			pom(i).pmin = pom(i+1).pmin
			pom(i).pmax = pom(i+1).pmax
			pom(i).pgBreak = pom(i+1).pgBreak
			pom(i).pstyl = pom(i+1).pstyl
			pom(i).chstyl = pom(i+1).chstyl
			pom(i).lgrw = pom(i+1).lgrw
			pom(i).rgrw = pom(i+1).rgrw
			pom(i).cmd = pom(i+1).cmd
			pom(i).atr = pom(i+1).atr
			pom(i).skup = pom(i+1).skup
			pom(i).umode = pom(i+1).umode
			pom(i).nmode = pom(i+1).nmode
		next i

		i = ubound(pom())-1
		redim preserve pom(i)
	end if

HledatJenSamOstavec:
	&apos; if there is separated block of paragraphs the set 1st search
	if (pom(0).pmode &lt;&gt; 0) and (pom(0).hled=&quot;&quot;) then
		pom(0).pmode = 16
		pom(0).hled=&quot;$&quot;
	end if

	&apos; additional adjustments
	for i = 0 to ubound(pom())
		&apos; search of Page Break: if alone Break without other text is searched
		if (pom(i).hled = &quot;&quot;) and (pom(i).pgBreak&gt;0) then pom(i).hled = &quot;$&quot;

		&apos; set of flag of group that can have the zero length but nevertheless this group is considered as found
		&apos; rid the anchors ^ and $
		l = 0 : r = 0
		if (left(pom(i).hled,1)=&quot;^&quot;) then l = 1
		if (right(pom(i).hled,1)=&quot;$&quot;) then r = 1
		rest = ucase( mid(pom(i).hled,1+l, len(pom(i).hled)-l-r) )
		&apos; at the end is * or ? or {0,nn}
		if (right(rest,1)=&quot;*&quot;)or(right(rest,1)=&quot;?&quot;)or(right(rest,1)=&quot;}&quot;) then
			if (right(rest,1)=&quot;}&quot;) then  &apos; remove the brackets
				ch = &quot;&quot;  &apos; find open bracket
				for n = len(rest)-1 to 1 step -1
					if mid(rest,n,1)=&quot;{&quot; then exit for
					ch = mid(rest,n,1)  &amp;  ch
				next n
				&apos; if there was form {0,nn} then remove the modifier
				if instr(ch,&quot;0,&quot;)=1 then rest = left(rest,len(rest)-len(ch)-2)

			else
				rest = mid(rest,1, len(rest)-1)
			end if

			&apos; a. type:   [xy...z]*   but no:  [xx]*[yy]*
			if (left(rest,1)=&quot;[&quot;) and (right(rest,1)=&quot;]&quot;) then
				rest = mid(rest,2, len(rest)-2)
				&apos; jen pri jednom paru zavorek
				if (instr(rest,&quot;[&quot;)=0)and((instr(rest,&quot;]&quot;)=0)) then pom(i).nmode = 1

				&apos; b. typ:   x*   = only one character
			elseif (len(rest)=1) then
				pom(i).nmode = 1

				&apos; c. typ:   \x0000*
			elseif (len(rest)=6) and (left(rest,2)=&quot;\X&quot;) then
				pom(i).nmode = 1
			end if

		end if

	next i

	&apos; if stretched group is last in grouping, then turn off the exception on no-found
	&apos; else there could be eternal cycle
	i = ubound(pom())

	&apos; search all paragraph as the preparation for search only according to character style
	if pom(0).atr = 4 then pom(0).hled = &quot;.*&quot;
	if pom(0).atr = 10 then pom(0).hled = &quot;.*&quot;  &apos; for the search of any index mark

	getFindArray() = removeZero( pom() ) &apos; bug #74
end function


	&apos; the dialog lets choose from the field of values
sub getFromList(caption$, pole1(), x&amp;, y&amp;, xx&amp;, yy&amp;) as string
	dim pom(),poloha
	oDSEL = LoadDialog_(&quot;AltSearch&quot;, &quot;D_styl&quot;) &apos; dialog to choose the style
	oDSEL.Title =  caption
	oDSEL.model.tag = &quot;&quot;

	&apos; the position of dialog is relative to main window
	poloha = oDial.getPosSize
	poloha.x = poloha.x + x
	poloha.y = poloha.y + y
	oDSEL.setPosSize poloha.x, poloha.y, xx, yy, 3+12
	&apos; set the sizes of the inside of block
	oDSEL.getcontrol(&quot;Lb_styles&quot;).setPosSize 0, 0, xx-10, yy-10, 12

	oDSEL.getcontrol(&quot;Lb_styles&quot;).removeItems(0,oDSEL.getcontrol(&quot;Lb_styles&quot;).itemCount)  &apos; delete previous
	oDSEL.getcontrol(&quot;Lb_styles&quot;).addItems(pole1(),0)  &apos; add
	oDSEL.execute() &apos;show the dialog

	getFromList = oDSEL.model.Tag
end sub


	&apos; [::Grow 1,1::]text
sub getGrow(find as string) as array
	dim pom(2), tmp
	dim n as integer
	tmp = find
	if Ucase(left(tmp,7))&lt;&gt;&quot;[::GROW&quot; then goto konec &apos; if it doesn&apos;t start correctly then end
	n = 1
	pom(1)=trim(FindPartStr(tmp, &quot;[::grow&quot;,&quot;,&quot;,n))
	&apos; back compatibility with GROWE
	if ucase(left(pom(1),1)) = &quot;E&quot; then pom(1)=trim(rightPast(pom(1),&quot;e&quot;))
	n = n - 1
	pom(2)=trim(FindPartStr(tmp, &quot;,&quot;,&quot;::]&quot;,n))
	pom(0)=mid(tmp,n)
	getGrow() = pom()
	exit sub

konec:
	pom(0) = find
	pom(1) = &quot;&quot;
	pom(2) = &quot;&quot;
	getGrow() = pom()
end sub


	&apos; mode=0: returns the index of object where the cursor is
	&apos; mode=1: returns the total count of objects
	&apos; mode=2: tries to find the substring REST starting from entered index
	&apos; -1 is returned if the objects aren&apos;t in document, or the search is from start
sub getIndexBookmark(mode as integer, idx, rest1 as string) as long
	dim i as long, bin
	dim oTFr, tf, nam, names, count
	oTFr = ALTsearchDOC.getBookmarks
	names = oTFr.ElementNames &apos; array with the names of frames
	count = oTFr.count
	if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) isn&apos;t case sensitive; BIN=0 is binary comparison

	if mode = 2 then  &apos; find substring rest in name
		if rest = &quot;&quot; then  &apos;find next
			getIndexBookmark = idx
			exit sub
		end if
		if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
			for i = idx-1 to 0 step -1
				if instr(1,names(i), rest,bin)&gt;0 then  &apos; substring found
					getIndexBookmark = i
					exit sub
				end if
			next i
			getIndexBookmark = -1
			exit sub

		else &apos; forward
			for i = idx+1 to ubound(names())
				if instr(1,names(i), rest,bin)&gt;0 then  &apos; substring found
					getIndexBookmark = i
					exit sub
				end if
			next i
			getIndexBookmark = ubound(names())+1
			exit sub
		end if
	end if

	if mode = 1 then &apos; the count of all txt frames
		getIndexBookmark = count - 1
	else     &apos; mode = 0
		if count = 0 then &apos; there aren&apos;t any bookmarks
			getIndexBookmark = -1
			exit sub
		end if
		if INITimplNAME = &quot;SwXTextRanges&quot; then &apos; cursor is somewhere in text
			if oVCURS.text.ImplementationName = &quot;SwXTextFrame&quot; then &apos; cursor is inside the text frame
				&apos; return index of current
				nam = oVCURS.text.name
				for i = 0 to ubound(names())
					if nam = names(i) then
						getIndexBookmark = i
						exit sub
					end if
				next i
				getIndexBookmark = -1 &apos; no found, start 1st

			else &apos; found the nearest next, previous
				&apos; for now search from start/end
hledejBlizke:
				if ALTsearchPARAMS.zpet = 1 then &apos; backward
					getIndexBookmark = ubound(names())+1 &apos; last
				else
					getIndexBookmark = -1 &apos; first
				end if
			end if
		else &apos; directly the frame is selected
			if INITimplNAME &lt;&gt; &quot;SwXTextFrame&quot; then goto hledejBlizke
			nam = oSELS.name
			for i = 0 to ubound(names())
				if nam = names(i) then
					getIndexBookmark = i
					exit sub
				end if
			next i
			getIndexBookmark = -1 &apos; from first
		end if

	end if &apos; mode = 0
end sub


sub getIndexComment(mode as integer, idx, rest as string) as long
	dim i as long, bin
	dim oTFs, oTF, nam, names, count

	if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) isn&apos;t case sensitive; BIN=0 is binary comparison

	if ubound(TMPPOLE())=-1 then  &apos;1. pass: load tmp array with notes
		redim TMPPOLE()
		count = 0
		oTFs = ALTsearchDOC.getTextFields().createEnumeration()
		Do While oTFs.hasMoreElements()
			oTF = oTFs.nextElement()
			if oTF.supportsService(&quot;com.sun.star.text.TextField.Annotation&quot;) then
				redim preserve TMPPOLE(count)
				TMPPOLE(count)=oTF
				count= count+1
				if i&gt;65000 then
					hlaseni1(64, true, false, &quot;getIndexComment:  There is used more than 65000 arrays, notes or special footnotes. The rest is ignored.&quot;) &apos;  16=stop 32=? 48=! 64=info; may suppress; cancel the activities
					exit do
				end if
			end if
		Loop
	end if
	count = ubound(TMPPOLE())+1

	if mode = 2 then  &apos; find substring rest in name
		if rest = &quot;&quot; then  &apos;find next
			getIndexComment = idx
			exit sub
		end if
		if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
			for i = idx-1 to 0 step -1
				if instr(1,TMPPOLE(i).content, rest,bin)&gt;0 then  &apos; substring found
					getIndexComment = i
					exit sub
				end if
			next i
			getIndexComment = -1
			exit sub

		else &apos; forward
			for i = idx+1 to ubound(TMPPOLE())
				if instr(1,TMPPOLE(i).content, rest,bin)&gt;0 then  &apos; substring found
					getIndexComment = i
					exit sub
				end if
			next i
			getIndexComment = ubound(TMPPOLE())+1
			exit sub
		end if
	end if

	if mode = 1 then &apos; count of all notes
		getIndexComment = ubound(TMPPOLE())
	else  &apos;mode=0
		if count = 0 then
			getIndexComment = -1
			exit sub
		end if
		if INITimplNAME = &quot;SwXTextRanges&quot; then &apos; cursor is somewhere in text
			if isObject(prCURS.TextField) then &apos; cursor is directly before field
				&apos; find index according to anchor
				for i = 0 to ubound(TMPPOLE())
					if isRegionStart0(prCURS,TMPPOLE(i).anchor)  then
						getIndexComment = i
						exit sub
					end if
				next i
				getIndexComment = -1 &apos; no found, from first

			else &apos; found the nearest next, previous
				&apos; found the nearest next, previous  &apos; for now search from start/end
hledejBlizke:
				if ALTsearchPARAMS.zpet = 1 then &apos; backward
					getIndexComment = ubound(TMPPOLE())+1 &apos; last
				else
					getIndexComment = -1 &apos; first
				end if
			end if

		else  &apos; &quot;SwXTextRanges&quot;
			goto hledejBlizke &apos; go to 1st or last
		end if

	end if
end sub


	&apos; mode=0: returns the index of object where the cursor is
	&apos; mode=1: returns the total count of objects
	&apos; mode=2: tries to find the substring REST starting from entered index
	&apos; -1 is returned if the objects aren&apos;t in document, or the search is from start
sub getIndexPicture(mode as integer, idx, rest1 as string) as long
	dim i&amp;, bin, oTfr, tf, nam, names, Alttext, count,rest
	rest = rest1
	oTfr = ALTsearchDOC.GraphicObjects
	names = oTfr.ElementNames &apos; array with the names of frames
	
	reverseArray(names) &apos;ALTsearchDOC.GraphicObjects =&gt; the items in .ElementNames are in reversed order than the items returned with .getByIndex() !
	&apos;and I hope it is really reversed order and not some chaotic order !
	
	count = oTfr.count
	if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) isn&apos;t case sensitive; BIN=0 is binary comparison

	if mode = 2 then  &apos; find substring rest in name
		&apos; search in name or Alt text??
		Alttext = false
		if left(rest,1) = &quot;\&quot; then  &apos;search in Alternative text
			for i = 0 to ubound(names)
				&apos; replace the names with Alt. texts
				names(i) = oTfr.getByName(names(i)).Title
			next i
			rest = rightpast(rest,&quot;\&quot;)
			Alttext = true
		end if

		if (rest = &quot;&quot;) and (not Alttext) then &apos;find next
			getIndexPicture = idx
			exit sub
		end if
		if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
			for i = idx-1 to 0 step -1
				if ((instr(1,names(i), rest,bin)&gt;0) and (rest&lt;&gt;&quot;&quot;))   OR (Alttext and (names(i)= &quot;&quot;) and (rest= &quot;&quot;))  then &apos; substring found - 2nd condition after OR for the search of empty string in alt. text
					getIndexPicture = i
					exit sub
				end if
			next i
			getIndexPicture = -1
			exit sub

		else &apos; forward
			for i = idx+1 to ubound(names())
				if ((instr(1,names(i), rest,bin)&gt;0) and (rest&lt;&gt;&quot;&quot;))   OR (Alttext and (names(i)= &quot;&quot;) and (rest= &quot;&quot;))  then &apos; substring found - 2nd condition after OR for the search of empty string in alt. text
					getIndexPicture = i
					exit sub
				end if
			next i
			getIndexPicture = ubound(names())+1
			exit sub
		end if
	end if

	if mode = 1 then &apos; the count of all txt frames
		getIndexPicture = count - 1
	else
		if count = 0 then
			getIndexPicture = -1
			exit sub
		end if
		if INITimplNAME = &quot;SwXTextRanges&quot; then &apos; cursor is somewhere in text
			&apos; found the nearest next, previous
			&apos; for now search from start/end
hledejBlizke:
			if ALTsearchPARAMS.zpet = 1 then &apos; backward
				getIndexPicture = ubound(names())+1 &apos; last
			else
				getIndexPicture = -1 &apos; first
			end if

		else &apos; directly the image is selected
			if INITimplNAME &lt;&gt; &quot;SwXTextGraphicObject&quot; then goto hledejBlizke
			nam = oSELS.name
			for i = 0 to ubound(names())
				if nam = names(i) then
					getIndexPicture = i
					exit sub
				end if
			next i
			getIndexPicture = -1 &apos; from first
		end if

	end if &apos; mode = 0
end sub


	&apos; mode=0: returns the index of frame where the cursor is
	&apos; mode=1: returns the total count of frames
	&apos; mode=2: tries to find the substring REST starting from entered index
	&apos; -1 is returned if the objects aren&apos;t in document, or the search is from start
sub getIndexTextFrame(mode as integer, idx, rest as string) as long
	dim i as long, bin
	dim oTFr, tf, nam, names, count
	oTFr = ALTsearchDOC.getTextFrames
	names = oTFr.ElementNames &apos; array with the names of frames

	reverseArray(names) &apos;fix: bug #59  https://github.com/gitxpy/libreoffice-alt-search/issues/59
	
	count = oTFr.count
	if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) isn&apos;t case sensitive; BIN=0 is binary comparison

	if mode = 2 then  &apos; find substring rest in name
		if rest = &quot;&quot; then  &apos;find next
			getIndexTextFrame = idx
			exit sub
		end if
		if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
			for i = idx-1 to 0 step -1
				if instr(1,names(i), rest,bin)&gt;0 then  &apos; substring found
					getIndexTextFrame = i
					exit sub
				end if
			next i
			getIndexTextFrame = -1
			exit sub

		else &apos; forward
			for i = idx+1 to ubound(names())
				if instr(1,names(i), rest,bin)&gt;0 then  &apos; substring found
					getIndexTextFrame = i
					exit sub
				end if
			next i
			getIndexTextFrame = ubound(names())+1
			exit sub
		end if
	end if

	if mode = 1 then &apos; the count of all txt frames
		getIndexTextFrame = count - 1
	else
		if count = 0 then &apos; nejsou ramce
			getIndexTextFrame = -1
			exit sub
		end if
		if INITimplNAME = &quot;SwXTextRanges&quot; then &apos; cursor is somewhere in text
			if oVCURS.text.ImplementationName = &quot;SwXTextFrame&quot; then &apos; cursor is inside the text frame
				&apos; return index of current
				nam = oVCURS.text.name
				for i = 0 to ubound(names())
					if nam = names(i) then
						getIndexTextFrame = i
						exit sub
					end if
				next i
				getIndexTextFrame = -1 &apos; no found, start from 1st

			else &apos; found the nearest next, previous
				&apos; for now search from start/end
hledejBlizke:
				if ALTsearchPARAMS.zpet = 1 then &apos; backward
					getIndexTextFrame = ubound(names())+1 &apos; last
				else
					getIndexTextFrame = -1 &apos; first
				end if
			end if
		else &apos; directly the frame is selected
			if INITimplNAME &lt;&gt; &quot;SwXTextFrame&quot; then goto hledejBlizke
			nam = oSELS.name
			for i = 0 to ubound(names())
				if nam = names(i) then
					getIndexTextFrame = i
					exit sub
				end if
			next i
			getIndexTextFrame = -1 &apos; from first
		end if

	end if &apos; mode = 0
end sub


	&apos; return the index of table where the cursor is, or return the count of all tables
	&apos; mode=0: returns the index of object where the cursor is
	&apos; mode=1: returns the total count of objects
	&apos; mode=2: tries to find the substring REST starting from entered index
	&apos; -1 is returned if the objects aren&apos;t in document, or the search is from start
sub getIndexTextTable(mode as integer, idx, rest as string) as long
	dim i as long, bin
	dim oTFr, tf, nam, names, count
	oTFr = ALTsearchDOC.getTextTables
	names = oTFr.ElementNames &apos; array with the names of tables
	count = oTFr.count
	if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) isn&apos;t case sensitive; BIN=0 is binary comparison

	if mode = 2 then  &apos; find substring rest in name
		if rest = &quot;&quot; then  &apos;find next
			getIndexTextTable = idx
			exit sub
		end if
		if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
			for i = idx-1 to 0 step -1
				if instr(1,names(i), rest,bin)&gt;0 then  &apos; substring found
					getIndexTextTable = i
					exit sub
				end if
			next i
			getIndexTextTable = -1
			exit sub

		else &apos; forward
			for i = idx+1 to ubound(names())
				if instr(1,names(i), rest,bin)&gt;0 then  &apos; substring found
					getIndexTextTable = i
					exit sub
				end if
			next i
			getIndexTextTable = ubound(names())+1
			exit sub
		end if
	end if

	if mode = 1 then &apos; the count of all txt frames
		getIndexTextTable = count - 1
	else
		if count = 0 then
			getIndexTextTable = -1
			exit sub
		end if
		if INITimplNAME = &quot;SwXTextRanges&quot; then &apos; cursor is somewhere in text
			if oVCURS.text.ImplementationName = &quot;SwXCell&quot; then &apos; cursor is directly inside the table
				&apos; hledat další
				nam = oVCURS.textTable.name
				for i = 0 to ubound(names())
					if nam = names(i) then
						getIndexTextTable = i
						exit sub
					end if
				next i
				getIndexTextTable = -1 &apos; no found

			else &apos; found the nearest next, previous
hledejBlizke:
				&apos; for now search from start/end
				if ALTsearchPARAMS.zpet = 1 then &apos; backward
					getIndexTextTable = ubound(names())+1 &apos; last
				else
					getIndexTextTable = -1 &apos; first
				end if
			end if
		else &apos; je vybran rozsah buněk
			if INITimplNAME &lt;&gt; &quot;SwXTextTableCursor&quot; then goto hledejBlizke
			nam = oVCURS.textTable.name
			for i = 0 to ubound(names())
				if nam = names(i) then
					getIndexTextTable = i
					exit sub
				end if
			next i
			getIndexTextTable = -1 &apos; no found
		end if
	end if &apos; mode = 0
end sub


sub getIndexTField(mode as integer, idx, rest as string) as long
	dim i as long, bin
	dim oTFs, oTF, nam, names, count

	if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) isn&apos;t case sensitive; BIN=0 is binary comparison

	&apos; on error goto Errobsluha
	if ubound(TMPPOLE())=-1 then  &apos;1. pass: load tmp array with notes
		redim TMPPOLE()
		count = 0
		oTFs = ALTsearchDOC.getTextFields().createEnumeration()
		Do While oTFs.hasMoreElements()
			oTF = oTFs.nextElement()
			if not (oTF.supportsService(&quot;com.sun.star.text.TextField.Annotation&quot;) or oTF.supportsService(&quot;com.sun.star.text.TextField.GetReference&quot;)) then
				redim preserve TMPPOLE(count)
				TMPPOLE(count)=oTF
				count= count+1
				&apos;	     end if
				if i&gt;65000 then
					hlaseni1(64, true, false, &quot;getIndexTField: There is used more than 65000 arrays, notes or special footnotes. The rest is ignored.&quot;) &apos;  16=stop 32=? 48=! 64=info; may suppress; cancel the activities
					exit do
				end if
			end if
		Loop
	end if
	count = ubound(TMPPOLE())+1

	if mode = 2 then  &apos; find substring rest in name
		if rest = &quot;&quot; then  &apos;find next
			getIndexTField = idx
			exit sub
		end if
		if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
			for i = idx-1 to 0 step -1
				if instr(1,TMPPOLE(i).anchor.string, rest,bin)&gt;0 then  &apos; substring found
					getIndexTField = i
					exit sub
				end if
			next i
			getIndexTField = -1
			exit sub

		else &apos; forward
			for i = idx+1 to ubound(TMPPOLE())
				if instr(1,TMPPOLE(i).anchor.string, rest,bin)&gt;0 then  &apos; substring found
					getIndexTField = i
					exit sub
				end if
			next i
			getIndexTField = ubound(TMPPOLE())+1
			exit sub
		end if
	end if

	if mode = 1 then &apos; count of all notes
		getIndexTField = ubound(TMPPOLE())
	else  &apos;mode=0
		if count = 0 then
			getIndexTField = -1
			exit sub
		end if
		if INITimplNAME = &quot;SwXTextRanges&quot; then &apos; cursor is somewhere in text
			if isObject(prCURS.TextField) then &apos; cursor is directly before field
				&apos; find index according to anchor
				for i = 0 to ubound(TMPPOLE())
					if isRegionStart0(prCURS,TMPPOLE(i).anchor)  then
						getIndexTField = i
						exit sub
					end if
				next i
				getIndexTField = -1 &apos; no found, from first

			else &apos; found the nearest next, previous
				&apos; found the nearest next, previous  &apos; for now search from start/end
hledejBlizke:
				if ALTsearchPARAMS.zpet = 1 then &apos; backward
					getIndexTField = ubound(TMPPOLE())+1 &apos; last
				else
					getIndexTField = -1 &apos; first
				end if
			end if

		else  &apos; &quot;SwXTextRanges&quot;
			goto hledejBlizke &apos; go to 1st or last
		end if  &apos; &quot;SwXTextRanges&quot;

	end if &apos; mode = 0
end sub


	&apos; return the name of user Index or &quot;content&quot; or
	&apos; the object must be of type .getStart.DocumentIndexMark
sub getNameOfIndex(oIndex) as string
	dim pom, i

	getNameOfIndex = &quot;???&quot;
	pom = oIndex.getPropertySetInfo.properties

	for i = 0 to ubound(pom) step 1

		if pom(i).name = &quot;UserIndexName&quot; then
			getNameOfIndex = oIndex.UserIndexName
			exit sub
		end if

		if pom(i).name = &quot;PrimaryKey&quot; then
			getNameOfIndex = &quot;Alphabetical index&quot;
			exit sub
		end if

	next i

	if ubound(pom) = 4 then  &apos; according the count of properties I estimate it is content
		getNameOfIndex = &quot;Document content&quot;
		exit sub
	end if
	exit sub
konec:
	getNameOfIndex = &quot;Chyba&quot;
end sub


	&apos; return the code of the search of bookmark - 0 found,  -1/1 start/end of block, -2/2 start/end of document, and set properly prCURS
	&apos; set the variable FOUNDbookmarkNO  = index of currently found (-1 no found)
sub getNextBookmark(byval find as string, fromCur, blockCur as object, inFoot) as integer
	dim j&amp;,i&amp;, k&amp;, k1&amp;, k2&amp;, max&amp;, bin&amp;, zac&amp;, kon&amp;, krok&amp;, pgno&amp;
	dim oBookm, oAnch, oCol, pCur  &apos; collection of bookmarks
	dim hled, pom

	hled = find

	&apos; \ = search in the names of bookmarks
	inFoot = -1  &apos; -1 = search in the text of bookmark; 1 = search in the names of bookmarks; 0 = search any bookmark
	if left(hled,2)= &quot;\\&quot; then
		inFoot = 1
		hled = rightpast(hled, &quot;\\&quot;)
	end if
	if hled = &quot;&quot; then inFoot = 0 &apos; search all

	oBookm = ALTsearchDOC.Bookmarks
	max = oBookm.Count-1 &apos; max index of last note

	if max &lt; 0  then &apos; there isn&apos;t object  in document
		getNextBookmark = 4
		exit sub
	end if

	if (INITimplNAME &lt;&gt; &quot;SwXTextRanges&quot;) then &apos; the cursor isn&apos;t in text
		getNextBookmark = 10 &apos; canceled
		hlaseni(3) &apos; search in non-text object
		exit sub
	end if

	&apos; search the nearest
	pCur = oVCURS.text.createTextCursorByRange(oVCURS.getStart()) &apos; remember the start of current cursor
	pgno = oVCURS.getPage()

	&apos;detect index if cursor is directly on anchor - find according to position of anchor
	k = getIndexByAnchor(oBookm(),pCur.start(),max) &apos; -1 = cursor ins&apos;t on bookmark

	if k&gt;=0 then
		&apos; cursor is at start of bookmark - there could be more cursors on same place
		if FOUNDbookmarkNO&gt;=0 then  &apos; last found index
			if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
				if k &gt; FOUNDbookmarkNO then k = FOUNDbookmarkNO
			else
				if k &lt; FOUNDbookmarkNO then k = FOUNDbookmarkNO
			end if

		end if

		&apos; set 1st index for next search
		if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
			if k = 0 then : goto nenalezeno : else  k = k-1 : end if  &apos; 1st index for backward search
		else
			if k = max then : goto nenalezeno : else  k = k+1 : end if &apos; 1st index for forward search
		end if

	else
		&apos; cursor away from the bookmark, find nearest next/previous
		k1 = findPrevBookm(oVCURS.start,oBookm())  &apos;firstly find the nearest previous in ambit of same region
		k2 = findNextBookm(oVCURS.start,oBookm())  &apos;firstly find nearest next

		if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
			if k=-1 then k = max
			if (k2-k1)&gt;=1 then k=k2-1
			if (k1&lt;0)and(k2&lt;=max) then k=k2-1
			if (k1&lt;=max)and(k2&lt;0) then k=k1
			&apos; nothing, &apos;k&apos; is already found
		else &apos; 1st index for search
			if (k2-k1)&gt;=1 then k=k1+1
			if (k1&lt;0)and(k2&lt;=max) then k=k2
			if (k1&lt;=max)and(k2&lt;0) then k=k1+1
		end if

		if k = -1 then goto nenalezeno

	end if

	&apos; OK, search if it is ok for conditions, from the index to starting
	zac = k &apos; 1st index for search
	if ALTsearchPARAMS.zpet = 1 then
		kon = 0 : krok = -1  &apos; scour from k to 0
	else
		kon = max : krok = 1 &apos; scour from k to max
	end if

	for i = zac to kon step krok
		&apos; find in content of bookmarks ?
		if inFoot=1 then  &apos; search in names
			pom = oBookm(i).Name
		else &apos; search in text of anchor
			pom = oBookm(i).anchor.string  &apos; search in content of text of bookmark
		end if

		&apos; is the searched substring HLED included in VST, and is pertinently inside the block??
		&apos; if inFoot=0 then there will be the search without regard to occurrence of searched substring
		if isSubstrInBlock(oBookm(i),pom,hled,inFoot) then
			prCURS = oBookm(i) &apos;.anchor
			getNextBookmark = 0
			FOUNDbookmarkNO = i
			exit sub

		end if &apos; is the substring found?

	next i
	&apos; no found
nenalezeno:

	&apos; return index of unsuccessful search -1/1 start/end of block, -2/2 start/end of document, and set properly prCURS
	getNextBookmark = getNoFoundIndex(blockCur)
	FOUNDbookmarkNO = -1
end sub


sub getNextField(byval find as string, fromCur, blockCur as object) as integer
	dim j&amp;,i&amp;, k&amp;, max&amp;, bin&amp;, zac&amp;, kon&amp;, krok&amp;, pgno&amp;
	dim oFoot, oCol, pCur  &apos; collection of notes
	dim inFoot
	dim hled, pom

	hled = find
	&apos; set the mode for the search for all arrays
	if hled = &quot;&quot; then : inFoot = 0 : else : inFoot = 1 : end if

	if ubound(TMPPOLE())=-1 then  &apos;1. pass: load tmp array with notes
		getSortFields(TMPPOLE(), TMPPOLE1(), &quot;All&quot;, true)  &apos; load sorted notes
	end if

	oFoot = TMPPOLE()
	max = ubound(oFoot())  &apos; max index of last note

	if max &lt; 0  then &apos; there isn&apos;t object  in document
		getNextField = 4
		exit sub
	end if

	if (INITimplNAME &lt;&gt; &quot;SwXTextRanges&quot;) then &apos; the cursor isn&apos;t in text
		getNextField = 10 &apos; canceled
		hlaseni(3) &apos; search in non-text object
		exit sub
	end if

	&apos; search the nearest
	pCur = oVCURS.text.createTextCursorByRange(oVCURS.getStart()) &apos; remember the start of current cursor
	pgno = oVCURS.getPage()

	if isObject(pCur.TextField) then
		if not (pCur.supportsService(&quot;com.sun.star.text.TextField.Annotation&quot;) or pCur.supportsService(&quot;com.sun.star.text.TextField.GetReference&quot;)) then
			&apos; cursor is on filed (out of note)
			&apos; detect current index - find according to position of anchor
			k = getIndexByAnchor(oFoot(),pCur.start(),max)

			if k &lt; 0 then msgbox &quot;getNextField:  field not found although the cursor is on one&quot;

			&apos; set 1st index for next search
			if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
				if k = 0 then : goto nenalezeno : else  k = k-1 : end if  &apos; 1st index for backward search
			else
				if k = max then : goto nenalezeno : else  k = k+1 : end if &apos; 1st index for forward search
			end if
		else
			goto kurzorMimo
		end if

	else
kurzorMimo:
		&apos; cursor out of mark, find nearest next/previous
		if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
			&apos; return index of previous object for search
			k = findPrevObj(pgno,oVCURS.start,oFoot(),TMPPOLE1())
		else &apos; 1st index for search
			&apos; return index of next object for search
			k = findNextObj(pgno,oVCURS.start,oFoot(),TMPPOLE1())
		end if

		if k = -1 then goto nenalezeno

	end if

	&apos; OK, search if it is ok for conditions, from the index to starting
	zac = k &apos; 1st index for search
	if ALTsearchPARAMS.zpet = 1 then
		kon = 0 : krok = -1  &apos; scour from k to 0
	else
		kon = max : krok = 1 &apos; scour from k to max
	end if

	for i = zac to kon step krok
		&apos; is the searched substring HLED included in VST, and is pertinently inside the block??
		&apos; if inFoot=0 then there will be the search without regard to occurrence of searched substring
		if isSubstrInBlock(oFoot(i),oFoot(i).anchor.string,hled,inFoot) then
			if oFoot(i).anchor.string = &quot;&quot; then &apos; choose so as it can be deleted
				prCURS = oFoot(i).anchor.text.createTextCursorByRange(oFoot(i).anchor.getStart())
				prCURS.goRight(1,true)
			else  &apos; probably it isn&apos;t need here - anchor of note is always empty
				prCURS = oFoot(i).anchor
			end if

			getNextField = 0
			exit sub
		end if &apos;found

	next i

	&apos; no found
nenalezeno:
	&apos; return index of unsuccessful search -1/1 start/end of block, -2/2 start/end of document, and set properly prCURS
	getNextField = getNoFoundIndex(blockCur)
end sub


	&apos; return the code of finding of next object; 0=found
	&apos; found text object is in prCURS
sub getNextFootnote(byval find as string, fromCur, blockCur as object, typ as string,inFoot) as integer
	dim i&amp;, k&amp;, max&amp;, bin&amp;, zac&amp;, kon&amp;, krok&amp;
	dim oFoot, oAnch, oCol, pCur  &apos; collection of notes
	dim hled, pom

	hled = find

	&apos; \ = search in text of note
	inFoot = -1  &apos; -1 = search in the anchor that is visible (anchor of object); 1 = search in text of note (bubble); 0=find all
	if left(hled,2)= &quot;\\&quot; then
		inFoot = 1
		hled = rightPast(hled, &quot;\\&quot;)
	end if
	if hled = &quot;&quot; then inFoot = 0 &apos; search all

	if typ=&quot;Foot&quot; then
		oFoot = ALTsearchDOC.Footnotes
	else
		oFoot = ALTsearchDOC.Endnotes
	end if

	max = oFoot.count - 1  &apos; max index of last note
	if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) isn&apos;t case sensitive; BIN=0 is binary comparison

	if oFoot.count = 0 then
		getNextFootnote = 4
		exit sub
	end if

	if (INITimplNAME &lt;&gt; &quot;SwXTextRanges&quot;) then &apos; the cursor isn&apos;t in text
		getNextFootnote = 10 &apos; canceled
		hlaseni(3) &apos; search in non-text object
		exit sub
	end if

	&apos; search the nearest
znovu:
	oVCURS.collapseToStart
	pCur = oVCURS.text.createTextCursorByRange(oVCURS.getStart()) &apos; remembre current cursor
	if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
		runOOoIntCommand(&quot;JumpToPrevFootnote&quot;, &quot;&quot;, &quot;&quot;) &apos; JumpToNextFootnote  JumpToFootnoteOrAncho JumpToPrevFootnote
	else
		runOOoIntCommand(&quot;JumpToNextFootnote&quot;, &quot;&quot;, &quot;&quot;) &apos; JumpToNextFootnote  JumpToFootnoteOrAncho JumpToPrevFootnote
	end if
	&apos; remember the cursor after search of next note
	prCURS = oVCURS.text.createTextCursorByRange(oVCURS.getStart())
	&apos; if the cursors are same then no found
	if isRegionStart0(pCur,prCURS)  then goto nenalezeno &apos;next not found

	if FINDCOUNTER &lt; 0 then  &apos; cancel, end
		getNextFootnote = 10 &apos; canceled
		exit sub
	end if

	&apos;found but...
	if typ=&quot;Foot&quot; then
		if isEmpty(prCURS.footnote) then goto znovu &apos; probably it is Endnote, find next
	else
		if isEmpty(prCURS.endnote) then goto znovu &apos; probably it is Endnote, find next
	end if

	pCur = prCURS.text.createTextCursorByRange(prCURS.getStart())

	&apos; detect current index - find according to position of anchor
	k = getIndexByAnchor(oFoot(),pCur.start(),max)

	if k &lt; 0 then  &apos; Bug OOo: to the version 2.3 aren&apos;t functional the anchors of notes that causes the end with bug here ... but from 2.3 it could be functional
		&apos;    msgbox &quot;getNextFootnote:  note not found although the cursor is on one&quot;
		getNextFootnote = 10
		exit sub
	end if

	&apos; OK, search if it is ok for conditions, from the index to starting
	zac = k &apos; 1st index for search
	if ALTsearchPARAMS.zpet = 1 then
		kon = 0 : krok = -1  &apos; scour from k to 0
	else
		kon = max : krok = 1 &apos; scour from k to max
	end if

	for i = zac to kon step krok
		&apos; search in content of bookmark ?
		if inFoot=1 then
			pom = oFoot(i).string
		else &apos; search in text of anchor
			pom = oFoot(i).anchor.string
		end if

		&apos; is the searched substring HLED included in VST, and is pertinently inside the block??
		&apos; if inFoot=0 then there will be the search without regard to occurrence of searched substring
		if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
			prCURS = oFoot(i).anchor
			getNextFootnote = 0
			exit sub
		end if &apos;nalezeno

	next i

	&apos; no found
nenalezeno:

	&apos; return index of unsuccessful search -1/1 start/end of block, -2/2 start/end of document, and set properly prCURS
	getNextFootnote = getNoFoundIndex(blockCur)
end sub


	&apos; return the code of finding of next object; 0=found
	&apos; found text object is in prCURS
sub getNextComment(byval find as string, fromCur, blockCur as object) as integer
	dim j&amp;,i&amp;, k&amp;, max&amp;, bin&amp;, zac&amp;, kon&amp;, krok&amp;, pgno&amp;
	dim oFoot, oAnch, oCol, pCur  &apos; collection of notes
	dim inFoot
	dim hled, pom

	on error goto konec

	hled = find
	&apos; set the mode of the search for all notes
	if hled = &quot;&quot; then : inFoot = 0 : else : inFoot = 1 : end if

	if ubound(TMPPOLE())=-1 then  &apos;1. pruchod: load tmp array with notes
		getSortFields(TMPPOLE(), TMPPOLE1(), &quot;Annotation&quot;, true)  &apos; load sorted notes
	end if

	oFoot = TMPPOLE()
	max = ubound(oFoot())  &apos; max index of last note

	if max &lt; 0  then &apos; there isn&apos;t object  in document
		getNextComment = 4
		exit sub
	end if

	if (INITimplNAME &lt;&gt; &quot;SwXTextRanges&quot;) then &apos; the cursor isn&apos;t in text
		getNextComment = 10 &apos; canceled
		hlaseni(3) &apos; search in non-text object
		exit sub
	end if

	&apos; search the nearest
	pCur = oVCURS.text.createTextCursorByRange(oVCURS.getStart()) &apos; remember the start of current cursor
	pgno = oVCURS.getPage()

	if isObject(pCur.TextField) then
		if pCur.TextField.supportsService(&quot;com.sun.star.text.TextField.Annotation&quot;) then
			&apos; cursor is on mark
			&apos; detect current index - find according to position of anchor
			k = getIndexByAnchor(oFoot(),pCur.start(),max)

			if k &lt; 0 then msgbox &quot;getNextComment:  poznamka nenalezena ackoli je na ni kurzor&quot;

			&apos; set 1st index for next search
			if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
				if k = 0 then : goto nenalezeno : else  k = k-1 : end if  &apos; 1st index for backward search
			else
				if k = max then : goto nenalezeno : else  k = k+1 : end if &apos; 1st index for forward search
			end if
		else
			goto kurzorMimo
		end if

	else
kurzorMimo:
		&apos; cursor out of mark, find nearest next/previous
		if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
			&apos; return index of previous object for search
			k = findPrevObj(pgno,oVCURS.start,oFoot(),TMPPOLE1())
		else &apos; 1st index for search
			&apos; return index of next object for search
			k = findNextObj(pgno,oVCURS.start,oFoot(),TMPPOLE1())
		end if

		if k = -1 then goto nenalezeno

	end if

	&apos; OK, search if it is ok for conditions, from the index to starting
	zac = k &apos; 1st index for search
	if ALTsearchPARAMS.zpet = 1 then
		kon = 0 : krok = -1  &apos; scour from k to 0
	else
		kon = max : krok = 1 &apos; scour from k to max
	end if

	for i = zac to kon step krok
		&apos; is the searched substring HLED included in VST, and is pertinently inside the block??
		&apos; if inFoot=0 then there will be the search without regard to occurrence of searched substring
		if isSubstrInBlock(oFoot(i),oFoot(i).content,hled,inFoot) then
			if oFoot(i).anchor.string = &quot;&quot; then &apos; choose so as it can be deleted
				prCURS = oFoot(i).anchor.text.createTextCursorByRange(oFoot(i).anchor.getStart())
				prCURS.goRight(1,true)
			else  &apos; probably it isn&apos;t need here - anchor of note is always empty
				prCURS = oFoot(i).anchor
				beep
			end if

			getNextComment = 0
			exit sub
		end if &apos;found
	next i
	&apos; no found
nenalezeno:

	&apos; return index of unsuccessful search -1/1 start/end of block, -2/2 start/end of document, and set properly prCURS
	getNextComment = getNoFoundIndex(blockCur)
	exit sub
konec:
	hlaseni1(48, true, false, &quot;getNextComment:  Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error$ &amp; &quot; (line: &quot; &amp; Erl &amp; &quot;)&quot;) &apos;  16=stop 32=? 48=! 64=info; may suppress; cancel the activities
end sub


sub getNextReference(byval find as string, fromCur, blockCur as object, mode) as integer
	dim j&amp;,i&amp;, k&amp;, max&amp;, bin&amp;, zac&amp;, kon&amp;, krok&amp;, pgno&amp;
	dim oFoot, oCol, pCur  &apos; collection of notes
	dim hled, pom

	hled = find
	mode = -1  &apos; -1 = the search in text that is visible (in anchor of object); 1 = search in Title (in bubble); 0=find all
	if hled = &quot;\\\\&quot; then &apos; search empty text
		hled = &quot;&quot;
	else
		if left(hled,2)= &quot;\\&quot; then  &apos; search in name
			mode = 1
			hled = rightPast(hled, &quot;\\&quot;)
		else
			if hled = &quot;&quot; then  &apos; find all
				mode = 0
			end if
		end if
	end if

	if ubound(TMPPOLE())=-1 then  &apos;1. pruchod: load tmp array with notes
		getSortFields(TMPPOLE(), TMPPOLE1(), &quot;GetReference&quot;, true)  &apos; load sorted notes
	end if

	oFoot = TMPPOLE()
	max = ubound(oFoot())  &apos; max index of last note

	if max &lt; 0  then &apos; there isn&apos;t object  in document
		getNextReference = 4
		exit sub
	end if

	if (INITimplNAME &lt;&gt; &quot;SwXTextRanges&quot;) then &apos; the cursor isn&apos;t in text
		getNextReference = 10 &apos; canceled
		hlaseni(3) &apos; search in non-text object
		exit sub
	end if

	&apos; search the nearest
	pCur = oVCURS.text.createTextCursorByRange(oVCURS.getStart()) &apos; remember the start of current cursor
	pgno = oVCURS.getPage()

	if isObject(pCur.TextField) then
		if pCur.supportsService(&quot;com.sun.star.text.TextField.GetReference&quot;) then
			&apos; cursor is on filed (out of note)
			&apos; detect current index - find according to position of anchor
			k = getIndexByAnchor(oFoot(),pCur.start(),max)

			if k &lt; 0 then msgbox &quot;getNextReference:  field not found although the cursor is on one&quot;

			&apos; set 1st index for next search
			if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
				if k = 0 then : goto nenalezeno : else  k = k-1 : end if  &apos; 1st index for backward search
			else
				if k = max then : goto nenalezeno : else  k = k+1 : end if &apos; 1st index for forward search
			end if
		else
			goto kurzorMimo
		end if

	else
kurzorMimo:
		&apos; cursor out of mark, find nearest next/previous
		if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
			&apos; return index of previous object for search
			k = findPrevObj(pgno,oVCURS.start,oFoot(),TMPPOLE1())
		else &apos; 1st index for search
			&apos; return index of next object for search
			k = findNextObj(pgno,oVCURS.start,oFoot(),TMPPOLE1())
		end if

		if k = -1 then goto nenalezeno

	end if

	&apos; OK, search if it is ok for conditions, from the index to starting
	zac = k &apos; 1st index for search
	if ALTsearchPARAMS.zpet = 1 then
		kon = 0 : krok = -1  &apos; scour from k to 0
	else
		kon = max : krok = 1 &apos; scour from k to max
	end if

	for i = zac to kon step krok
		if mode = 1 then  &apos; search in name of mark ?
			pom = TMPPOLE(i).SourceName
		else &apos; search in text of anchor
			pom = TMPPOLE(i).anchor.string
		end if

		&apos; is the searched substring HLED included in VST, and is pertinently inside the block??
		&apos; if inFoot=0 then there will be the search without regard to occurrence of searched substring
		if isSubstrInBlock(oFoot(i),pom,hled,mode) then
			if oFoot(i).anchor.string = &quot;&quot; then &apos; choose so as it can be deleted
				prCURS = oFoot(i).anchor.text.createTextCursorByRange(oFoot(i).anchor.getStart())
				prCURS.goRight(1,true)
			else  &apos; probably it isn&apos;t need here - anchor of note is always empty
				prCURS = oFoot(i).anchor
			end if

			getNextReference = 0
			exit sub
		end if &apos;found

	next i

	&apos; no found
nenalezeno:

	&apos; return index of unsuccessful search -1/1 start/end of block, -2/2 start/end of document, and set properly prCURS
	getNextReference = getNoFoundIndex(blockCur)
end sub


	&apos; return the code of finding of next object; 0=found
	&apos; found text object is in prCURS
sub getNextReferenceMark(byval find as string, fromCur, blockCur as object, inFoot) as integer
	dim j&amp;,i&amp;, k&amp;, max&amp;, bin&amp;, zac&amp;, kon&amp;, krok&amp;, pgno&amp;
	dim oFoot, oAnch, oCol, pCur  &apos; collection of notes
	&apos;dim inFoot
	dim hled, pom

	hled = find

	inFoot = -1  &apos; -1 = search in text that is visible (in anchor of object); 1 = hledat ve Názvu (v bublině); 0=find all
	if hled = &quot;\\\\&quot; then &apos; search empty text
		hled = &quot;&quot;
	else
		if left(hled,2)= &quot;\\&quot; then  &apos; search in name
			inFoot = 1
			hled = rightPast(hled, &quot;\\&quot;)
		else
			if hled = &quot;&quot; then  &apos; find all
				inFoot = 0
			end if
		end if
	end if

	if ubound(TMPPOLE())=-1 then  &apos;1. pruchod: load tmp array with notes
		getSortRefMarks(TMPPOLE(), TMPPOLE1(), true)  &apos; nacte setridene podle stranek
	end if

	oFoot = TMPPOLE() &apos;ALTsearchDOC.ReferenceMarks
	max = ubound(oFoot())  &apos; max index of last note

	if max &lt; 0  then &apos; there isn&apos;t object  in document
		getNextReferenceMark = 4
		exit sub
	end if

	if (INITimplNAME &lt;&gt; &quot;SwXTextRanges&quot;) then &apos; the cursor isn&apos;t in text
		getNextReferenceMark = 10 &apos; canceled
		hlaseni(3) &apos; search in non-text object
		exit sub
	end if

	&apos; search the nearest

	pCur = oVCURS.text.createTextCursorByRange(oVCURS.getStart()) &apos; remember the start of current cursor
	pgno = oVCURS.getPage()

	if isObject(pCur.ReferenceMark) then
		&apos; cursor is on mark
		&apos; detect current index - find according to position of anchor
		k = getIndexByAnchor(oFoot(),pCur.start(),max)

		if k &lt; 0 then msgbox &quot;getNextReferenceMark:  znacka nenalezena ackoli je na ni kurzor&quot;

		&apos; set 1st index for next search
		if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
			if k = 0 then : goto nenalezeno : else  k = k-1 : end if  &apos; 1st index for backward search
		else
			if k = max then : goto nenalezeno : else  k = k+1 : end if &apos; 1st index for forward search
		end if

	else
		&apos; cursor out of mark, find nearest next/previous
		if ALTsearchPARAMS.zpet = 1 then  &apos; backward search
			&apos; return index of previous object for search
			k = findPrevObj(pgno,oVCURS.start,oFoot(),TMPPOLE1())
		else &apos; 1st index for search
			&apos; return index of next object for search
			k = findNextObj(pgno,oVCURS.start,oFoot(),TMPPOLE1())
		end if

		if k = -1 then goto nenalezeno

	end if

	&apos; OK, search if it is ok for conditions, from the index to starting
	zac = k &apos; 1st index for search
	if ALTsearchPARAMS.zpet = 1 then
		kon = 0 : krok = -1  &apos; scour from k to 0
	else
		kon = max : krok = 1 &apos; scour from k to max
	end if

	for i = zac to kon step krok
		&apos; hledat ve nazvu značky
		if inFoot = 1 then
			pom = oFoot(i).Name
		else &apos; hledat v textu
			pom = oFoot(i).anchor.string
		end if

		&apos; is the searched substring HLED included in VST, and is pertinently inside the block??
		&apos; if inFoot=0 then there will be the search without regard to occurrence of searched substring
		if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
			if oFoot(i).anchor.string = &quot;&quot; then &apos; select empty text to potentially delete with DEL
				prCURS = oFoot(i).anchor.text.createTextCursorByRange(oFoot(i).anchor.getStart())
				prCURS.goRight(1,true)
			else
				prCURS = oFoot(i).anchor
			end if
			getNextReferenceMark = 0
			exit sub

		end if &apos; is the substring found?

	next i

	&apos; no found
nenalezeno:

	&apos; return index of unsuccessful search -1/1 start/end of block, -2/2 start/end of document, and set properly prCURS
	getNextReferenceMark = getNoFoundIndex(blockCur)
end sub


	&apos; return the object with the parameters for search of paragraphs \p
	&apos; x.txt - searched string; if x.mode=0 then without paragraphs
	&apos; x.bmin/x.bmax - min/max the count of empty paragraphs before searched string (if x.bmax=-1 then any count)
	&apos; x.emin/x.emax - min/max the count of empty paragraphs after searched string (if x.emax=-1 then any count)
	&apos; admissible syntax: \p\p...\p  \p+ \p* \p{počet} \p{min,}  \p{min,max} \p{1}neco\p
	&apos; for now not supported: neco\p{1}neco   (could be for example  x.mode = 4, x.txt1 2nd part of string)
sub GetParFind0(find as string) as  tParFind
	dim za, ko, i as integer
	dim vysl as tParfind
	dim pom

	za = 0 &apos; the start of searched text
	vysl.mode = 0 &apos; not include the paragraph
	vysl.attr = &quot;&quot; &apos;without the attribute for the search
	vysl.txt = find &apos; not include the paragraph
	i = instr(find,chr(13)) &apos;the position of 1st found paragraph
	if i &gt; 0 then &apos; special operation for paragraphs \p
		if i = 1 then  &apos; the paragraphs at the start
			do while mid(find,i,1)=chr(13) &apos; continuous block of paragrpahs
				i = i+1
			loop  &apos; while it is 13
			pom() = vyhodnotMetazn(find,i)
			if pom(0)=0 then &apos;there isn&apos;t metacounter = +*{}
				vysl.bmin = i-1
				vysl.bmax = i-1
				za = i
			else &apos; there is metacounter
				vysl.bmin = pom(1)
				vysl.bmax = pom(2)
				za = i+pom(0)
			end if
			vysl.mode = 1 &apos; 1. bit = the paragraphs at the start
			i = instr(za,find,chr(13),) &apos;position of next paragraph - should be at the end
			if i &gt; 0 then goto hledejkonec  &apos; next at the end
			ko = len(find)
			vysl.txt = mid(find,za,ko-za+1)
			if vysl.txt = &quot;&quot; then vysl.mode = 16  &apos; single paragraph or group - without text
		else &apos; the paragraphs aren&apos;t at start of searched string ret
			za = 1  &apos; define the start if the paragraphs are only at the end
hledejkonec:
			ko = i-1 &apos; before the final block of paragraphs
			do while mid(find,i,1)=chr(13) &apos; continuous block of paragraphs
				i = i+1
			loop  &apos; while it is 13
			pom() = vyhodnotMetazn(find,i)
			if pom(0)=0 then &apos;there isn&apos;t metacounter = +*{}
				vysl.emin = i-ko-1
				vysl.emax = i-ko-1
			else &apos; there is metacounter
				vysl.emin = pom(1)
				vysl.emax = pom(2)
			end if

			if pom(0)+i-1 &lt; len(find) then
				vysl.mode = 0 &apos; there is still some text after 2nd block of paragraphs - not supported
				&apos;vysl.txt1 =
				&apos;vysl.mode = 4
			else
				vysl.mode = vysl.mode + 2 &apos; 2. bit = paragraphs at the end
				vysl.txt = mid(find,za,ko-za+1)
			end if

		end if
	end if

	&apos; detect and filter the attributes of the search
	i = instr(vysl.txt,&quot;::]&quot;)
	if (instr(vysl.txt,&quot;[:::&quot;)=1)and(i&gt;7) then
		vysl.attr = mid(vysl.txt,5,i-5)
		vysl.txt = right(vysl.txt,len(vysl.txt)-i-2)
	end if

	GetParFind = vysl
end sub


	&apos; it returns the estimated data type for the attributes of text
function getPrValue(pomo as string)
	dim ppom as string
	on error goto konec
	&apos; for now: only boolean, strings and numbers
	getPrValue = pomo
	ppom = ucase(pomo)
	select case ppom
	case &quot;TRUE&quot;
		getPrValue = true
	case &quot;FALSE&quot;
		getPrValue = false
	case else
		if IsNumeric(ppom) then
			if (instr(ppom,&quot;&amp;h&quot;)=1) then
				getPrValue = clng(ppom)
			else
				ppom = replace_(ppom,&quot;,&quot;,&quot;.&quot;)  &apos; val knows only decimal . as separator
				getPrValue = val(ppom)
			end if

		else &apos; string is
			getPrValue = pomo

		end if
	end select
konec:
end function


Function getRealStyleName(sStyles$, sName$) as string &apos;return the .Name of Style for .DisplayName; sStyles is type of style like &quot;ParagraphStyles&quot;, &quot;CharacterStyles&quot; etc.
	dim i&amp;, oStyle as object, sReturn$, oStyles as object
	oStyles=ALTsearchDOC.StyleFamilies.getByName(sStyles)
	if NOT oStyles.hasByName(sName) then &apos;there isn&apos;t .Name of style
	for i=0 to oStyles.Count-1 &apos;traverse all styles
		oStyle=oStyles.getByIndex(i) &apos;current style
		if oStyle.DisplayName=sName then &apos;there is .Name for .DisplayName
			sReturn=oStyle.Name &apos;return .Name
			exit for
		end if
	next i
	else &apos;there is .Name
		sReturn=sName
	end if
	getRealStyleName=sReturn
End Function


	&apos;analyze the replace string completely and return array for replace function
function getReplArray(byval nahr as string) as  tRepl
	dim pom(0) as tRepl
	dim pp(), cmd, rest
	dim  i&amp;, n, k, nMode&amp;
	dim kod, pomo as string
	dim attrnames()

	ALTsearchPRINTOUT = &quot;&quot;  &apos; the name of file, frame for report - empty = without report

	&apos;every special command of array for the replace will be run individually in the dependence on CMD

	if ALTsearchPARAMS.reg &lt;&gt; 1 then &apos; no regexps
		pom(0).nahr = nahr
		pom(0).cmd  = &quot;$&quot;     &apos; normally insert text
		pom(0).smaz = 1
		getReplArray() = pom()
		exit function
	end if

	&apos; on parts according to used commands

	redim pom() as tRepl
	dim ch as string
	dim lenRepl&amp;

	rest = &quot;&quot;
	i = 1
	lenRepl = len(nahr)
	n = -1  &apos; counter of record of result array

	do while i &lt;= lenRepl
		ch = mid(nahr, i, 1)
		select case nMode
		case 0 &apos;normal mode
			select case ch
			case &quot;\&quot;  &apos; escape mode - 1st occurrence of slash
				nMode = 1
				if i = 1 then &apos; first zaznam - vytvorit
					n=n+1  &apos; new group for search
					redim preserve pom(n)
				end if

				if lenRepl&gt;i then  &apos; there is next character after slash
					select case mid(nahr, i+1, 1) &apos; next character
					case &quot;x&quot;,&quot;&amp;&quot;,&quot;#&quot;,&quot;\&quot;,&quot;|&quot;   &apos; the specialni text entered with \ ensues
						if (pom(n).cmd &lt;&gt; &quot;$&quot;)and(i&lt;&gt;1) then
							n=n+1  &apos; new record for text
							redim preserve pom(n)
						end if

					case &quot;f&quot;  &apos; the enforcement pasting via clipboard, new record isn&apos;t need, only the flag for all array is set
						&apos; nic

					case else   &apos; there will be some spacial parameter
						if i&lt;&gt;1 then
							n=n+1
							redim preserve pom(n)
						end if

					end  select

				end if

			case &quot;&amp;&quot;  &apos; same like \0
				n=n+1  &apos; new group for search
				redim preserve pom(n)

				&apos; insert content of group 0
				pom(n).nahr = &quot;0&quot;
				pom(n).cmd = &quot;@&quot;  &apos; identifier of group
				nMode = 0  &apos; continue by text mode

			case else &apos;maybe the character to searched text
				if i = 1 then &apos; the start with string
					n=n+1  &apos; new group for search
					redim preserve pom(n)
					pom(n).nahr = ch
					pom(n).cmd = &quot;$&quot;   &apos; identifier of string
				else
					if pom(n).cmd = &quot;$&quot; then &apos;open string of text - add to next
						pom(n).nahr = pom(n).nahr  &amp;  ch
					else  &apos;jelse establish new record and add the character
						n=n+1  &apos; new group for search
						redim preserve pom(n)
						pom(n).nahr = ch
						pom(n).cmd = &quot;$&quot;   &apos; identifier of string
					end if
				end if

			end select

		case 1	&apos;Escape mode
			select case ch
			case &quot;&amp;&quot;, &quot;\&quot;, &quot;|&quot;  &apos; insert normal &amp; or \ or |
				nMode = 0
				pom(n).nahr = pom(n).nahr  &amp;  ch
				pom(n).cmd = &quot;$&quot;   &apos; identifier of string

			case &quot;b&quot;, &quot;e&quot;, &quot;p&quot;, &quot;t&quot;, &quot;n&quot;, &quot;S&quot;, &quot;c&quot;, &quot;m&quot;, &quot;M&quot;, &quot;r&quot;, &quot;D&quot;, &quot;d&quot;, &quot;v&quot;, &quot;V&quot;, &quot;u&quot;, &quot;O&quot;, &quot;I&quot;             &apos; &quot;i&quot;,
				nMode = 0
				pom(n).nahr = &quot;&quot; &apos; without the parameter
				pom(n).cmd = ch  &apos; identifier of function

			case &quot;o&quot;  &apos; the text content of object navi, fiil the flag of use
				nMode = 0
				pom(n).nahr = &quot;&quot; &apos; without the parameter
				pom(n).cmd = ch  &apos; identifier of function
				pom(0).textobs = 1 &apos; flag of the use of this parameter, so as not convert the tables needlessly

			case &quot;f&quot; &apos; enforcement the pasting via clipboard ; in version v1.1 changed in \F to \f  (\F is for the pasting of special footnote)
				nMode = 0
				pom(0).form = 1

			case &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;
				&apos; paste the group by number
				nMode = 0
				pom(n).nahr = ch &apos;
				pom(n).cmd = &quot;@&quot;  &apos; identifier of group

			case &quot;H&quot;,&quot;h&quot;, &quot;P&quot;, &quot;C&quot;, &quot;N&quot;, &quot;A&quot;, &quot;R&quot;, &quot;F&quot;, &quot;E&quot;, &quot;B&quot;, &quot;L&quot;, &quot;i&quot;, &quot;K&quot; &apos; očekává parametr - řetězec mezi {}
				nMode = 0
				pom(n).nahr = &quot;&quot; &apos; without the parameter
				pom(n).cmd = ch  &apos; identifier of group
				if lenRepl&gt;i then
					if mid(nahr, i+1, 1) = &quot;{&quot; then  &apos;parameter
						nMode = 2  &apos; continue with the reading of paragraph
						i = i + 1
					else
						select case ch &apos; state without the brackets
						case &quot;P&quot;, &quot;C&quot; : pom(n).nahr = &quot;Standard&quot; &apos;default
						case &quot;R&quot; : ALTsearchPRINTOUT = MSG(33) &apos; write the replacements - Writer
						end select
					end if
				else
					select case ch &apos; state without the brackets -at the end of replace expression
					case &quot;P&quot;, &quot;C&quot; : pom(n).nahr = &quot;Standard&quot; &apos; default
					case &quot;R&quot; : ALTsearchPRINTOUT = MSG(33) &apos; write the replacements - Writer
					end select
				end if

			case &quot;x&quot;  &apos; hexadecimally entered character
				nMode = 0
				pomo = &quot;&quot;
				for k = 1 to 4
					if (i+k)&lt;=(lenRepl) then pomo=pomo &amp; mid(nahr, i+k, 1)
				next k
				pomo = hex2str(pomo)
				pom(n).nahr = pom(n).nahr  &amp;  pomo
				pom(n).cmd = &quot;$&quot;   &apos; identifier of string
				i = i+4

			case &quot;#&quot;  &apos; decimally entered character
				nMode = 0
				k = 1
				pomo = &quot;&quot;
				kod = &quot;&quot;
				if (i+k)&lt;=(lenRepl) then pomo = mid(nahr,i+k,1) &apos; character that ensues after #
				do while  isDigit_(pomo) and (i+k&lt;=lenRepl)   &apos;it is digit
					kod = kod  &amp;  pomo
					k = k + 1
					if k &gt; 5 then exit do &apos; max 5 digits
					pomo = &quot;&quot;
					if (i+k)&lt;=(lenRepl) then pomo = mid(nahr,i+k,1) &apos; character that ensues after #
				loop

				i = i + k - 1

				pomo = chr(val(kod))
				pom(n).nahr = pom(n).nahr  &amp;  pomo
				pom(n).cmd = &quot;$&quot;   &apos; identifier of string

			case else &apos; unknown parameter - ignore
				nMode = 0
				pom(n).nahr = &quot;&quot; &apos; without the parameter
				pom(n).cmd = ch  &apos; identifier of group

			end select

		case 2	&apos; reading of parameter between {}
			select case ch
			case &quot;\&quot;
				if (i&lt;lenRepl)and(mid(nahr, i+1, 1)=&quot;}&quot;)  then
					&apos; \} insert the brace
					pom(n).nahr = pom(n).nahr  &amp;  &quot;}&quot;
					i = i + 1
				else
					&apos; everything except for closed bracket - add
					pom(n).nahr = pom(n).nahr  &amp;  ch
				end if

			case &quot;}&quot;
				nMode = 0

				&apos;test the meaningfulness of replace parameter

				dim oStyles as object, sStyle$, sDisplayName$
				select case pom(n).cmd
				case &quot;P&quot; &apos;check the existence of Paragraph Style
					if trim(pom(n).nahr) = &quot;&quot; then
						pom(n).nahr = &quot;Standard&quot; &apos;default
					else &apos;test the existence of style
						sStyle=getRealStyleName(&quot;ParagraphStyles&quot;, pom(n).nahr)
						if sStyle&lt;&gt;&quot;&quot; then pom(n).nahr=sStyle else goto NoStyl &apos;there was/n&apos;t .Name for .DisplayName
					end if

				case &quot;C&quot; &apos;check the existence of Character Style
					if trim(pom(n).nahr) = &quot;&quot; then
						pom(n).nahr = &quot;Standard&quot; &apos;default
					else &apos;test the existence of style
						sStyle=getRealStyleName(&quot;CharacterStyles&quot;, pom(n).nahr)
						if sStyle&lt;&gt;&quot;&quot; then pom(n).nahr=sStyle else goto NoStyl &apos;there was/n&apos;t .Name for .DisplayName
					end if

				case &quot;N&quot; &apos;&apos;check the existence of Numbering Style
					if trim(pom(n).nahr) = &quot;&quot; then
						&apos; let empty = reset
					else &apos;test the existence of style
						sStyle=getRealStyleName(&quot;NumberingStyles&quot;, pom(n).nahr)
						if sStyle&lt;&gt;&quot;&quot; then pom(n).nahr=sStyle else goto NoStyl &apos;there was/n&apos;t .Name for .DisplayName
					end if

				case &quot;R&quot; &apos;find and set the name and object for statement
					if trim(pom(n).nahr) = &quot;&quot; then &apos;empty brackets
						ALTsearchPRINTOUT = MSG(33)
					else
						ALTsearchPRINTOUT = pom(n).nahr
					end if

				end select

			case else &apos; everything else instead of close bracket - so add
				pom(n).nahr = pom(n).nahr  &amp;  ch

			end select

		case else
			&apos;shouldn&apos;t happen
		end select

		i = i + 1
	loop

	if n = -1 then &apos; if there is empty string then assign handly
		redim preserve pom(0)
		pom(0).nahr = &quot;&quot;
		pom(0).cmd = &quot;$&quot;   &apos; identifier of string
	end if

	&apos; 1. detect if there will be necessary to delete found text
	&apos; 2. detect whether there will be used the parameter &amp; = vložit cely nalezeny text, nebo vnitřni část dlouheho bloku
	for i = 0 to ubound(pom())
		select case pom(i).cmd
		case &quot;@&quot;  &apos; if there is occurred the replace of whole block or its part, then set the indicators
			pom(0).smaz = 1  &apos; in all cases
			if pom(i).nahr = &quot;0&quot; then
				pom(0).vloz = 1  &apos; there will be pasted whole found string by \0 or &amp;
			end if

			&apos; the list of parameters for functions that only change the properties, but there isn&apos;t change with the object (nodelete, no move)
		case &quot;c&quot;,&quot;m&quot;,&quot;M&quot;,&quot;r&quot;,&quot;D&quot;,&quot;d&quot;,&quot;H&quot;,&quot;h&quot;,&quot;P&quot;,&quot;C&quot;,&quot;N&quot;,&quot;A&quot;,&quot;R&quot;,&quot;K&quot;  &apos; away from the functions, only set the properties

		case else
			pom(0).smaz = 1

		end select

	next i

	&apos; detect whether the replacement ends with the pasting of empty paragraph
	for i = ubound(pom()) to 0 step -1  &apos; backward
		select case pom(i).cmd
		case &quot;p&quot;  &apos;
			pom(i).ppos = 1
			exit for

			&apos; the list of parameters for functions that only change the properties, but there isn&apos;t change with the object (nodelete, no move)
		case &quot;c&quot;,&quot;m&quot;,&quot;M&quot;,&quot;r&quot;,&quot;D&quot;,&quot;d&quot;,&quot;H&quot;,&quot;h&quot;,&quot;P&quot;,&quot;C&quot;,&quot;N&quot;,&quot;A&quot;,&quot;R&quot;,&quot;K&quot;  &apos; away from the functions, only set the properties

		case else  &apos; something else will be paste at the end - no need any solution
			exit for

		end select

	next i

	if ALTsearchPRINTOUT&lt;&gt;&quot;&quot; then &apos;get link to object of file for report of replacements
		if trim(pom(n).nahr) = &quot;&quot; then &apos; empty brackets
			ALTsearchPRINTOUT = MSG(33) &apos; write the replacements - Writer
		end if
		&apos; 1. search according to name frame.title
		oPOFILE = getDocumentControl(ALTsearchPRINTOUT, ALTsearchDOC)

		&apos;  focus to new document
		oPOFILE.CurrentController.Frame.containerWindow.setFocus()
		&apos; wait for activity, else there isn&apos;t any found in linux
		i = 0  &apos; pojistka proti zacyklení
		do while not oPOFILE.CurrentController.frame.isActive()
			i = i + 1
			if i&gt;100000 then
				msgbox &quot;Focus - overflowed 1&quot;
				exit do
			end if
		loop

		&apos; set prCURS1
		prCURS1 = oPOFILE.text.createTextCursorByRange(oPOFILE.text.getEnd()) &apos; to the end of document
		oPOFILE.CurrentController.select(prCURS1)    &apos; choose the end
		oVCURS1 = oPOFILE.CurrentController.getViewCursor() &apos; set visible cursor

		&apos; return focus to the current document
		oDOCcontrol.Frame.containerWindow.setFocus()

		&apos; find out and wait until current file hasn&apos;t the focus - else there is no found
		i = 0 &apos; pojistka proti zacyklení
		do while not oDOCcontrol.frame.isActive()
			i = i + 1
			if i&gt;100000 then
				msgbox &quot;Focus - overflowed 2&quot;
				exit do
			end if

		loop
	end if &apos; get link to object of file for report of replacements

	getReplArray() = pom()
	exit function

noStyl:
	&apos; the style isn&apos;t included in document!
	hlaseni1(48, true, false, MSG(20) &amp; pom(n).nahr  &amp; MSG(21)) &apos;  16=stop 32=? 48=! 64=info; may suppress; cancel the activities
	pom(0).cmd = &quot;!&quot;  &apos; flag of bug of parameter
	getReplArray() = pom()
end function


	&apos; the dialog let choose some from character styles used (inUse) in document
sub getStyleName(typ as string, inUse as boolean) as string
	dim pom(), poloha
	pom() = GetStyles(typ,inUse) &apos; true = only used, else all paragraph styles
	getStyleName = getFromList(MSG(47),pom,120,90,220,350)
end sub


	&apos; return corresponding character from the code entered with hexadeciaml string
sub hex2str(byval vstup as string) as string
	dim pom
	on error goto problem
	pom = CLng(&quot;&amp;H&quot; &amp; vstup)
	if pom=0 then goto problem
	hex2str = chr(val(pom))
	exit sub
problem:
	hex2str = &quot;&quot;
end sub


sub hlaseni(volba as integer)as integer
	dim pom, pr, i, quit
	pr = chr(13)
	quit = 0 &apos; suppression of report  6 = yes, continue
	&apos;next occurrence of found expression ... no found.

	pom = MSG(0) &amp; &quot;  &quot;&quot;&quot; &amp; ALTsearchPARAMS.find &amp; &quot;&quot;&quot;  &quot; &amp; MSG(1) &amp; pr &amp; &quot; &quot; &amp; pr &amp; &quot; &quot;

	select case volba
	case 0 &apos; the search in block ended
		i = 32
		pom = pom  &amp;  MSG(2)
		if QUITMODE then quit = 1  &apos; 1=No 6=Yes; possibility to suppress report
	case 1 &apos; continue from start?
		i = 4 + 32 + 128 &apos;128= 1st button active 256-2nd
		pom = pom  &amp;  MSG(4) &amp; pr &amp; &quot; &quot;
		if QUITMODE then quit = 1  &apos; 1=No 6=Yes; possibility to suppress report
	case 2  &apos; continue from end?
		pom = pom  &amp;  MSG(3) &amp; pr &amp; &quot; &quot;
		i = 4 + 32 + 128 &apos;128= 1st button active
		if QUITMODE then quit = 1  &apos; 1=No 6=Yes; possibility to suppress report
	case 3  &apos; search text on non-text object
		pom = MSG(5)
		i = 32
	case 4  &apos; this object ins&apos;t in document
		pom = pom  &amp;  MSG(6) &amp; pr &amp; &quot; &quot;
		i = 32
	case 5  &apos; searched expression ...    was founs ...  ×times.
		pom = MSG(13) &amp; &quot;  &quot;&quot;&quot; &amp; ALTsearchPARAMS.find &amp; &quot;&quot;&quot;  &quot; &amp; pr &amp; pr &amp; MSG(14) &amp; cstr(nCOUNT) &amp; MSG(15)
		i = 64
		if QUITMODE then quit = 1  &apos; 1=No 6=Yes; possibility to suppress report
	case 6  &apos; not possible to select more these objects  at once
		pom = MSG(18) &amp; &quot;  &quot;&quot;&quot; &amp; ALTsearchPARAMS.find &amp; &quot;&quot;&quot;  &quot;
		i = 64
	case 7  &apos; this selection of all searched expressions can take longer time and can causes the interruption &apos;Highlighting&apos;, if it is used in document, without the possibility &apos;Back&apos;
		pom = MSG(19)
		i = 4 + 32 + 128 &apos;128= 1st button active
		if QUITMODE then quit = 6  &apos; 1=No 6=Yes; possibility to suppress report
	case 8  &apos; searched expression ...    was REPLACED ...  ×times.
		pom = MSG(13) &amp; &quot;  &quot;&quot;&quot; &amp; ALTsearchPARAMS.find &amp; &quot;&quot;&quot;  &quot; &amp; pr &amp; pr &amp; MSG(30) &amp; cstr(REPLCOUNT) &amp; MSG(15)
		i = 64
		if QUITMODE then quit = 1  &apos; 1=No 6=Yes; possibility to suppress report

	end select

	if quit&gt;0 then  &apos; there is set no for decision-making functions
		hlaseni = quit
	else
		hlaseni = msgbox(pom, i, MSG(11) &amp; VERSION)
		if not ALTsearchDIALOG_end then oDial.setfocus()  &apos; return focus to dialog
	end  if
end sub


&apos; write report with the text:
	&apos; style: 16=stop 32=? 48=! 64=info
sub hlaseni1(styl as long, potlacitHlaseniMozno as boolean, prerusit as boolean,vypis$) &apos; style: 16=stop 32=? 48=! 64=info
	if not (potlacitHlaseniMozno and QUITMODE) then  &apos; no suppression of report
		msgbox(vypis, styl, MSG(11) &amp; VERSION)
		if not ALTsearchDIALOG_end then oDial.setfocus()  &apos; focus to dialog
	end  if
end sub


sub InsertTextTuCursor(elem as string, mytext as string, mode)
	&apos; where: 0 - according to cursor/block; 1 - add to start; 2 - add to end; 3 rewrite
	dim tx, min, max, tmp
	tx = oDial.getcontrol(elem)
	max = tx.Selection.max
	min = tx.Selection.min
	if max&lt;min then  &apos; select block from right to left
		tmp = min
		min = max
		max = tmp
	end if

	select case mode
	case 0 &apos; from curs
		tx.text = left(tx.text,min) &amp; mytext &amp; right(tx.text,len(tx.text)-max)
		&apos; set position after inserted text
		setCursorSel(elem, len(mytext)+min, len(mytext)+min)
	case 1 &apos; from start
		tx.text = mytext  &amp;  tx.text
		setCursorSel(elem, 0, 0)
	case 2 &apos; to end
		tx.text = tx.text  &amp;  mytext
		setCursorSel(elem, len(tx.text), len(tx.text))
	case 3 &apos; replace
		tx.text = mytext
		setCursorSel(elem, len(tx.text), len(tx.text))
	end select
	tx.setfocus()
end sub


	&apos; test that cursor has a range of text &gt;64k, or one isn&apos;t text object
sub isBigText_Or_NonTextObject(cur as object) as boolean
	&apos;dim pom, le
	isBigText_Or_NonTextObject = true
	on error goto konec
	if cur.isCollapsed then
		isBigText_Or_NonTextObject = false
	else   &apos; if length of string is non-zero than it is less than 64k
		if (len(cur.string)&lt;&gt;0) then isBigText_Or_NonTextObject = false
		if isObject(cur.TextField) then isBigText_Or_NonTextObject = true  &apos; field and note/annotation as non-text object for paste via clipboard
		if isObject(cur.Footnote) then isBigText_Or_NonTextObject = true  &apos; special footnote as non-text object for paste via clipboard
		if isObject(cur.Endnote) then isBigText_Or_NonTextObject = true  &apos; endnote as non-text object for paste via clipboard
		if isObject(cur.ReferenceMark) then isBigText_Or_NonTextObject = true  &apos; reference mark as non-text object for paste via clipboard
	end if
konec:
end sub


	&apos; compare the values of properties of cursor and style
sub isSameProperties(parStState,nam,curs,oPSt) as boolean
	isSameProperties = true &apos; it supposes the sameness - then no change of anything
	&apos; exclude struct for now - I don&apos;t compare simply
	if (parStState &lt;&gt; 2)and (not IsUnoStruct(curs.getPropertyValue(nam))) then &apos; check according to the values of style
		if ERRcontrol then on error goto konec
		if (curs.getPropertyValue(nam))&lt;&gt; (oPSt.getPropertyValue(nam))  then
			isSameProperties = false
		end if
	end if
konec:
end sub


sub isSelTextRange(mode as integer) as boolean
	if oSELS.supportsService(&quot;com.sun.star.text.TextRanges&quot;) then
		isSelTextRange = true
	else
		if mode = 1 then hlaseni(3)
		isSelTextRange = false
	end if
end sub


	&apos; return substring from left, till the searched string sHle
sub leftTo(ret$, sHle$)as string
	dim i&amp;
	dim nic as variant
	i = instr(1,ret,sHle,1)  &apos; last parameter = 1 - case insensitive
	if i&gt;0 then
		leftTo = left(ret,i-1)
	else &apos; no found
		leftTo = &quot;&quot;
	end if
end sub


sub nastavKurzor(pCurs as object)as object  &apos;set Cur according to pCurs
	dim curs
	Curs = pCurs.text.createTextCursor()
	Curs.gotorange(pCurs.getStart(),false)
	Curs.gotorange(pCurs.getEnd(),true)
	nastavKurzor = curs
end sub


sub nastavRozsah(Curs, byval r1, r2 as object)as integer
	if ERRcontrol then on error goto errorreg
	Curs.gotorange(r1,false)
	Curs.gotorange(r2,true)
	nastavRozsah = 0
	exit sub
errorreg:
	nastavRozsah = -4
end sub


	&apos; set variables ALTsearchSKUP(0-2) according to parameter of the search of substring: 1=before found 0=nfound 2=zafter found
sub nastavSkupiny012(retezec, hled)
	dim bin, i, j
	bin = 0
	if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) isn&apos;t case sensitive; BIN=0 is binary comparison
	j = len(hled)
	i = instr(1,retezec, hled, bin)  &apos; order of 1st found character of substring
	if i = 0 then     &apos;substring not fount
		ALTsearchSKUP(0) = retezec&apos; found substring
		exit sub
	end if
	ALTsearchSKUP(0) = mid(retezec, i, j) &apos; found substring
	ALTsearchSKUP(1) = left(retezec, i-1)   &apos; string before the found substring
	ALTsearchSKUP(2) = mid(retezec, i+j)  &apos; string after the found substring
end sub


sub nastavVKurzor(pCurs as object, init as boolean, info as string )  &apos;set visible cursor podle pCurs
	oDOCcontrol.select(pCurs) &apos; select object
	if init then CursorInit(true)
	vypisFoundInfo(info)
end sub


	&apos; move prCURS in dependence of entered parameters
sub NoFoundBlokOdst(zacatek as object, min, max, dirBackw) as boolean
	dim i as long
	on error goto Errobsluha
	NoFoundBlokOdst = false  &apos; supposion: found
	prCURS.gotoRange(zacatek,false)  &apos;
	i = 0 &apos; counter of empty paragraphs
	if dirBackw then &apos;backward search
		do while prCURS.goLeft(1,false) and prCURS.isEndOfParagraph
			i = i+1
			if (i &gt;= max) and (max &gt; 0) then exit sub &apos; the maximum is accomplished, end
		loop &apos;the block of paragraphs
		if (i = 0)and(min&lt;=0) then &apos; no found nic a min=0
			prCURS.goLeft(1,false)
			exit sub &apos; end as fast as possible
		end if
		if (i = 0)or(i &lt;= (min-1)) then &apos; the minimum isn&apos;t achieved
			if (i = 0) then prCURS.goLeft(1,false)
			NoFoundBlokOdst = true
			exit sub &apos; end as fast as possible
		end if
		&apos; overshoot the mark -  return back
		if not prCURS.isEndOfParagraph then prCURS.goRight(1,false)

	else &apos; search forward
		do while prCURS.goRight(1,false) and prCURS.isStartOfParagraph &apos; while the paragraphs are empty
			i = i+1
			if (i &gt;= max) and (max &gt; 0) then exit sub &apos; the maximum is achieved, end
		loop &apos;the block of paragraphs
		if (i = 0)and(min&lt;=0) then &apos; no found and min=0
			if not prCURS.goRight(1,false) then  &apos; last paragraph of document
				NoFoundBlokOdst = true
				exit sub
			end if
			prCURS.goLeft(2,false)
			exit sub &apos; end as fast as possible
		end if
		if (i = 0)or(i &lt;= (min-1)) then &apos; no found empty paragraph of minimum
			if (i = 0) then prCURS.goLeft(1,false)
			NoFoundBlokOdst = true
			exit sub &apos; end as fast as possible
		end if
		&apos; overshoot the mark -  return back
		if not prCURS.isStartOfParagraph then prCURS.goLeft(1,false)
	end if &apos; search forward
	exit sub
	Errobsluha: &apos; error 1: bug of region = found outside of border of limiting block
	if Err=1 then  &apos; 1
		hlaseni1(48, true, false, &quot;NoFoundBlokOdst:  Region Error&quot;) &apos;  16=stop 32=? 48=! 64=info; may suppress; cancel the activities
	else
		hlaseni1(48, true, false, &quot;NoFoundBlokOdst:  Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error$ &amp; &quot; (line: &quot; &amp; Erl &amp; &quot;)&quot;) &apos;  16=stop 32=? 48=! 64=info; may suppress; cancel the activities
		resume next
	end if
end sub


	&apos; move prCURS in dependence on entered parameters
sub NoFoundBreak(found as object, BreakTyp as integer) as boolean
	dim pCur as object
	NoFoundBreak = true &apos; supposition: no found
	pCur = found.getEnd
	select case BreakTyp
	case 1  &apos; hand Page Break before
		if (pCur.BreakType = 4)or(pCur.BreakType = 5) then NoFoundBreak = false
		if NOT IsEmpty(pCur.PageDescName) then NoFoundBreak = false
	case 2  &apos; break of column
		if found.getStart.BreakType = 1 then NoFoundBreak = false
	end select
end sub


	&apos; return index 1. of found record, -1 = no found
sub pozvSeznamuA(seznam, hled) as long
	dim hl as string
	dim i as long
	for i = 0 to seznam.itemCount-1
		if seznam.getItem(i)=hled then
			pozvSeznamuA = i
			exit sub
		end if
	next i
	pozvSeznamuA = -1
end sub


	&apos; swap the codes that are entered hexa \xhhhh and cgharacters
sub prepis_hex(byval vstup as string) as string
	dim po, od as long
	dim zac, kon, kod, vst as string

	&apos; hexa
	od = 1
	po = 1
	do while po &gt; 0
		vst = ucase(vstup)  &apos; for lowercase and also uppercase &quot;h&quot;
		po = instr(od, vst,&quot;\x&quot;)

		if po &gt; 0 then &apos; swap code
			zac = left(vstup,po-1)
			kon = right(vstup,len(vstup)-len(zac))
			kod = left(kon,6)
			kod = &quot;&amp;H&quot;  &amp;  right(kod,len(kod)-2)
			kon = mid(kon,7,65535)
			vstup = zac &amp; chr(val(kod)) &amp; kon
			od = po+1
		end if
	loop

	prepis_hex = vstup
end sub


	&apos; add &quot;neco&quot; to list &quot;seznam&quot; (if there isn&apos;t one)
	&apos; it adds only to start positions of list given by the variable &quot;promene&quot;
	&apos; &quot;pevne&quot; is count of items at the end of list that stay without changes
sub pridejDoSeznamuA(seznam, neco, promene, pevne)
	if Left(neco, 1)=&quot;&amp;&quot; then neco=sZERO &amp; neco &apos;add ZeroWidthJoiner before initial &amp; -&gt; bug #74
	if pozvSeznamuA(seznam, neco) &gt;= 0 then exit sub &apos; it is already there, end
	&apos; add new item
	if seznam.itemCount &gt;= (promene+pevne) then &apos; delete last variable item
		seznam.removeItems(promene-1,1)
	end if
	seznam.addItem(neco, 0)
end sub


&apos; bug #74   https://github.com/gitxpy/libreoffice-alt-search/issues/74
Function removeZero(ByRef variable as variant) as variant &apos;remove zeroWidthJoiner&amp; from the starts of items in string$, normal array(), or Type tFind
	dim i&amp;, s$, v
	v=VarType(variable)
	if v=8 then &apos;variable is string$
		if Left(variable, 2)=sZEROamp then variable=Mid(variable, 2) &apos;string starts with ZeroWidthJoiner&amp; so remove ZeroWidthJoiner
	else &apos;variable should be array() or Type tFind
		for i=lbound(variable) to ubound(variable)
			if v=8200 then s=variable(i) else s=variable(i).hled &apos;check if variable is normal array() or Type tFind
			if Left(s, 2)=sZEROamp then &apos;item starts with ZeroWidthJoiner&amp;
				s=Mid(s, 2) &apos;remove ZeroWidthJoiner
				if v=8200 then variable(i)=s else variable(i).hled=s &apos;normal array() or Type tFind
			end if
		next i
	end if
	removeZero=variable
End Function


	&apos; the function find and replace in string
	&apos; the name is changed to replace_ because of the colisions with the standard library in some OS
Function Replace_(Source As String, Search As String, NewPart As String) as string
	Dim Result As String
	Dim StartPos As Long
	Dim CurrentPos As Long
	Result = &quot;&quot;
	StartPos = 1
	CurrentPos = 1
	If Search = &quot;&quot; Then
		Result = Source
	Else
		Do While CurrentPos &lt;&gt; 0
			CurrentPos = InStr(StartPos, Source, Search)
			If CurrentPos &lt;&gt; 0 Then
				Result = Result  &amp;  Mid(Source, StartPos, CurrentPos - StartPos)
				Result = Result  &amp;  NewPart
				StartPos = CurrentPos + Len(Search)
			Else
				Result = Result  &amp;  Mid(Source, StartPos, Len(Source))
			End If &apos; Position &lt;&gt; 0
		Loop
	End If
	Replace_ = Result
End Function


	&apos; return string with swapped all \x to \u,  \x za \u, only in case occurred in form \xhhhh
	&apos;   format \xhh let be
Function replace_x2u(source as string) as string
	Dim Result, Search, zn3, zn4 As String
	Dim StartPos As Long
	Dim CurrentPos As Long
	dim le as Long

	Result = &quot;&quot;
	StartPos = 1
	CurrentPos = 1
	le = len(source) &apos; length of string
	search = &quot;\x&quot;

	Do While CurrentPos &lt;&gt; 0
		CurrentPos = InStr(StartPos, Source, Search,0)  &apos; case sensitive!!!
		If CurrentPos &lt;&gt; 0 Then  &apos;found
			if CurrentPos + 4 &lt; len(source) then &apos; last swap before end must come into format \uhhhh, else let it be
				&apos; check the format is \xhh
				&apos; check if supposed character 3 and 4 is hex number
				zn3 = mid(source,CurrentPos+4,1)
				zn4 = mid(source,CurrentPos+5,1)
				if (Instr(&quot;1234567890abcdefABCDEF&quot;, zn3)&gt;0) and (Instr(&quot;1234567890abcdefABCDEF&quot;, zn4)&gt;0) then
					&apos;swap
					Result = Result  &amp;  Mid(Source, StartPos, CurrentPos - StartPos)
					Result = Result  &amp;  &quot;\u&quot;
					StartPos = CurrentPos + Len(Search)

				else
					Result = Result  &amp;  Mid(Source, StartPos, CurrentPos - StartPos)
					Result = Result  &amp;  &quot;\x&quot;
					StartPos = CurrentPos + Len(Search)

				end if

			else
				Result = Result  &amp;  Mid(Source, StartPos, CurrentPos - StartPos)
				Result = Result  &amp;  &quot;\x&quot;
				StartPos = CurrentPos + Len(Search)

			end if

		Else &apos; no found next occurrence
			Result = Result  &amp;  Mid(Source, StartPos, Len(Source))  &apos;add rest of string
		End If &apos; Position &lt;&gt; 0
	Loop
	replace_x2u = Result
End Function


	&apos; the function find and replace in string
	&apos; case sensitive !!!
Function ReplaceC(Source As String, Search As String, NewPart As String) as string
	Dim Result As String
	Dim StartPos As Long
	Dim CurrentPos As Long
	Result = &quot;&quot;
	StartPos = 1
	CurrentPos = 1
	If Search = &quot;&quot; Then
		Result = Source
	Else
		Do While CurrentPos &lt;&gt; 0
			CurrentPos = InStr(StartPos, Source, Search,0)  &apos; case sensitive!!!
			If CurrentPos &lt;&gt; 0 Then
				Result = Result  &amp;  Mid(Source, StartPos, CurrentPos - StartPos)
				Result = Result  &amp;  NewPart
				StartPos = CurrentPos + Len(Search)
			Else
				Result = Result  &amp;  Mid(Source, StartPos, Len(Source))
			End If &apos; Position &lt;&gt; 0
		Loop
	End If
	ReplaceC = Result
End Function


	&apos; swap the codes that are decimal hexadecimal to characters
sub replDec2hex(byval vstup as string) as string
	dim po, od as long
	dim zac, kon, kod, vst, hexa as string

	&apos; firstly decimal because next hexa code cannot change the meaning of decimal code
	od = 1
	po = 1
	do while po &gt; 0
		po = instr(od, vstup,&quot;\#&quot;)
		if po &gt; 0 then &apos; swap the code
			zac = left(vstup,po-1)
			kod = &quot;&quot;
			dim i
			i = 0
			kon = mid(vstup,po+2+i,1) &apos; character that ensues after #
			do while isDigit_(kon) and (po+i+1&lt;=len(vstup))   &apos;it is digit
				kod = kod  &amp;  kon
				kon = mid(vstup,po+2+i,1)
				i = i + 1
				if i &gt; 5 then exit do &apos; max 5 digits
			loop
			kon = mid(vstup,po+1+i)
			hexa = &quot;000&quot;+hex(val(mid(kod,2,9)))  &apos; convert to hexa
			vstup = zac  &amp;  &quot;\x&quot; &amp; right(hexa,4)  &amp;  kon

			od = po+1
		end if
	loop
	replDec2hex = vstup
end sub


	&apos; if file isn&apos;t saved then it must refresh the identification name after write
sub RestoreFrameName
	if oPOFILE.URL = &quot;&quot; then
		oPOFILE.CurrentController.Frame.Title = ALTsearchPRINTOUT
		oPOFILE.Title = ALTsearchPRINTOUT
	end if
end sub


Sub reverseArray(arr()) &apos;reverse the order of items in array
	dim temp as variant, i&amp;, iLast&amp;, j&amp;, i2&amp;
	iLast=ubound(arr)
	i2=iLast \ 2
	if iLast MOD 2=0 then i2=i2-1 &apos;odd count of items in array doesn&apos;t need swap the middle item
	for i=0 to i2 &apos;swap 1st with last, 2nd with penultimate etc.
		temp=arr(i) &apos;1st to temp
		j=iLast-i &apos;index of last
		arr(i)=arr(j) &apos;last to 1st
		arr(j)=temp &apos;temp to last
	next i
End Sub


	&apos; return the substring from right, after the searched string sHle
sub rightPast(ret$, sHle$)as string
	dim i&amp;
	i = instr(1,ret, sHle,1)  &apos; last parametere = 1 - case insensitive
	if i&gt;0 then
		rightPast = right(ret,len(ret)-i-len(sHle)+1)
	else &apos; no found
		rightPast = &quot;&quot;
	end if
end sub


sub runOOoIntCommand(cmd as string, nam, valu) as variant
	dim document as object
	dim oDispatcher as object
	dim args1(0) as new com.sun.star.beans.PropertyValue
	document   = ALTsearchDOC.CurrentController.Frame
	oDispatcher = createUnoService(&quot;com.sun.star.frame.DispatchHelper&quot;)
	args1(0).Name = nam     &apos; JumpToNextFootnote  JumpToFootnoteOrAnchor
	args1(0).Value = valu
	oDispatcher.executeDispatch(document, &quot;.uno:&quot; &amp; cmd, &quot;&quot;, 0, args1())
end sub


	&apos; carry the result over the tag of dialog at activation, doubleclick on the list of style
sub selStyle(oEvt)
	oDSEL.endExecute()
	oDSEL.model.Tag = oEvt.ActionCommand
end sub


	&apos; set selection in text field
sub setCursorSel(elem as string, min,max as integer)
	dim sel
	sel = createUnoStruct( &quot;com.sun.star.awt.Selection&quot; )
	sel.min = min
	sel.max = max
	oDial.getcontrol(elem).setselection(sel)
end sub


	&apos; progressbar shows the participation of filled part considering to maximal
Sub StatusBarPr(hodnota as long)
	ALTsearchDOC.CurrentController.statusIndicator.setValue(hodnota)
End Sub


	&apos; initialization of statusbar
Sub StatusBarStart(vyzva as string, maximum as long)
	ALTsearchDOC.CurrentController.statusIndicator.reset
	ALTsearchDOC.CurrentController.statusIndicator.start(vyzva, maximum)
End Sub


	&apos; write statusinfo after the interval n
sub StatusInfo(n as long)
	const interval = 17
	if (n mod interval) = 0 then vypisStatusInfo()
end sub


	&apos; write text to statusbar; empty string = reset to original form OOo
Sub StatusText(sInformation as string, delka, init as boolean, initbar as long)
	Dim iLen,iRest As Integer
	if sInformation= &quot;&quot; then
		ALTsearchDOC.CurrentController.statusIndicator.end
		ALTsearchDOC.CurrentController.statusIndicator.reset
		exit sub
	end if
	iLen=Len(sInformation)
	iRest=delka-iLen
	if init then
		ALTsearchDOC.CurrentController.statusIndicator.start(sInformation &amp; SPACE(iRest),initbar)
	else
		ALTsearchDOC.CurrentController.statusIndicator.settext(sInformation &amp; SPACE(iRest))
		ALTsearchDOC.CurrentController.statusIndicator.setValue(FINDCOUNTER)
	end if
End Sub


	&apos; insert values to the places of parameters \0..\9, &amp;, \u, \i, \I, \} to the string SUBST  (for URL \h and the like)
sub SubstValue(byval subst as string, cur, oriCur) as string
	dim ch, rest as string
	dim lenRepl, i as long
	dim nMode as byte
	rest = &quot;&quot;
	i = 1
	subst = prepis_hex(replDec2hex(subst)) &apos; replace hexadecimally and decimally the entered codes to characters
	lenRepl = len(subst)

	do while i &lt;= lenRepl
		ch = mid(subst, i, 1)
		select case nMode
		case 0 &apos;normal mode
			select case ch
			case &quot;\&quot;  &apos; escape mode - 1st occurrence of slash
				nMode = 1

			case &quot;&amp;&quot;  &apos; the same is \0, insert whole found text
				nMode = 0
				rest = rest  &amp;  ALTsearchSKUP(0)

			case else &apos;maybe the character to searched text
				rest = rest  &amp;  ch

			end select

		case 1	&apos;Escape mode
			nMode = 0
			select case ch
			case &quot;\&quot;, &quot;&amp;&quot;  &apos; v as characters
				rest = rest &amp; ch

			case &quot;u&quot;  &apos; insert URL of found text
				rest = rest &amp; ALTsearchSKUP(10)

			case &quot;b&quot;  &apos; part before searched substring
				rest = rest &amp; ALTsearchSKUP(1)

			case &quot;e&quot;  &apos; part after searched substring
				rest = rest &amp; ALTsearchSKUP(2)

			case &quot;o&quot; &apos; insert text content of object (of note, frame, field ...)
				if (ALTsearchSKUP(11) &lt;&gt; &quot;&quot;) then
					&apos; #13#10 is paragraph, there will be added the line break during inserting
					rest =  rest  &amp;  replace_(ALTsearchSKUP(11),chr(13) &amp; chr(10),chr(13))  &apos; text content

				end if

			case &quot;O&quot; &apos; insert the name of object (of note, frame, field ...)
				if (ALTsearchSKUP(12) &lt;&gt; &quot;&quot;) then
					rest =  rest  &amp;  ALTsearchSKUP(12)  &apos; name of object
				end if

			case &quot;i&quot;  &apos; counter of find - replace
				rest = rest &amp; REPLCOUNT  &apos; attend to formatted counter todo!!!

			case &quot;I&quot;  &apos; number of page
				if ALTsearchPRINTOUT = &quot;&quot; then &apos; redirection isn&apos;t
					nastavVKurzor(Cur, false, &quot;&quot;)  &apos;set visible cursor according to work
					&apos; if it is block of text then detect the page of start of block
					select case Cur.ImplementationName
					case &quot;SwXTextCursor&quot;
						oVCURS.collapseToStart  &apos; the page where it starts is interested, according to original visible cursor
					case &quot;SwXTextTableCursor&quot;  &apos; select the text of 1st cell
						oDOCcontrol.select(oVCURS.Cell)
					end select

				else
					nastavVKurzor(oriCur, false, &quot;&quot;)  &apos;set visible cursor podle puvodniho prac
					&apos; if it is block of text then detect the page of start of block
					select case oriCur.ImplementationName
					case &quot;SwXTextCursor&quot;
						oVCURS.collapseToStart  &apos; the page where it starts is interested, according to original visible cursor
					case &quot;SwXTextTableCursor&quot;  &apos; select the text of 1st cell
						oDOCcontrol.select(oVCURS.Cell)
					end select

				end if

				rest = rest &amp; cstr(oVCURS.getPage())  &apos; insert the number of page of start

			case &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;
				rest = rest &amp; ALTsearchSKUP(val(ch))

			case else &apos; unknown parameter - adopt
				rest = rest &amp; &quot;\&quot; &amp; ch

			end select

		case else
			&apos;shouldn&apos;t happen
		end select

		i = i + 1
	loop

	if nMode = 1 then rest = rest  &amp;  &quot;\&quot;  &apos; last was slash \ adopt
	SubstValue = rest
end sub


	&apos; actualize the values of text fields in document to show proper values after inserting
sub update_fields
	dim document  as object
	dim oDispatcher as object
	document   = ALTsearchDOC.CurrentController.Frame
	oDispatcher = createUnoService(&quot;com.sun.star.frame.DispatchHelper&quot;)
	oDispatcher.executeDispatch(document, &quot;.uno:UpdateFields&quot;, &quot;&quot;, 0, Array())
end sub


	&apos; increase/decrease also the direction of the search, and also according the max, including report
sub vyhodnotHledani(i,max as long) as boolean
	vyhodnotHledani = false
	if max &lt; 0 then
		hlaseni(4)
		exit sub
	end if
	if ALTsearchPARAMS.zpet = 1 then  &apos; reversed bounds for backward search
		if i&lt;=0 then
			if 6 &lt;&gt; hlaseni(1) then exit sub &apos;reached the beginning of document, continue from end?
			i = max
		else
			i = i-1
			if i&lt;0 then i=0 &apos; should to start finding from first
		end if
	else
		if i&gt;=max then
			if 6 &lt;&gt; hlaseni(2) then exit sub &apos;reached the end of document. continue from begin?
			i = 0
		else
			i = i + 1
			if i&gt;max then i=max &apos; should to start finding also from the last
		end if
	end if
	vyhodnotHledani = true
end sub


	&apos; evaluate the counted metacharacter at given position in string INFO
	&apos; array vys(0) will return the length of string of metacharacter - quotation
	&apos; vys(1)/vys(2) return min max of quotation; max=-1 is any count of repetition
sub vyhodnotMetazn(find as string, pol as integer) as array
	dim vysl(2) as integer
	dim i,n as integer
	dim pom
	i=pol
	select case mid(find,i,1) &apos; next character behind the character
	case &quot;?&quot;
		vysl(0) = 1 &apos; length of counted metacharacter
		vysl(1) = 0
		vysl(2) = 1 &apos; max 1
	case &quot;*&quot;
		vysl(0) = 1 &apos; length of counted metacharacter
		vysl(1) = 0
		vysl(2) = -1 &apos; any count
	case &quot;+&quot;
		vysl(0) = 1 &apos; length of counted metacharacter
		vysl(1) = 1
		vysl(2) = -1 &apos; any count
	case &quot;{&quot;
		n = i
		if instr(n,find,&quot;}&quot;) = 0 then goto Problem
		pom = &quot;x&quot; &amp; FindPartStr(find,&quot;{&quot;,&quot;}&quot;,n) &amp; &quot;x&quot;
		vysl(0) = n-i
		if instr(pom,&quot;,&quot;)&gt;0 then  &apos;it contains comma ,
			vysl(1) = val(FindPartStr(pom,&quot;x&quot;,&quot;,&quot;,1)) &apos; min
			vysl(2) = val(FindPartStr(pom,&quot;,&quot;,&quot;x&quot;,1)) &apos; max
			if vysl(2) = 0 then vysl(2) = -1  &apos; if the value of maximum isn&apos;t entered then without limitation
		else &apos; there isn&apos;t comma
			vysl(1) = val(FindPartStr(pom,&quot;x&quot;,&quot;x&quot;,1)) &apos; min
			if vysl(2) &lt; 0 then vysl(2) = 0  &apos; if there isn&apos;t the correct count of repetitions then zero
			vysl(2) = vysl(1)
		end if
	case else &apos; there isn&apos;t counted metacharacter
problem:
		vysl(1)=0
		vysl(2)=0
		vysl(0)=0
	end select
	vyhodnotMetazn() = vysl()
end sub


	&apos; write info under the inputbox Find
sub vypisFoundInfo(itext)
	if not ALTsearchDIALOG_end then oDIAL.model.Lb_info.label = itext
end sub


sub vypisStatusInfo()
	dim pom
	pom = MSG(7) &amp; cstr(FINDCOUNTER)
	if nCOUNT&gt;0 then pom = pom &amp; MSG(16) &amp; nCOUNT   &apos;found
if REPLCOUNT&gt;0 then pom = pom &amp; MSG(31) &amp; REPLCOUNT  &apos; Count of replacements:
	if batREPLCOUNT&gt;0 then pom = pom &amp; MSG(31) &amp; batREPLCOUNT
	StatusText(pom, 100,false,0)
end sub


	&apos; rewrite the choice to the array according the tag
Sub ZapisVolbu(oEvt)
	dim pom
	pom = oEvt.source.getSelectedItem
	pom = right(pom,len(pom)-instr(pom,chr(160)))
	select case oEvt.source.model.tag
	case &quot;freg&quot;   &apos; find-regular options
		InsertTextTuCursor(&quot;Cb_find&quot;,pom,0)

	case &quot;fext&quot;   &apos; find-extend options
		pom = FINDEXT(oEvt.source.getSelectedItemPos())
		pom = right(pom,len(pom)-instr(pom,chr(160))) &apos; separate the command
		select case left(pom,4)
		case &quot;[::G&quot; &apos; insert the widening of selection to cursor
			InsertTextTuCursor(&quot;Cb_find&quot;,pom,1)
		case &quot;[::F&quot;,&quot;[::T&quot;,&quot;[::P&quot;,&quot;[::N&quot;,&quot;[::C&quot;,&quot;[::E&quot;,&quot;[::R&quot; &apos; special commands - delete original content
			InsertTextTuCursor(&quot;Cb_find&quot;,pom,3)
			if (pom=&quot;[::Reference::]&quot;)and isSelTextRange(0) then
				if isObject(oVCURS.Start.ReferenceMark) then
					pom = &quot;\\&quot; &amp; oVCURS.Start.ReferenceMark.Name
					InsertTextTuCursor(&quot;Cb_find&quot;,pom,2)
					&apos; select searched name of reference, to could be potentially simply deleted
					setCursorSel(&quot;Cb_find&quot;, len(oDIAL.model.Cb_find.text)-len(pom) ,len(oDIAL.model.Cb_find.text))
				end if
			end if
			FIRSTPASS = true  &apos; there could be the change of type of object, read the array of objects again
			&apos; unconditionally read again the array at nearest finding

		case &quot;||&quot;  &apos; add to the end the Find and also Replace
			InsertTextTuCursor(&quot;Cb_find&quot;,pom,2)
			InsertTextTuCursor(&quot;Cb_repl&quot;,pom,2)
			&apos; focus and cursor to the end of search
			oDIAL.getControl(&quot;Cb_find&quot;).setfocus()  &apos; focus to the inputbox Find
		case else &apos; and other according to cursor and block
			InsertTextTuCursor(&quot;Cb_find&quot;,pom,0)
		end select

	case &quot;fatr&quot;   &apos; find-attributes options
		pom = FINDATR(oEvt.source.getSelectedItemPos())
		pom = right(pom,len(pom)-instr(pom,chr(160))) &apos; separate the command
		select case pom
		case &quot;[:::p::]&quot;  &apos; find similar
			if not ALTsearchDOC.getCurrentController().getSelection().supportsService(&quot;com.sun.star.text.TextRanges&quot;) then goto problem
			pom = &quot;[:::&quot; &amp; getCharProperties(oVCURS, false) &amp; &quot;::]&quot;

		case &quot;[:::s::]&quot;   &apos; find same
			if not ALTsearchDOC.getCurrentController().getSelection().supportsService(&quot;com.sun.star.text.TextRanges&quot;) then goto problem
			pom = &quot;[:::&quot; &amp; getCharProperties(oVCURS, true) &amp; &quot;::]&quot;

		case &quot;[:::ps::]&quot;  &apos; find paragraph style
			if not ALTsearchDOC.getCurrentController().getSelection().supportsService(&quot;com.sun.star.text.TextRanges&quot;) then goto problem
			&apos; choose from the list of used character style
			pom = &quot;[:::ParaStyleName=&quot; &amp;  getStyleName(&quot;ParagraphStyles&quot;, true)  &amp; &quot;::]&quot;

		case &quot;[:::chs::]&quot;  &apos; find character style
			if not ALTsearchDOC.getCurrentController().getSelection().supportsService(&quot;com.sun.star.text.TextRanges&quot;) then goto problem
			&apos; choose from the list of used character style
			pom = &quot;[:::CharStyleName=&quot; &amp;  getStyleName(&quot;CharacterStyles&quot;, true)  &amp; &quot;::]&quot;

		case &quot;[:::ns::]&quot;  &apos; find list style
			if not ALTsearchDOC.getCurrentController().getSelection().supportsService(&quot;com.sun.star.text.TextRanges&quot;) then goto problem
			&apos; choose from the list of used character style
			pom = &quot;[:::NumberingStyleName=&quot; &amp;  getStyleName(&quot;NumberingStyles&quot;, true)  &amp; &quot;::]&quot;

		end  select

		InsertTextTuCursor(&quot;Cb_find&quot;,pom,3)  &apos; 1= insert to the begin; 3= rewrite existed text = is probably the most reasonable, although not ideal...

	case &quot;rext&quot;   &apos; replace-extend options
		select case left(pom,3)
		case &quot;\C{&quot;  &apos; assign the character style
			pom = &quot;\C{&quot; &amp;  getStyleName(&quot;CharacterStyles&quot;,false)  &amp; &quot;}&quot;

		case &quot;\P{&quot;  &apos; assign the paragraph style
			pom = &quot;\P{&quot; &amp;  getStyleName(&quot;ParagraphStyles&quot;,false)  &amp; &quot;}&quot;

		case &quot;\N{&quot;  &apos; assign the character style
			pom = &quot;\N{&quot; &amp;  getStyleName(&quot;NumberingStyles&quot;,false)  &amp; &quot;}&quot;

		end  select

		InsertTextTuCursor(&quot;Cb_repl&quot;,pom,0)

	case &quot;ratr&quot;   &apos; replace-attributes-properties
		if oEvt.source.SelectedItemPos &gt; 0 then &apos; exclude 1st item that is information about the possibility to load by button
			pom = replace_(pom,&quot; = &quot;, &quot;=&quot;)
			InsertTextTuCursor(&quot;Cb_repl&quot;,&quot;\A{&quot; &amp; pom &amp; &quot;}&quot;,0)
		end if

	end select
	oDIAL.model.Ch_reg.state = 1 &apos; turn on regular expression
	exit sub

problem:
	&apos; bug of selection - not supported.
	hlaseni1(48, true, false, &quot;WriteChoice:  &quot; &amp; MSG(12)) &apos;  16=stop 32=? 48=! 64=info; may suppress; cancel the activities
End Sub


	&apos; truncate the string from right to entered count of characters, possibly replenish ...
sub zkratitNa(byval ret$, poc)as string
	dim le&amp;
	le = len(ret)
	if le&gt;poc then
		ret = left(ret,poc-3) &amp; &quot;...&quot;
	end if
	zkratitNa = ret
end sub

</script:module>