<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="AltSearch" script:language="StarBasic">&apos; AltSearch - for LibreOffice Writer
&apos; licence: CC0 1.0 Universal (CC0 1.0) Public Domain Dedication https://creativecommons.org/publicdomain/zero/1.0/deed.en

option explicit

Global VERSION &apos;version of AltSearch taken with &apos;fromTools &gt; F_VERSION()&apos; from the LibreOffice extension info
public const ERRcontrol = true &apos;false &apos;true  &apos; turn on the own service of bugs: false for debugging, else must be true for proper reaction on bugs for region etc in FindNextInBlock
global ICUcompatability  &apos; = true &apos; reaction on ICU in regular expressions (International Components for Unicode): \xhhhh =&gt; \uhhhh =&gt; accepts both ways
	dim INITerror &apos; counter of repeated bugs of initialization of cursor

global ALTsearchINI(12)  &apos; item 0 boolean - flag it ran before = load ini values
global const ALTSearchMaxHistory=30 &apos;maximum number of items for combo boxes Find, Replace
global ALTsearchFIND(0) as string  &apos; history of search
global ALTsearchREPL(0) as string  &apos; history of replacing
global ALTsearchDOC, ALTsearchDOCCONTROL, ALTsearchKBD, ALTsearchDIALOG  &apos; for control of service in other document windows
global ALTSiniSEL &apos; selection at start
global ALTsearchSKUP(12) as string &apos; array with texts of found groups [the groups are expressions in brackets in regexp (...)]
global HLE(), HLE1(), HLE2(), REPL()  &apos; array with parameters for search HLE() without groups, for faster search, HLE1 a HLE2 is for bigblock
global ALTSlastFOUND  &apos; code with result of last search: 0=found
global oSELS, oDOCcontrol
global MSG(60) as string
global ALTsearchDIALOG_end
global ALTsearchFINDLAST &apos; last expressions searched with findNext
	dim ALTsearchPRINTOUT as string &apos; activation of writing to file \R - name of file - windows
	dim oPOFILE as object &apos; object of file for listing

	dim ALTsearchMFIND(), ALTsearchMREPL() &apos; arrays for individual F&amp;R in regime multi
	dim nCOUNT as long, REPLCOUNT as long, batREPLCOUNT as long &apos; counter of found expressions, counter of substitutions for find all, counter for substitutions for batches
public FOUNDall as variant&apos; collection after fast selection - either 0 or object, according to result of fast search; if 0 then need use selection found via BackColor
	dim WARNING as boolean  &apos; enable the warning before the possibility to break the highlighting
	dim DISPATCHER as object
	dim DISPATHARGS(0) as new com.sun.star.beans.PropertyValue
	dim ERRPROP as long &apos; counter for unsuccessful settings of properties

	dim oDIAL &apos; main dialog
	dim oDSEL &apos; dialog for Style selection
	dim oDMOF &apos; dialog to execute batch for more files
global oDIALSH  &apos; dialog keyboard shortcuts
	dim FIRSTPASS as boolean
	dim ISbatchINIT as boolean  &apos; flag executed initialization of batch module
	dim QUITMODE as boolean
	dim OUTMSG as variant
global SRCHATR() &apos; array with attributes for search

global LISTofWFILES() &apos; list of opened files for Writer
global LISTfilesForBATCH &apos; list of selected files for run the batch
global BATCHtoEXECUTE &apos; name of batch for execution on more files
global COUNTBATCH, COUNTBATCHsel &apos; counters
global oBATCHdispatch  &apos; dispatch for running the batch via helped procedure
global MULTIfileBatchRUN as boolean  &apos; flag that the batch for more files is run
global MULTIfleBatchREPORT as string &apos; total report
global MULTIfleBatchDISABLEMSG as boolean &apos; suppression of partial reports after each file

global prCURS, prCURS1 &apos; hidden cursors
	dim FO1, FO2, FO3, FO0 as object &apos; found blocks: start mark, block between marks, final mark
	dim FO1S, FO2S, FO3S as string &apos; strings replied to start mark, block between and final mark of big-blocks
global oVCURS, oVCURS1 &apos; visible cursor, 1 for file of listing
	dim FINDREG(), FINDEXT(), FINDATR(), REPLEXT()
global INITimplNAME &apos; implem. name of selected object
	dim FINDCOUNTER as long &apos; counter of paragraphs during search \p \m \c, for indicator of search and break the run
global TMPPOLE(), TMPPOLE1() &apos; array for notes, footnote, a text arrays
global LANGUAGE as string

	dim HELPPATH$, USERPATH$, LASTNAME as string  &apos;paths to help and user dir; last used name of batch
	dim TEXTFIELDS as boolean   &apos; flag for the actualization of fields
	dim NOINIT as boolean &apos; true = ban for actualization of cursor - it is hack for non-functional setFocus() of dialog
public FOUNDbookmarkNO as long &apos; index of currently find or processed bookmark (-1 no found)

	dim FOUNDcaseTYPE &apos; 0=without modifications, leave it; 1=1st are Uppercases; 2=all Uppercases;  - number determined the type for strings
	dim HELPkeyMODIF as integer

	dim iREPLACE&amp; &apos;count of no-replacements for final msgbox after Replace all (&quot;!&quot; in select case in function ReplDo) to don&apos;t show this msgbox if there wasn&apos;t any replacement

	type tVolby &apos; remember the parameters of dialog
		kcase as byte
		word as byte
		styl as byte
		reg as byte
		csele as byte
		zpet as byte
		preservecap as byte
		find$
		repl$
	end type

global ALTsearchPARAMS as tVolby  &apos; variable for search options

global sZERO$, sZEROamp$ &apos; fix of bug #74

Sub _AltSearch(optional batchName)   &apos; run main dialog
	dim oL, oKey, loc, tmp, vysl
	
	rem bug #74
	sZERO=chr(&amp;h200D&amp;) &apos;ZeroWidthJoiner
	sZEROamp = sZERO &amp; &quot;&amp;&quot; &apos;ZeroWidthJoiner&amp;
	
    VERSION = fromTools.F_VERSION

	ALTsearchDOC = ThisComponent
	reset_klv   &apos; if the service of keyboard was in other window so free it
	ALTsearchDIALOG = LoadDialog_(&quot;AltSearch&quot;, &quot;D_alts&quot;)
	oDIA_Choice = LoadDialog_(&quot;AltSearch&quot;, &quot;D_choice&quot;)  &apos; due to localization move to the initialization of main dialog
	oDIALSH = LoadDialog_(&quot;AltSearch&quot;, &quot;D_keys&quot;) &apos; dialog for keyboard shortcuts
	oDIAL = ALTsearchDIALOG &apos; not must to rewrite the oDIAL to AltSea...
	oDMOF = LoadDialog_(&quot;AltSearch&quot;, &quot;D_morefiles&quot;)    &apos; dialog for batch on more files
	ISbatchINIT = false
	ALTsearchFINDLAST = &quot;&quot; &apos; last expression that was found with findNext

	DISPATCHER = createUnoService(&quot;com.sun.star.frame.DispatchHelper&quot;) &apos; copy via clipboard

	redim TMPPOLE() &apos; reset the array used for search the frames, notes, footnote, and text fields

	HELPkeyMODIF = 0 &apos; code of modifier during pressing the button Help

	LoadLanguage  &apos; load the strings for language

	HELPPATH = GetHelpDir(&quot;name.TomBil.addon.AltSearch.HelpPath&quot;)
	USERPATH = GetUserPath

	if ALTsearchINI(0)  then &apos; if already run then load history
		&apos;load ini and history of F&amp;R
		if ubound(ALTsearchFIND())=-1 then
			redim ALTsearchFIND(0)
		end if
		oDIAL.model.Cb_find.text = ALTsearchFIND(0)   &apos; found expression
		tmp = oDIAL.getControl(&quot;Cb_find&quot;)
		tmp.removeItems(0,tmp.ItemCount)
		tmp.addItems(ALTsearchFIND(),0)

		if ubound(ALTsearchREPL())=-1 then
			redim ALTsearchREPL(0)
		end if
		oDIAL.model.Cb_repl.text = ALTsearchREPL(0)   &apos; replaced expression
		tmp = oDIAL.getControl(&quot;Cb_repl&quot;)
		tmp.removeItems(0,tmp.ItemCount)
		tmp.addItems(ALTsearchREPL(),0)

		oDIAL.model.Ch_case.state = ALTsearchINI(3) &apos; case sensitive
		oDIAL.model.Ch_word.state = ALTsearchINI(4) &apos; whole words
		oDIAL.model.Ch_reg.state = ALTsearchINI(5)  &apos; regular expressions
		oDIAL.model.Ch_zpet.state = ALTsearchINI(6)  &apos; backward
		oDIAL.model.Ch_styl.state = ALTsearchINI(7)  &apos; find paragraph styles
		oDIAL.model.Ch_preservecap.state = ALTsearchINI(10)  &apos; keep Uppercases

		&apos; set the position of dialog
		oDIAL.setPosSize ALTsearchINI(1), ALTsearchINI(2), 0, 0, 3
	else
		ALTsearchINI(0)  = true
	end if

	ALTSlastFOUND = 10  &apos;code for successfulness of last search (0 = found) after start preventively not found

	NOINIT = false  &apos; don&apos;t reduce CursorInit()
	FIRSTPASS = true
	CursorInit(true) &apos; initialization of cursor positions and block
	&apos; if some block is selected the check the search in block
	if oSELS.supportsService(&quot;com.sun.star.text.TextRanges&quot;) then
		if (not oVCURS.IsCollapsed) then oDIAL.model.Ch_csele.state = 1
	end if

	&apos; set selection in inputbox Find
	setCursorSel(&quot;Cb_find&quot;,0,len(oDIAL.model.Cb_find.text))

	&apos; reaction on ICU in regular expressions (International Components for Unicode): \xhhhh =&gt; \uhhhh =&gt; accepts both ways
	ICUcompatability = getICUcomp    &apos; test the version of OOo, LibreO and set odl or new evaluation of Regexp
	oDIAL.model.Lb2.Helptext = GetProductname_() &apos; informations about version of OOo to title
	if ICUcompatability then
		oDIAL.model.Lb2.label = &quot;       &quot;
	else
		oDIAL.model.Lb2.label = &quot;-ICU&quot;
	end if

	Bt_swfind &apos; switch to base dialog of search (1st page of dialog)

	ALTsearchDIALOG_end = false

	&apos; modal dialog - [v.1.4.2] don&apos;t show if batch is running
	if isMissing(batchName) then oDIAL.setVisible(true)

	&apos; due to possibility to restore the focus of dialog -&gt; add the listener
	oL = createUnoListener(&quot;AltSearchDlg_&quot;,&quot;com.sun.star.awt.XTopWindowListener&quot;)
	oDIAL.addTopWindowListener(oL)

	&apos; if the parameter is set then run the batch immediately
	if not isMissing(batchName) then
		LASTNAME = BatchName
		initCmd  &apos; run via keyboard shortcut
		Bt_run()
		KonecTm &apos;ALTsearchDIALOG_end = true &apos; then end
	end if

	while not ALTsearchDIALOG_end &apos; set before
		wait 300
	wend

	oDIAL.setVisible(false)
End Sub


	&apos; for hot key Ctrl+Shift+L
sub _FindBack
	if ERRcontrol then on error goto konec
	if ALTSlastFOUND&lt;&gt;4 then
		if ALTsearchDIALOG_end then loadParams(true) &apos; restore the options from Ini
		ALTsearchPARAMS.zpet = 1
		if ALTsearchPARAMS.find = &quot;&quot; then exit sub
		FindDo  &apos; search
	end if
	exit sub
konec:
	reset_klv
end sub


	&apos; for hot key Ctrl+L
sub _FindNext
	if ERRcontrol then on error goto konec
	if ALTSlastFOUND&lt;&gt;4 then
		if ALTsearchDIALOG_end then loadParams(true) &apos; restore options from Ini
		ALTsearchPARAMS.zpet = 0
		if ALTsearchPARAMS.find = &quot;&quot; then exit sub
		FindDo  &apos; search
	end if
	exit sub
konec:
	reset_klv
end sub


sub addToHistory(hl as byte, na as byte) &apos; add F or R expression to history
	dim arr() &apos;temporary array
	if hl = 1 then &apos;
		&apos;add to history of Find
		pridejDoSeznamuA(oDIAL.getcontrol(&quot;Cb_find&quot;), ALTsearchPARAMS.find, ALTSearchMaxHistory, 0)
		&apos; save for next run
		ALTsearchFIND = removeZero( oDIAL.getcontrol(&quot;Cb_find&quot;).getItems ) &apos;bug #74
	end  if
	if na = 1 then &apos;
		&apos;add to history of Replace
		pridejDoSeznamuA(oDIAL.getcontrol(&quot;Cb_repl&quot;), ALTsearchPARAMS.repl, ALTSearchMaxHistory, 0)
		&apos; save for next run
		ALTsearchREPL = removeZero( oDIAL.getcontrol(&quot;Cb_repl&quot;).getItems ) &apos;bug #74
	end  if
end sub


	&apos; switch to the dialog for the launching the scripts
Sub Bt_batch
	iniBatch   &apos; initialization of batch module if needed
	oDIAL.Model.Step = 2
End Sub


	&apos; read to  Cb_replAtr the list of properties of selected object
sub Bt_loadAtr
	dim prop, oSe, sezn
	dim pom, i, ppol()
	oDIAL.model.Cb_loadAtr.enabled = false  &apos; deactivate during work
	if ERRcontrol then on error resume next   &apos; bug od property &quot;ClientMap&quot; for text Frame
	sezn = oDIAL.getcontrol(&quot;Cb_replAtr&quot;)
	oSe = ALTsearchDOC.getCurrentController.getSelection

	select case oSe.ImplementationName
	case &quot;SwXTextRanges&quot;,&quot;com.sun.star.drawing.SvxShapeCollection&quot;
		&apos; array with list of properties
		oSe= ALTsearchDOC.getCurrentController.getSelection.getByIndex(0)

	case &quot;SwXTextGraphicObject&quot;,&quot;SwXTextFrame&quot;,&quot;SwXTextTableCursor&quot;, &quot;SwXTextEmbeddedObject&quot;

	case else
		hlaseni1(32, true, false, &quot;Bt_loadAtr:  Unknown object: &quot;  &amp;  oSe.ImplementationName) &apos;16=stop 32=? 48=! 64=info; may suppress; cancel the activities
		goto konec
	end select

	prop = oSe.PropertySetInfo.Properties

	&apos; cancel the old list
	sezn.removeItems(0, sezn.ItemCount)
	for i = 0 to ubound(prop())  &apos; traverse all properties
		pom =&quot;&quot;
		&apos; isn&apos;t the property read only?
		if (not((prop(i).Attributes and 16) = 16)) then
			select case prop(i).type.TypeClass
				&apos; .type.TypeClass: 2-boolean, 3-byte, 4-short, 6-long, 10-float, 11-double, 12-string
				&apos;                 15-constant OOo, 17-struct, 20-array []string, 22-events, index???
			case 2,3,4,6,10,11,12,15
				pom = prop(i).name &amp;  &quot; = &quot; &amp; oSe.GetPropertyValue(prop(i).name)
				sezn.addItem(pom, sezn.ItemCount)

			case 17  &apos; struct
				pom = prop(i).name  &amp;  &quot;: &quot;  &amp;  getStructValues(oSe,prop(i).name)
				sezn.addItem(pom, sezn.ItemCount)

			case 20, 22  &apos; arrays, events - ignore

			case else  &apos; the rest - ignorovat

			end  select
		end if
	next i

	pom = &quot;&quot;
	pom = oSe.getName()
	if pom&lt;&gt;&quot;&quot; then sezn.addItem(&quot;Name = &quot; &amp; pom, sezn.ItemCount)

	ppol() = BubbleSortList_(sezn.items) &apos; save due to sorting
	sezn.removeItems(0, sezn.ItemCount)  &apos; cancel old list
	sezn.addItems(ppol(),0)  &apos; load sorted list
	sezn.addItem(MSG(22),0)  &apos; 1st item = Help: update list with the button at left

konec:
	oDIAL.model.Cb_loadAtr.enabled = true &apos; activsate
end sub


	&apos; save to new or add to exist record
Sub Bt_save1
	SaveBatch(1)
End Sub


	&apos; count the occurences
sub BtCount
	if NOT testViewCursor then exit sub &apos;test if Visible cursor isn&apos;t in Comment etc.
	dim info, curinit, curs, i, j, max, hled, pom, bin, oTmp, oAnch, inFoot, oFoot, mode
	info = &quot;&quot;  &apos;information filed under the inpubox Find
	loadParams(false) &apos; save options of search
	redim TMPPOLE() &apos; reset the array used for search the frames, notes, footnote, a text field
	addToHistory(1,0) &apos;add to history the F&amp;R expressions

	i = instr(ALTsearchPARAMS.find,&quot;[::BigBlock::]&quot;)
	if (i &gt; 0)and (ALTsearchPARAMS.reg=1) then
		&apos;big block
		&apos; start and final string for search the BigBlock
		pom = left(ALTsearchPARAMS.find,i-1)
		HLE1() = getFindArray(pom, false) &apos; array with search without groups ()
		&apos; final closing string for search the Bigblock
		pom = right(ALTsearchPARAMS.find,len(ALTsearchPARAMS.find)-i-13) &apos; I search the end
		HLE2() = getFindArray(pom, false) &apos;array with the search without groups ()
		HLE() = HLE1()
		HLE(0).cmd = &quot;[::BigBlock::]&quot;
	else
		&apos; normal search - no big block
		pom = ALTsearchPARAMS.find
		if (ALTsearchPARAMS.reg=1) then  &apos; prepare for regexp
			pom = replace_(pom,&quot;\|&quot;,&quot;\x007C&quot;)  &apos; it isn&apos;t delimiter OR but character &quot;|&quot;
		end if
		HLE() = getFindArray(pom, false) &apos; for presearch , WITHOUT possible groups - straight search with groups is very slow
		i = instr(pom,&quot;||&quot;)
		if (i &gt; 0)and (ALTsearchPARAMS.reg=1) then &apos; multi replacement
			&apos;arrays for partial multisearch
			ALTsearchMFIND() = ArrayOutOfString_(pom,&quot;||&quot;)
			HLE(0).cmd = &quot;[::MultipleSearch::]&quot;
		end if
	end if

	curinit = false  &apos; refresh the cursors after found with CursorInit(true)
	HledamDisp(true) &apos; not accessible during counting
	FINDCOUNTER = 1  &apos; general counter for status figures &gt;0 cn cancel the action
	nCOUNT = 0       &apos; counter of found expressions
	if ALTsearchPARAMS.reg &lt;&gt; 1 then
		&apos; normal search without regular expressions
		if not Pocitej(HLE(),false) then goto chyba &apos; procedure for universal counting outside the special objects
		goto konec &apos; show reports and end
	else
		&apos; search with regexps
		select case HLE(0).cmd
		case &quot;[::MultipleSearch::]&quot;
			for i=0 to ubound(ALTsearchMFIND())  &apos; search across all search
				pom = ALTsearchMFIND(i)
				HLE() = getFindArray(pom, false) &apos; for presearch, WITHOUT possible groups that is very slow
				if not Pocitej(HLE(),false) then goto chyba &apos; procedure for univerzal calculating outside the special objects
			next i
		case &quot;[::Comment::]&quot;, &quot;[::Field::]&quot;, &quot;[::Reference::]&quot;
			hled = HLE(0).hled
			select case HLE(0).cmd
			case &quot;[::Comment::]&quot;
				getSortFields(TMPPOLE(), TMPPOLE1(), &quot;Annotation&quot;, false)  &apos; read quickly the unsorted notes
				if hled = &quot;&quot; then : mode = 0 : else : mode = 1 : end if  &apos; set the mode of search
			case &quot;[::Field::]&quot;
				getSortFields(TMPPOLE(), TMPPOLE1(), &quot;All&quot;, false)  &apos; read quickly the unsorted fields
				if hled = &quot;&quot; then : mode = 0 : else : mode = 1 : end if  &apos; set the mode of search
			case &quot;[::Reference::]&quot;
				getSortFields(TMPPOLE(), TMPPOLE1(), &quot;GetReference&quot;, false)  &apos; read quickly the unsorted references
				mode = -1  &apos; -1 = search in the text that is visible (in anchor of object); 1 = search in Title (in bubble); 0 = find all
				if hled = &quot;\\&quot; then &apos; search empty text
					hled = &quot;&quot;
				else
					if left(hled,2)= &quot;\\&quot; then  &apos; search in title
						mode = 1
						hled = rightPast(hled, &quot;\\&quot;)
					else
						if hled = &quot;&quot; then  &apos; find all
							mode = 0
						end if
					end if
				end if
			end select

			if (ALTsearchPARAMS.csele=0) and (hled = &quot;&quot;) and (mode=0) then &apos; all document
				&apos; speedup for all fileds in document
				nCOUNT = ubound(TMPPOLE()) + 1
			else
				for i = 0 to Ubound(TMPPOLE())  &apos; for all objects - fields without frames
					select case HLE(0).cmd
					case &quot;[::Comment::]&quot;
						pom = TMPPOLE(i).content
					case &quot;[::Field::]&quot;
						pom = TMPPOLE(i).anchor.string
					case &quot;[::Reference::]&quot;
						if mode = 1 then  &apos; search in name of mark ?
							pom = TMPPOLE(i).SourceName
						else &apos; search in text of anchor
							pom = TMPPOLE(i).anchor.string
						end if
					end select

					&apos; is searched substring HLED included in VST and is potentially inside the block?
					&apos; if pom = 0 then the search is run without the regard to occurence of found substring
					if isSubstrInBlock(TMPPOLE(i),pom,hled,mode) then
						nCOUNT = nCOUNT + 1 &apos; yes, found, count it
					end if &apos; substring is found
					if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
					StatusInfo(i) &apos; print the statusinfo after some interval
				next i

				nastavVKurzor(ALTSiniSEL, false, &quot;&quot; ) &apos; restore original selection
			end if


		case &quot;[::Footnote::]&quot;, &quot;[::Endnote::]&quot;
			hled = HLE(0).hled
			&apos; \ = search in text of note
			inFoot = -1  &apos; -1 = search in anchor that is visible (anchor of object); 1 = search in text of note (bubble); 0 = search all
			if left(hled,2)= &quot;\\&quot; then
				inFoot = 1
				hled = rightPast(hled, &quot;\\&quot;)
			end if
			if hled = &quot;&quot; then inFoot = 0 &apos; search all
			if HLE(0).cmd = &quot;[::Footnote::]&quot; then
				oFoot = ALTsearchDOC.Footnotes
			else
				oFoot = ALTsearchDOC.Endnotes
			end if

			max = oFoot.count - 1  &apos; max index of last note
			if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison

			if (ALTsearchPARAMS.csele=0) and (hled = &quot;&quot;) then &apos; all in whole document
				&apos; speedup for all arrays in document
				nCOUNT = max + 1
				goto konec
			end if

			for i = 0 to max
				&apos; search in content of note ?
				if inFoot=1 then
					pom = oFoot(i).string
				else &apos; search in text of anchor
					pom = oFoot(i).anchor.string
				end if

				&apos; is searched substring HLED included in VST and is potentially inside the block?
				&apos; if inFoot = 0 then there is search of searched substring without regard
				if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
					nCOUNT = nCOUNT + 1
				end if &apos;nalezeno

				if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval
			next i


		case &quot;[::Bookmark::]&quot;
			hled = HLE(0).hled
			&apos; \ = searching in names of bookmarks
			inFoot = -1  &apos; -1 = search in text of bookmark; 1 = search in name of bookmarks; 0 = search any bookmark
			if left(hled,2)= &quot;\\&quot; then
				inFoot = 1
				hled = rightPast(hled, &quot;\\&quot;)
			end if
			if hled = &quot;&quot; then inFoot = 0 &apos; find all

			oFoot = ALTsearchDOC.Bookmarks
			max = oFoot.count - 1  &apos; max index of last note
			if (ALTsearchPARAMS.csele=0)and (hled = &quot;&quot;) and (inFoot=0) then &apos; all in whole document
				&apos; sppedup for all arrays in document
				nCOUNT = max + 1
				goto konec
			end if

			for i = 0 to max
				&apos; search in content of bookarks ?
				if inFoot=1 then  &apos; search in names
					pom = oFoot(i).Name
				else &apos; search in text of anchor
					pom = oFoot(i).anchor.string  &apos; search in content of bookmark
				end if

				&apos; is searched substring HLED included in VST and is potentially inside the block?
				&apos; if inFoot = 0 then there is search of searched substring without regard
				if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
					nCOUNT = nCOUNT + 1  &apos; select and count
				end if &apos; color the found
				if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval
			next i


		case &quot;[::ReferenceMark::]&quot;
			hled = HLE(0).hled
			inFoot = -1  &apos;-1 = search in text; 1 = search in title (bubble); 0 = search all
			if hled = &quot;\\\\&quot; then &apos; search empty text
				hled = &quot;&quot;
			else
				if left(hled,2)= &quot;\\&quot; then  &apos; search in name
					inFoot = 1
					hled = rightPast(hled, &quot;\\&quot;)
				else
					if hled = &quot;&quot; then  &apos; search all
						inFoot = 0
					end if
				end if
			end if

			oFoot = ALTsearchDOC.ReferenceMarks
			max = oFoot.count - 1  &apos; max index of last mark
			if (ALTsearchPARAMS.csele=0)and (hled = &quot;&quot;) and (inFoot=0) then &apos; all in whole document
				&apos; speedup all arrays in document
				nCOUNT = max + 1
				goto konec
			end if

			for i = 0 to max
				&apos; search the marks ?
				if inFoot = 1 then
					pom = oFoot(i).Name
				else &apos; search in text of anchor
					pom = oFoot(i).anchor.string
				end if

				&apos; is searched substring HLED included in VST and is potentially inside the block?
				&apos; if inFoot = 0 then there is search of searched substring without regard
				if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
					nCOUNT = nCOUNT + 1  &apos; select and count
				end if &apos; color the found
				if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval
			next i


		case &quot;[::TextFrame::]&quot;
			max = getIndexTextFrame(1,0,&quot;&quot;)
			hled = HLE(0).hled

			if ALTsearchPARAMS.csele=0 then &apos; whole document
				if hled = &quot;&quot; then
					nCOUNT = max + 1
				else
					&apos; count only items that include searched substring
					i = getIndexTextFrame(2,-1,hled)  &apos; find 1st substring
					do while (i&gt;=0)and(i&lt;=max)
						nCOUNT = nCOUNT + 1
						i = getIndexTextFrame(2,i,hled)  &apos;find next substring
						if FINDCOUNTER &lt; 0 then exit do &apos; cancel, end
						StatusInfo(i) &apos; show statusinfo after set interval
					loop
				end if

			else &apos; only selection
				&apos; auxiliary array pomocné with the names of text frames
				TMPPOLE()= ALTsearchDOC.getTextFrames.ElementNames
				if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison

				for i = 0 to Ubound(TMPPOLE())  &apos; for all objects - array of names of frames
					&apos; the substring is found or find all
					if (instr(1,TMPPOLE(i),hled,bin)&gt;0)or(hled=&quot;&quot;) then
						&apos;ascertain the anchor - to oAnch
						oTmp = ALTsearchDOC.getTextFrames.getByName(TMPPOLE(i)) &apos; object of frame
						oAnch = getAnchorOfFramePicture(oTmp)
						&apos; is the anchor inside the selection?
						if isInsideOfSelection(oAnch) then nCOUNT = nCOUNT + 1 &apos; yes, found, count it
					end if
					if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
					StatusInfo(i) &apos; show statusinfo after set interval
				next i
				nastavVKurzor(ALTSiniSEL, false, &quot;&quot; ) &apos; refresh original selection
			end if


		case &quot;[::TextTable::]&quot;
			max = getIndexTextTable(1,0,&quot;&quot;)
			hled = HLE(0).hled
			if ALTsearchPARAMS.csele=0 then &apos; whole document
				if hled = &quot;&quot; then
					nCOUNT = max + 1
				else
					&apos; count only items that include the searched substring
					i = getIndexTextTable(2,-1,hled)  &apos; find 1st substring
					do while (i&gt;=0)and(i&lt;=max)
						nCOUNT = nCOUNT + 1
						i = getIndexTextTable(2,i,hled)  &apos; find next substring
						if FINDCOUNTER &lt; 0 then exit do &apos; cancel, end
						StatusInfo(i) &apos; show statusinfo after set interval
					loop
				end if

			else &apos; only selection
				TMPPOLE()= ALTsearchDOC.getTextTables.ElementNames
				if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison

				for i = 0 to Ubound(TMPPOLE())  &apos; pro all objects - array with the names of tables
					&apos; the substring is found or find all
					if (instr(1,TMPPOLE(i),hled,bin)&gt;0)or(hled=&quot;&quot;) then
						&apos;ascertain the anchor - to oAnch
						oTmp = ALTsearchDOC.getTextTables.getByName(TMPPOLE(i)) &apos; object of frame
						oAnch = getTextRangeOfTable(oTmp)
						&apos; is anchor inside the selection?
						if isInsideOfSelection(oAnch) then nCOUNT = nCOUNT + 1 &apos; yes, found, count
					end if
					if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
					StatusInfo(i) &apos; show statusinfo after set interval
				next i
				nastavVKurzor(ALTSiniSEL, false, &quot;&quot; ) &apos; refresh original selection
			end if &apos;only selection


		case &quot;[::Picture::]&quot;
			max = getIndexPicture(1,0,&quot;&quot;)
			hled = HLE(0).hled
			if ALTsearchPARAMS.csele=0 then &apos; whole document
				if hled = &quot;&quot; then
					nCOUNT = max + 1
				else
					&apos; count only items that include the searched substring
					i = getIndexPicture(2,-1,hled)  &apos; find 1st substring
					do while (i&gt;=0)and(i&lt;=max)
						nCOUNT = nCOUNT + 1
						i = getIndexPicture(2,i,hled)  &apos; find next substring
						if FINDCOUNTER &lt; 0 then exit do &apos; cancel, end
						StatusInfo(i) &apos; show statusinfo after set interval
					loop
				end if

			else &apos;only selection
				TMPPOLE()= ALTsearchDOC.GraphicObjects.ElementNames
				if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison

				for i = 0 to Ubound(TMPPOLE())  &apos; for all objects - array with the names of images
					&apos; the substring is found or find all
					if (instr(1,TMPPOLE(i),hled,bin)&gt;0)or(hled=&quot;&quot;) then
						&apos;ascertain the anchor - to oAnch
						oTmp = ALTsearchDOC.GraphicObjects.getByName(TMPPOLE(i)) &apos; object of frame
						oAnch = getAnchorOfFramePicture(oTmp)
						&apos;is anchor inside the selection?
						if isInsideOfSelection(oAnch) then nCOUNT = nCOUNT + 1 &apos; yes, found, count it

					end if &apos; the substring is found or find all
					if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
					StatusInfo(i) &apos; show statusinfo after set interval
				next i
				nastavVKurzor(ALTSiniSEL, false, &quot;&quot; ) &apos; refresh original selection
			end if &apos;only selection


		case &quot;[::BigBlock::]&quot;  &apos; bigBlock
			resetPrCurs &apos; set prCURS in the dependence of selected block and choice of block
hledejdal:
			j = FindNextInBlock(HLE1(), prCURS, ALTSiniSEL, false, false)
			if j &lt;&gt; 0 then goto vratcurs
			FO1 = nastavKurzor(prCURS)  &apos; remember the start
			FO2 = FO1.text.createTextCursor()  &apos;nastavKurzor(prCURS)  &apos; same region for FO2

			j = FindNextInBlock(HLE2(), prCURS, ALTSiniSEL, false, false)
			if j &lt;&gt; 0 then goto vratcurs &apos; no found
			FO3 = nastavKurzor(prCURS)  &apos; save result to FO3

			if nastavRozsah(FO2, FO1.getEnd(),FO3.getStart()) &lt;&gt; 0 then
				prCURS = nastavKurzor(FO1) &apos; in the case of bug of region search farther behind the FO1
				goto hledejdal
			end if

			if ALTsearchPARAMS.zpet = 1 then  &apos; inverse bounds for backward search
				if nastavRozsah(prCURS, FO1.getEnd(),FO3.getStart()) &lt;&gt; 0 then
					prCURS = nastavKurzor(FO1) &apos; in the case of bug of region search farther behind the FO1
					goto hledejdal
				end if
			else
				if nastavRozsah(prCURS, FO1.getStart(),FO3.getEnd()) &lt;&gt; 0 then
					prCURS = nastavKurzor(FO1) &apos; in the case of bug of region search farther behind the FO1
					goto hledejdal
				end if
			end if

			&apos; found
			nCOUNT = nCOUNT + 1
			goto hledejDal
vratcurs:
			goto konec

		case else   &apos; standard regexp
			&apos; normal regexps
			if not Pocitej(HLE(),false) then goto chyba &apos; procedure for universal calculating outside of special objects
		end select

	end if
konec:
	HledamDisp(false) &apos; accessible search
	hlaseni(5) &apos; pocet
	redim TMPPOLE() &apos; reset the array used for search the frames, notes, footnote, a text field
	exit sub
chyba:
	HledamDisp(false) &apos; accessible search
end sub


	&apos;button find all
sub BtFindAll
	if NOT testViewCursor then exit sub &apos;test if Visible cursor isn&apos;t in Comment etc.
	dim info, curinit, curs, i, j, max, hled, pom, bin, oAnch, oFoot, inFoot, mode
	info = &quot;&quot;  &apos; information box under the Find
	loadParams(false) &apos; save the options of search
	redim TMPPOLE() &apos; reset the array used for search the frames, notes, footnote, a text field
	addToHistory(1,0) &apos; &apos;add to history the F&amp;R expressions

	i = instr(ALTsearchPARAMS.find,&quot;[::BigBlock::]&quot;)
	if (i &gt; 0)and (ALTsearchPARAMS.reg=1) then
		&apos; big block
		&apos; start, open string for the search of big block
		pom = left(ALTsearchPARAMS.find,i-1)
		HLE1() = getFindArray(pom, false) &apos; the array with the search without groups ()
		&apos; final, close string for search of big block
		pom = right(ALTsearchPARAMS.find,len(ALTsearchPARAMS.find)-i-13) &apos; search the end
		HLE2() = getFindArray(pom, false) &apos; the array with the search without groups ()
		HLE() = HLE1()
		HLE(0).cmd = &quot;[::BigBlock::]&quot;
	else
		&apos; normal search - no big block
		pom = ALTsearchPARAMS.find
		&apos;test for multireplace
		if (ALTsearchPARAMS.reg=1) then  &apos; prepare for regexp
			pom = replace_(pom,&quot;\|&quot;,&quot;\x007C&quot;)  &apos; it is not delimiter OR but the character &quot;|&quot;
		end if
		HLE() = getFindArray(pom, false) &apos; for presearch, WITHOUT possible groups - straight search with groups is very slow
		i = instr(pom,&quot;||&quot;)
		if (i &gt; 0)and (ALTsearchPARAMS.reg=1) then &apos; multireplacement with the regexp symbolsmultireplacement with the regexp symbols
			HLE1() = getFindArray(pom, false) &apos; without groups, not important, ones will be loaded onec more singly
			&apos;the arrays for individual multisearch
			HLE(0).cmd = &quot;[::MultipleSearch::]&quot;  &apos; the rest isn&apos;t important, it will be processed once again
			ALTsearchMFIND() = ArrayOutOfString_(pom,&quot;||&quot;)  &apos; the array with the individual substrings for search
		else
			&apos; no used HLE1() for Find all?
			HLE1() = getFindArray(pom, true) &apos; the array with the search also with groups () - the array has more records = slower search
		end if
	end if

	curinit = false  &apos; refresh the cursors with CursorInit(true) after find
	HledamDisp(true) &apos; not accessible during counting
	FINDCOUNTER = 1  &apos; general counter for status entries; &gt;0 it is possible to cancel
	nCOUNT = 0       &apos; counter of found expressions
	WARNING = true  &apos; enable the warning before the possibility of violation the highlighting

	if ALTsearchPARAMS.reg &lt;&gt; 1 then
		&apos; normal search without regexps
		if not Pocitej(HLE(),true) then goto chyba &apos; procedure for universal calculating outside of special objects
		if isObject(FOUNDall) then &apos; found with accelerated search, 0 = highlight with BCOLOR
			ALTsearchDOC.getCurrentController.select(FOUNDall)  &apos;&apos;
			hlaseni(5)
			goto chyba &apos; the end without of highlighting with BCOLOR
		end if
		&apos; normal end with the highlighting with BCOLOR
	else
		&apos; search with regexps
		select case HLE(0).cmd
		case &quot;[::MultipleSearch::]&quot;
			for i=0 to ubound(ALTsearchMFIND())  &apos; search over all || search
				pom = ALTsearchMFIND(i)
				HLE() = getFindArray(pom, false) &apos; for presearch , WITHOUT possible groups - straight search with groups is very slow
				if not Pocitej(HLE(),true) then goto chyba &apos; procedure for universal calculating outside of special objects
				if isObject(FOUNDall) then &apos; found with accelerated search but it need highlight
					&apos; show warning about the violation of highlighting before 1st use
					if WARNING then  &apos; only for 1st time
						if isUsedCharBackColor then
							if 6 &lt;&gt; hlaseni(7) then goto chyba
						end if
						ClearBackColor &apos; cancel potential previous helped colors
						WARNING = false
					end if

					for j = 0 to FOUNDall.count-1
						FOUNDall(j).CharBackColor = BCOLOR
					next j
				end if
			next i

		case &quot;[::Comment::]&quot;, &quot;[::Field::]&quot;, &quot;[::Reference::]&quot;
			if isUsedCharBackColor then
				if 6 &lt;&gt; hlaseni(7) then goto chyba &apos; warning about highlighting
			end if
			ClearBackColor &apos; cancel potential previous helped colors

			hled = HLE(0).hled
			select case HLE(0).cmd
			case &quot;[::Comment::]&quot;
				getSortFields(TMPPOLE(), TMPPOLE1(), &quot;Annotation&quot;, false)  &apos; load quickly the non-sorted notes
				if hled = &quot;&quot; then : mode = 0 : else : mode = 1 : end if  &apos; set the mode of search
			case &quot;[::Field::]&quot;
				getSortFields(TMPPOLE(), TMPPOLE1(), &quot;All&quot;, false)  &apos; load quickly the non-sorted arrays
				if hled = &quot;&quot; then : mode = 0 : else : mode = 1 : end if  &apos; set the mode of search
			case &quot;[::Reference::]&quot;
				getSortFields(TMPPOLE(), TMPPOLE1(), &quot;GetReference&quot;, false)  &apos; load quickly the non-sorted references
				mode = -1  &apos; -1 = search in text that is visible (anchor of object); 1 = search in title (in bubble); 0 = find all
				if hled = &quot;\\&quot; then &apos; search empty text
					hled = &quot;&quot;
				else
					if left(hled,2)= &quot;\\&quot; then  &apos; search in title
						mode = 1
						hled = rightPast(hled, &quot;\\&quot;)
					else
						if hled = &quot;&quot; then  &apos; find all
							mode = 0
						end if
					end if
				end if
			end select

			if (ALTsearchPARAMS.csele=0) and (hled = &quot;&quot;) and (mode=0) then &apos; whole document
				&apos; speedup for all fields in document
				for i = 0 to ubound(TMPPOLE()) &apos; color everything
					TMPPOLE(i).anchor.CharBackColor = BCOLOR
					nCOUNT = nCOUNT + 1
					if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
					StatusInfo(i) &apos; show statusinfo after set interval
				next i
			else
				for i = 0 to Ubound(TMPPOLE())  &apos; for all objects - array of names of frames
					select case HLE(0).cmd
					case &quot;[::Comment::]&quot;
						pom = TMPPOLE(i).content
					case &quot;[::Field::]&quot;
						pom = TMPPOLE(i).anchor.string
					case &quot;[::Reference::]&quot;
						if mode = 1 then  &apos; search in title znacky ?
							pom = TMPPOLE(i).SourceName
						else &apos; search in text of anchor
							pom = TMPPOLE(i).anchor.string
						end if
					end select

					&apos; is searched substring HLED included in VST a is potentially inside the block?
					&apos; if pom=0 then the searched substring is found without regard
					if isSubstrInBlock(TMPPOLE(i),pom,hled,mode) then
						TMPPOLE(i).anchor.CharBackColor = BCOLOR
						nCOUNT = nCOUNT + 1 &apos; yes, found, count it
					end if &apos; substring is found

					if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
					StatusInfo(i) &apos; show statusinfo after set interval
				next i
				nastavVKurzor(ALTSiniSEL, false, &quot;&quot; ) &apos; refresh original selection
			end if


		case &quot;[::Footnote::]&quot;, &quot;[::Endnote::]&quot;
			if isUsedCharBackColor then
				if 6 &lt;&gt; hlaseni(7) then goto chyba &apos; warning about highlighting
			end if
			ClearBackColor &apos; cancel potential previous helped colors

			hled = HLE(0).hled

			&apos; \ = search in text of note
			inFoot = -1  &apos; -1 = search in anchor that is visible (in anchor of object); 1 = search in text of note (in bubble); 0 = find all
			if left(hled,2)= &quot;\\&quot; then
				inFoot = 1
				hled = rightPast(hled, &quot;\\&quot;)
			end if
			if (hled = &quot;&quot;) then inFoot = 0 &apos; find all

			if HLE(0).cmd = &quot;[::Footnote::]&quot; then
				oFoot = ALTsearchDOC.Footnotes
			else
				oFoot = ALTsearchDOC.Endnotes
			end if

			max = oFoot.count - 1  &apos; max index of last note
			if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison

			for i = 0 to max
				&apos; search in content of note?
				if inFoot=1 then
					pom = oFoot(i).string
				else &apos; search in text of anchor
					pom = oFoot(i).anchor.string
				end if

				&apos; is searched substring HLED included in VST a is potentially inside the block?
				&apos; if inFoot=0 then is searched the found substring without regard
				if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
					&apos; select and count
					if left(HLE(0).hled,2)= &quot;\\&quot; then &apos; exception: there was \ at start so select the texts of notes
						&apos; pomocný kurzor s textem poznamky
						curs = oFoot(i).start.text.createTextCursorByRange(oFoot(i).start.getStart())
						curs.goToRange(oFoot(i).getEnd(),true)
						curs.CharBackColor = BCOLOR
					else  &apos; vybrat kotvy
						oFoot(i).anchor.CharBackColor = BCOLOR
					end if
					nCOUNT = nCOUNT + 1
				end if &apos;nalezeno

				if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval
			next i


		case &quot;[::ReferenceMark::]&quot;
			if isUsedCharBackColor then
				if 6 &lt;&gt; hlaseni(7) then goto chyba &apos; warning about highlighting
			end if
			ClearBackColor &apos; cancel potential previous helped colors

			hled = HLE(0).hled
			inFoot = -1  &apos; -1 = search in text that is visible (anchor of object); 1 = hledat ve Názvu (v bublině); 0 = find all
			if hled = &quot;\\\\&quot; then &apos; search empty text
				hled = &quot;&quot;
			else
				if left(hled,2)= &quot;\\&quot; then  &apos; search in title
					inFoot = 1
					hled = rightPast(hled, &quot;\\&quot;)
				else
					if hled = &quot;&quot; then  &apos; find all
						inFoot = 0
					end if
				end if
			end if

			oFoot = ALTsearchDOC.ReferenceMarks
			max = oFoot.count - 1  &apos;  max index of last note
			if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison

			for i = 0 to max
				&apos; search in title of mark
				if inFoot = 1 then
					pom = oFoot(i).Name
				else &apos; search in text
					pom = oFoot(i).anchor.string
				end if

				&apos; is searched substring HLED included in VST a is potentially inside the block?
				&apos; if inFoot=0 is searched the found substring without regard
				if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
					&apos; select and count
					if oFoot(i).anchor.string = &quot;&quot; then
						curs = oFoot(i).anchor.text.createTextCursorByRange(oFoot(i).anchor.getStart())
						curs.goRight(1,true)
						curs.CharBackColor = BCOLOR
					else
						oFoot(i).anchor.CharBackColor = BCOLOR
					end if
					nCOUNT = nCOUNT + 1
				end if &apos; found

				if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval
			next i


		case &quot;[::Bookmark::]&quot;
			hlaseni(6)
			goto chyba

		case &quot;[::TextFrame::]&quot;
			hlaseni(6)
			goto chyba

		case &quot;[::TextTable::]&quot;
			hlaseni(6)
			goto chyba

		case &quot;[::Picture::]&quot;
			hlaseni(6)
			goto chyba

		case &quot;[::BigBlock::]&quot;  &apos; bigBlock
			resetPrCurs &apos; set prCURS in the dependence of selected block and choice of block
hledejdal:
			j = FindNextInBlock(HLE1(), prCURS, ALTSiniSEL, false, false)
			if j &lt;&gt; 0 then goto vratcurs
			FO1 = nastavKurzor(prCURS)  &apos; remember the start
			FO2 = FO1.text.createTextCursor()  &apos;nastavKurzor(prCURS)  &apos; same region for FO2

			j = FindNextInBlock(HLE2(), prCURS, ALTSiniSEL, false, false)
			if j &lt;&gt; 0 then goto vratcurs &apos; no found
			FO3 = nastavKurzor(prCURS)  &apos; save result to FO3

			if nastavRozsah(FO2, FO1.getEnd(),FO3.getStart()) &lt;&gt; 0 then
				prCURS = nastavKurzor(FO1) &apos; in the case of bug of region search farther behind the FO1
				goto hledejdal
			end if

			if ALTsearchPARAMS.zpet = 1 then  &apos; inverse bounds for backward search
				if nastavRozsah(prCURS, FO1.getEnd(),FO3.getStart()) &lt;&gt; 0 then
					prCURS = nastavKurzor(FO1) &apos; in the case of bug of region search farther behind the FO1
					goto hledejdal
				end if
			else
				if nastavRozsah(prCURS, FO1.getStart(),FO3.getEnd()) &lt;&gt; 0 then
					prCURS = nastavKurzor(FO1) &apos; in the case of bug of region search farther behind the FO1
					goto hledejdal
				end if
			end if

			&apos; found
			&apos; show warning about the violation of highlighting before 1st use
			if WARNING then  &apos; only for 1st time
				if isUsedCharBackColor then
					if 6 &lt;&gt; hlaseni(7) then goto chyba
				end if
				ClearBackColor &apos; cancel potential previous helped colors
				WARNING = false
			end if
			prCURS.CharBackColor = BCOLOR  &apos; if the highlighting is enabled then select by color

			&apos; found
			nCOUNT = nCOUNT + 1
			goto hledejDal

vratcurs:
			goto konec
		case else   &apos; standard regexp
			&apos; normal regexp
			if not Pocitej(HLE(),true) then goto chyba &apos; procedure for universal calculating outside of special objects
			if isObject(FOUNDall) then &apos; foudn with accelerated search
				ALTsearchDOC.getCurrentController.select(FOUNDall)
				nCOUNT = FOUNDall.count
				goto konec1 &apos; the end without of highlighting with BCOLOR
			end if
			&apos; normal end with the highlighting with BCOLOR
		end select
	end if  &apos; search with regexps

konec:
	SelectAllBColor &apos; select like disjointed block everything that has the background &quot;BCOLOR&quot;
	ClearBackColor  &apos; cancel helped colors
konec1:
	HledamDisp(false) &apos; accessible search
	hlaseni(5) &apos; BtFindAll
	redim TMPPOLE() &apos; reset the array used for search the frames, notes, footnote, a text field
	exit sub
chyba:
	HledamDisp(false) &apos; accessible search
end sub


	&apos; find next
sub BtFindNext
	if NOT testViewCursor then exit sub &apos;test if Visible cursor isn&apos;t in Comment etc.
	dim info, curs,i, pom
	&apos; problem in Linux - unwanted actualization of cursor after 1st search of objects
	&apos; if there is loaded TMPPOLE and there is set unempty string ALTsearchFINDLAST, then is supposed it isn&apos;t 1st passing
	&apos; ALTsearchFINDLAST is set during 1st load of TMPPOLE() in procedure mySelDialFocus()
	&apos; this all is needed because of non-functional oDIAL.setFocus() after hodong of window and showing the window of file in Linux OOo minimally to version 2.2.1
	&apos; GetGuiType  &apos; 1=Win 2=Mac 3=UNIX 4=Linux
	if ((GetGuiType=3)or(GetGuiType=4) )and(ubound(TMPPOLE())&gt;-1)and(FIRSTPASS)and(leftTo(ALTsearchFINDLAST,&quot;::]&quot;)=leftTo(oDIAL.model.Cb_find.text,&quot;::]&quot;)) then FIRSTPASS = false
	ALTsearchFINDLAST = &quot;&quot;

	info = &quot;&quot;  &apos; information box under the Find
	loadParams(false) &apos; save the options of search

	if FIRSTPASS then
		redim TMPPOLE() &apos; reset the array used for search the frames, notes, footnote, a text field
		FOUNDbookmarkNO = -1 &apos; the index of found bookmark during search [::Bookmark::]
	end if

	if isSelTextRange(0) then  &apos; only for textRange
		&apos; set the start of search if the search is only inside the block during 1st search
		if FIRSTPASS and (ALTsearchPARAMS.csele = 1) then
			if ALTsearchPARAMS.zpet = 1 then   &apos; for search from the end of block
				oVCURS.collapseToEnd
			else
				oVCURS.collapseToStart
			end if
		end if
	end if

	addToHistory(1,0) &apos; &apos;add to history the F&amp;R expressions

	i = instr(ALTsearchPARAMS.find,&quot;[::BigBlock::]&quot;)
	if (i &gt; 0)and (ALTsearchPARAMS.reg=1) then
		&apos; big block
		&apos; start, open string for the search of big block
		pom = left(ALTsearchPARAMS.find,i-1)
		HLE1() = getFindArray(pom, false) &apos; the array with the search without groups ()
		&apos; final, close string for search of big block
		pom = right(ALTsearchPARAMS.find,len(ALTsearchPARAMS.find)-i-13) &apos; search the end
		HLE2() = getFindArray(pom, false) &apos; the array with the search without groups ()
		HLE() = HLE1()
		HLE(0).cmd = &quot;[::BigBlock::]&quot;
	else
		&apos; normal search - no big block
		pom = ALTsearchPARAMS.find
		if (ALTsearchPARAMS.reg=1) then  &apos; prepare for regexp
			&apos;         pom = replace_(pom,&quot;\\&quot;,&quot;\&quot;)  &apos; substitute some special characters for hexa codes \x005C
			pom = replace_(pom,&quot;\|&quot;,&quot;\x007C&quot;)  &apos; it is not delimiter OR but the character &quot;|&quot;
		end if
		i = instr(pom,&quot;||&quot;)

		if (i &gt; 0)and (ALTsearchPARAMS.reg=1) then &apos; multireplacement
			pom = replace_(pom,&quot;||&quot;,&quot;|&quot;)  &apos; for orientatioanl looked up only with the help of | OR
			HLE1() = getFindArray(pom, false) &apos; without groups - don&apos;t presearch
		else
			HLE1() = getFindArray(pom, true) &apos; the array with the search also with groups () - the array has more records = slower search
		end if
		HLE() = getFindArray(pom, false) &apos; for presearch , WITHOUT possible groups - straight search with groups is very slow
	end if

	FindDo  &apos; the search

	PosunZakrytyText  &apos; if the cursor is hidden below the dialog then move the projection (if there is space)

	if FIRSTPASS then FIRSTPASS = false
end sub


	&apos;button replace
sub BtReplace
	if NOT testViewCursor then exit sub &apos;test if Visible cursor isn&apos;t in Comment etc.
	dim pom, i
	&apos; for linux: the search of yellow comments else the muddles during 1st replacement
	If oSELS.supportsService(&quot;com.sun.star.text.TextRanges&quot;) Then prCURS = oVCURS.text.createTextCursorByRange(oVCURS) &apos; working according to visible

	&apos; the block is really found
	if ALTSlastFOUND&lt;&gt;0 then goto najdiDalsi
	if ALTSlastFOUND&lt;&gt;0 then exit sub  &apos; no found, end

	loadParams(false) &apos; save, actualization of search options
	addToHistory(0,1) &apos; &apos;add to history the F&amp;R expressions
	REPL() = getReplArray(ALTsearchPARAMS.repl) &apos; load the array of replacements

	FO1S = &quot;&quot; :  FO2S = &quot;&quot; : FO3S = &quot;&quot;  &apos; reset of the big-blocks strings

	ERRPROP = 0 &apos; the counter of unsuccessful settings of properties

	TEXTFIELDS = false  &apos; flag for actualization of fields
	HledamDisp(true) &apos; non-accessible buttons and search
	ReplDo  &apos; execute the replacements, prCURS is at the end or at start according to direction
	HledamDisp(false) &apos; accessible buttons and search

	if TEXTFIELDS then update_fields  &apos; if the actualization of fields is needed &apos; actualization of values of text fields in document to show correct values after paste
	redim TMPPOLE() &apos; reset the array used for search the frames, notes, footnote, a text field

	batREPLCOUNT  = batREPLCOUNT + 1  &apos; the counter of the changes of batch processing

	if ERRPROP &gt; 0 then  hlaseni1(16, true, false, MSG(23) &amp; ERRPROP &amp; MSG(15)) &apos; the count of unsuccessful set properties: &apos; style: 16=stop 32=? 48=! 64=info; may suppress; cancel the activities
najdiDalsi:
	BtFindNext
end sub


sub BtReplaceAll
	if NOT testViewCursor then exit sub &apos;test if Visible cursor isn&apos;t in Comment etc.
	dim info, curinit, curs, rest, n, i, j, max, hled, pom, oTmp, oAnch, bin, inFoot, oFoot, mode, oUndoMgr as object, oButtonReplaceAll as object, sUndo$
	sUndo=oDIAL.Model.getByName(&quot;Bt_replall&quot;).Label &apos;label Replace all for Undo manager
	oUndoMgr=ALTsearchDOC.UndoManager
	oUndoMgr.enterUndoContext(sUndo) &apos;set Undo manager
	bin = 0  &apos; set the search of uppercases in substrings
	info = &quot;&quot;  &apos; information box under the Find
	loadParams(false) &apos; save the options of search
	TEXTFIELDS = false &apos; for actualization of fields
	FO1S = &quot;&quot; :  FO2S = &quot;&quot; : FO3S = &quot;&quot;  &apos; reset of the big-blocks strings

	redim TMPPOLE() &apos; reset the array used for search the frames, notes, footnote, a text field
	addToHistory(1,1) &apos; &apos;add to history the F&amp;R expressions

	i = instr(ALTsearchPARAMS.find,&quot;[::BigBlock::]&quot;)
	if (i &gt; 0)and (ALTsearchPARAMS.reg=1) then
		&apos; big block
		&apos; start, open string for the search of big block
		pom = left(ALTsearchPARAMS.find,i-1)
		HLE1() = getFindArray(pom, false) &apos; the array with the search without groups ()
		&apos; final, close string for search of big block
		pom = right(ALTsearchPARAMS.find,len(ALTsearchPARAMS.find)-i-13) &apos; search the end
		HLE2() = getFindArray(pom, false) &apos; the array with the search without groups ()
		HLE() = HLE1()
		HLE(0).cmd = &quot;[::BigBlock::]&quot;
	else
		&apos; normal search - no big block
		&apos;test for multireplace
		pom = ALTsearchPARAMS.find
		if (ALTsearchPARAMS.reg=1) then  &apos; prepare for regexp
			&apos;         pom = replace_(pom,&quot;\\&quot;,&quot;\&quot;)  &apos; substitute some special characters to hexa codes \x005C
			pom = replace_(pom,&quot;\|&quot;,&quot;\x007C&quot;)  &apos; it is not delimiter OR but the character &quot;|&quot;
		end if
		HLE() = getFindArray(pom, false) &apos; for presearch , WITHOUT possible groups - straight search with groups is very slow
		i = instr(pom,&quot;||&quot;)
		if (i &gt; 0)and (ALTsearchPARAMS.reg=1) then &apos; multireplacement with the regexp symbols
			HLE1() = getFindArray(pom, false) &apos; without groups, not important, ones will be loaded once more singly
			&apos;the arrays for individual multisearch
			HLE(0).cmd = &quot;[::MultipleSearch::]&quot;  &apos; the rest isn&apos;t important, it will be processed once again
			ALTsearchMFIND() = ArrayOutOfString_(pom,&quot;||&quot;)  &apos; the array with the individual substrings for search
			&apos; uprava nahrazovaciho retezce
			pom = replace_(ALTsearchPARAMS.repl,&quot;\\&quot;,&quot;\x005C&quot;)  &apos; substitute special characters to hexa codes
			pom = replace_(pom,&quot;\|&quot;,&quot;\x007C&quot;)                 &apos; it is not delimiter OR but the character &quot;|&quot;
			ALTsearchMREPL() = ArrayOutOfString_(pom,&quot;||&quot;)  &apos; array with single strings for replacement
		else
			HLE1() = getFindArray(pom, true) &apos; the array with the search also with groups () - the array has more records = slower search
		end if
	end if

	REPL() = getReplArray(ALTsearchPARAMS.repl) &apos; load the array of replacements
	curinit = false  &apos; refresh the cursors after found with CursorInit(true)
	HledamDisp(true) &apos; not accessible during counting
	ERRPROP = 0 &apos; the counter of unsuccessful settings of properties
	FINDCOUNTER = 1  &apos; general counter for status entries &gt;0 enable the cancel
	REPLCOUNT = 0    &apos; counter of found exchanges
	nCOUNT = 0
	iREPLACE=0 &apos;reset the count of no-replacements (&quot;!&quot; in function ReplDo)

	if ALTsearchPARAMS.reg &lt;&gt; 1 then
		&apos; normal search without regexps, false - without presearch, not needed there aren&apos;t regexps
		if not Zamenuj(false) then goto chyba &apos; the procedure for EXECUTING OF ALL EXCHANGES via find -- replace
		goto konec &apos; vypis vysledku a konec
	else
		&apos; search with regexps
		select case HLE(0).cmd
		case &quot;[::MultipleSearch::]&quot;
			for i=0 to ubound(ALTsearchMFIND())  &apos; search over all search
				HLE() = getFindArray(ALTsearchMFIND(i), false) &apos; for presearch , WITHOUT possible groups - straight search with groups is very slow
				HLE1() = getFindArray(ALTsearchMFIND(i), true) &apos; for presearch, including the groups
				if ubound(ALTsearchMREPL()) &gt;= i then
					REPL() = getReplArray(ALTsearchMREPL(i)) &apos; load the array of replacements
					if not Zamenuj(false) then goto chyba &apos; the procedure for EXECUTING OF ALL EXCHANGES via find -- replace
				end if
			next i

		case &quot;[::Comment::]&quot;
			max = getIndexComment(1,0,&quot;&quot;)
			hled = HLE(0).hled
			&apos; helped array TMPPOLE() with the names of text frames is loaded from getIndexComment()
			if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison

			for i = 0 to Ubound(TMPPOLE())  &apos; for all objects
				&apos; the substring is found or find all
				if (instr(1,TMPPOLE(i).content,hled,bin)&gt;0)or(hled=&quot;&quot;) then
					&apos;ascertain the anchor - to oAnch
					oAnch = TMPPOLE(i).anchor &apos; found object
					&apos;is anchor inside the selection?
					if isInsideOfSelection(oAnch) then  &apos; yes, found, exchange
						prCURS = TMPPOLE(i).anchor &apos; found object
						info = TMPPOLE(i).content  &apos; information box under the Find
						curinit = false &apos; refresh the cursors after found - attention maybe it will cancel the IniBlok for the search in block!!
						redim ALTsearchSKUP(14) &apos; delete the array with groups
						ALTsearchSKUP(11) = info  &apos; text content of note
						pom = TMPPOLE(i).SupportedServiceNames(0)
						ALTsearchSKUP(12) = right(pom,len(pom)-18)  &apos; uno name of note

						nastavSkupiny012(ALTsearchSKUP(11), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found

						nastavVKurzor(prCURS, curinit, info) &apos; set visible cursor to found object
						REPLCOUNT = REPLCOUNT + 1 &apos; counter of exchanges
						ReplDo  &apos; execute the exchanges
					end if
				end if &apos; the substring is found or find all
				if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval
			next i


		case &quot;[::Bookmark::]&quot;
			hled = HLE(0).hled
			&apos; \ = search in the names of bookmarks
			mode = -1  &apos; -1 = search in the text of bookmark; 1 = search at the names of bookmarks; 0 = search any bookmark
			if left(hled,2)= &quot;\\&quot; then
				mode = 1
				hled = rightPast(hled, &quot;\\&quot;)
			end if
			if hled = &quot;&quot; then mode = 0 &apos; find all

			if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison

			TMPPOLE = ALTsearchDOC.Bookmarks
			max = TMPPOLE.count - 1  &apos;  max index of last note

			do while (i &lt;= TMPPOLE.count - 1)  &apos; the index of last note, the count of indexes is changed during the delete of bookmark
				&apos; search in the content of bookmarks?
				if mode=1 then  &apos; search in names
					pom = TMPPOLE(i).Name
				else &apos; search in text of anchor
					pom = TMPPOLE(i).anchor.string  &apos; search in the content of bookmark
				end if

				&apos; the substring is found or find all
				if (instr(1,pom,hled,bin)&gt;0)or(hled=&quot;&quot;) then
					&apos;ascertain the anchor - to oAnch
					oAnch = TMPPOLE(i).anchor &apos; found object
					&apos;is anchor inside the selection?
					if isInsideOfSelection(oAnch) then  &apos; yes, found, exchange
						&apos; the anchor isn&apos;t cursor but textRange =&gt; convert to cursor else bugs
						FOUNDbookmarkNO = i  &apos; save index of processed bookmark
						prCURS = TMPPOLE(i).anchor.text.createTextCursorByRange(TMPPOLE(i).anchor) &apos; .getStart()
						redim ALTsearchSKUP(14) &apos; delete the array with groups
						ALTsearchSKUP(11) = TMPPOLE(i).anchor.String  &apos; the text of bookmark for REPL \o
						ALTsearchSKUP(12) = TMPPOLE(i).getName()  &apos; name to replpar \O

						if mode = 1 then &apos; search in the names of bookmarks
							nastavSkupiny012(ALTsearchSKUP(12), hled)   &apos; set the variables ALTsearchSKUP(0-2); in \b is part before found substring,inv \e is part after found substring, and in &amp; is found substring
						else  &apos; search in the text of bookmark
							nastavSkupiny012(prCURS.String, hled)   &apos; set the variables ALTsearchSKUP(0-2) according the parameter found substring: 1=before found 0=found 2=after found
						end if

						nastavVKurzor(prCURS, false, info) &apos; set visible cursor to found object
						REPLCOUNT = REPLCOUNT + 1 &apos; counter of exchanges
						ReplDo  &apos; execute the exchanges
					end if
				end if &apos; the substring is found or find all

				if FINDCOUNTER &lt; 0 then i = TMPPOLE.count + 100  &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval

				i = i+1
				if (TMPPOLE.count-1)&lt;max then &apos; current count of bookmarks is lesser than original - ReplDo deleted some
					i = i - max + TMPPOLE.count - 1
					if i&lt;0 then i = TMPPOLE.count + 10  &apos; for sure cancel, end
					max = TMPPOLE.count-1  &apos; actualize the maximum
				endif

				if (TMPPOLE.count-1)&gt;max then &apos; current count of bookamrks is greater than original - ReplDo added some
					i = i - max + TMPPOLE.count - 1
					max = TMPPOLE.count-1  &apos; actualize the maximum
				end if
			loop

			FOUNDbookmarkNO = -1 &apos; the index of found bookmark during search [::Bookmark::]

		case &quot;[::Field::]&quot;
			max = getIndexTField(1,0,&quot;&quot;)
			hled = HLE(0).hled
			if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison

			for i = 0 to Ubound(TMPPOLE())  &apos; for all objects
				&apos; the substring is found or find all
				if (instr(1,TMPPOLE(i).anchor.string,hled,bin)&gt;0)or(hled=&quot;&quot;) then
					&apos;ascertain the anchor - to oAnch
					oAnch = TMPPOLE(i).anchor &apos; found object
					&apos;is anchor inside the selection?
					if isInsideOfSelection(oAnch) then  &apos; yes, found, exchange
						prCURS = TMPPOLE(i).anchor &apos; found object
						redim ALTsearchSKUP(14) &apos; delete the array with groups
						ALTsearchSKUP(11) = TMPPOLE(i).anchor.string  &apos; text content of field
						pom = TMPPOLE(i).SupportedServiceNames(0)
						ALTsearchSKUP(12) = right(pom,len(pom)-18)  &apos; uno name of note
						nastavSkupiny012(ALTsearchSKUP(11), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
						nastavVKurzor(prCURS, false, info) &apos; set visible cursor to found object
						REPLCOUNT = REPLCOUNT + 1 &apos; counter of exchanges
						ReplDo  &apos; execute the exchanges
					end if
				end if &apos; the substring is found or find all
				if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval
			next i

		case &quot;[::Reference::]&quot;
			hled = HLE(0).hled
			getSortFields(TMPPOLE(), TMPPOLE1(), &quot;GetReference&quot;, false)  &apos; oad quickly non-sorted references
			mode = -1  &apos; -1 = search in text that is visible (anchor of object); 1 = search in title (in bubble); 0 = find all
			if hled = &quot;\\\\&quot; then &apos; search empty text
				hled = &quot;&quot;
			else
				if left(hled,2)= &quot;\\&quot; then  &apos; search in title
					mode = 1
					hled = rightPast(hled, &quot;\\&quot;)
				else
					if hled = &quot;&quot; then  &apos; find all
						mode = 0
					end if
				end if
			end if

			for i = 0 to Ubound(TMPPOLE())  &apos; for all objects - array of names of frames
				if mode = 1 then  &apos; search in title znacky ?
					pom = TMPPOLE(i).SourceName
				else &apos; search in text of anchor
					pom = TMPPOLE(i).anchor.string
				end if

				&apos; is searched substring HLED included in VST a is potentially inside the block?
				&apos; if pom=0 then the searched substring is found without regard
				if isSubstrInBlock(TMPPOLE(i),pom,hled,mode) then
					prCURS = TMPPOLE(i).anchor &apos; found object
					redim ALTsearchSKUP(14) &apos; delete the array with groups
					ALTsearchSKUP(11) = prCURS.string  &apos; text content of field
					ALTsearchSKUP(12) = prCURS.start.TextField.SourceName  &apos; the name of source mark where to refer
					info = ALTsearchSKUP(12)  &apos; info = uno name of field

					if mode = 1 then &apos; search in name of ref
						nastavSkupiny012(ALTsearchSKUP(12), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
					else  &apos; search in the text of anchor
						nastavSkupiny012(ALTsearchSKUP(11), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
					end if

					nastavVKurzor(prCURS, false, info) &apos; set visible cursor to found object
					REPLCOUNT = REPLCOUNT + 1 &apos; counter of exchanges
					ReplDo  &apos; execute the exchanges
				end if &apos; substring is found
				if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval
			next i

		case &quot;[::Footnote::]&quot;, &quot;[::Endnote::]&quot;
			hled = HLE(0).hled

			&apos; \ = search in text of note
			inFoot = -1  &apos; -1 = search in anchor that is visible (in anchor of object); 1 = search in text of note (in bubble); 0 = find all
			if left(hled,2)= &quot;\\&quot; then
				inFoot = 1
				hled = rightPast(hled, &quot;\\&quot;)
			end if
			if (hled = &quot;&quot;) then inFoot = 0 &apos; find all

			if HLE(0).cmd = &quot;[::Footnote::]&quot; then
				oFoot = ALTsearchDOC.Footnotes
			else
				oFoot = ALTsearchDOC.Endnotes
			end if

			max = oFoot.count - 1  &apos;  max index of last note
			&apos; hide the references to notes to TMPPOLE - during delete would decreased the count of notes and then bug of index
			redim TMPPOLE()
			for i = 0 to max
				redim preserve TMPPOLE(i)
				TMPPOLE(i)= oFoot(i)  &apos; pole
			next i

			if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison

			for i = max to 0 step -1  &apos; backward, else during the ommiting of note will come to renumbering of next ones and undesirabled recursive deleting
				&apos; search in content of note or in text of anchor
				if inFoot=1 then
					pom = TMPPOLE(i).string
				else &apos; search in text of anchor
					pom = TMPPOLE(i).anchor.string
				end if

				&apos; is searched substring HLED included in VST a is potentially inside the block?
				&apos; if inFoot=0 is searched the found substring without regard
				if isSubstrInBlock(TMPPOLE(i),pom,hled,inFoot) then
					&apos; at replace is worked only with anchor, never with texts, but it is possible to find according the texts
					prCURS = TMPPOLE(i).anchor &apos; found anchor
					redim ALTsearchSKUP(14) &apos; delete the array with groups
					ALTsearchSKUP(11) = TMPPOLE(i).string  &apos; text content of note
					ALTsearchSKUP(12) = TMPPOLE(i).anchor.string  &apos; text of anchor
					info = &quot;[&quot; &amp; ALTsearchSKUP(12) &amp; &quot;]   &quot; &amp; ALTsearchSKUP(11)

					if inFoot = 1 then &apos; search in the text of note
						nastavSkupiny012(ALTsearchSKUP(11), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
					else  &apos; search in the text of anchor
						nastavSkupiny012(ALTsearchSKUP(12), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
					end if

					nastavVKurzor(prCURS, false, info) &apos; set visible cursor to found object
					REPLCOUNT = REPLCOUNT + 1 &apos; counter of exchanges
					ReplDo  &apos; execute the exchanges
				end if &apos; execute the found
				if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval
			next i

		case &quot;[::ReferenceMark::]&quot;
			hled = HLE(0).hled
			inFoot = -1  &apos; -1 = search in text that is visible (anchor of object); 1 = hledat ve Názvu (v bublině); 0 = find all
			if hled = &quot;\\\\&quot; then &apos; search empty text
				hled = &quot;&quot;
			else
				if left(hled,2)= &quot;\\&quot; then  &apos; search in title
					inFoot = 1
					hled = rightPast(hled, &quot;\\&quot;)
				else
					if hled = &quot;&quot; then  &apos; find all
						inFoot = 0
					end if
				end if
			end if

			oFoot = ALTsearchDOC.ReferenceMarks
			max = oFoot.count - 1  &apos;  max index of last note
			&apos; hide the references to notes to TMPPOLE - the count of marks would be decreased during delete and then the bug will occur
			redim TMPPOLE()
			for i = 0 to max
				redim preserve TMPPOLE(i)
				TMPPOLE(i)= oFoot(i)  &apos; pole
			next i

			if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison

			&apos; serch if it satisfies the conditions
			for i = 0 to max
				&apos; find in title of mark
				if inFoot = 1 then
					pom = TMPPOLE(i).Name
				else &apos; search in text
					pom = TMPPOLE(i).anchor.string
				end if

				&apos; is searched substring HLED included in VST a is potentially inside the block?
				&apos; if inFoot=0 is searched the found substring without regard
				if isSubstrInBlock(oFoot(i),pom,hled,inFoot) then
					if TMPPOLE(i).anchor.string = &quot;&quot; then &apos; select to possible deleting
						prCURS = TMPPOLE(i).anchor.text.createTextCursorByRange(TMPPOLE(i).anchor.getStart())
						prCURS.goRight(1,true)
					else
						prCURS = TMPPOLE(i).anchor
					end if

					redim ALTsearchSKUP(14) &apos; delete the array with groups
					ALTsearchSKUP(11) = prCURS.string &apos; text content
					ALTsearchSKUP(12) = TMPPOLE(i).Name  &apos; name of mark
					info = ALTsearchSKUP(12)

					if inFoot = 1 then &apos; search in title
						nastavSkupiny012(ALTsearchSKUP(12), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
					else  &apos; search was in text
						nastavSkupiny012(ALTsearchSKUP(11), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
					end if
					nastavVKurzor(prCURS, false, info) &apos; set visible cursor to found object
					REPLCOUNT = REPLCOUNT + 1 &apos; counter of exchanges
					ReplDo  &apos; execute the exchanges
				end if &apos; nalezen text

				if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval
			next i

		case &quot;[::TextFrame::]&quot;
			&apos; load helped array with the names of objects (frames)
			TMPPOLE()= ALTsearchDOC.getTextFrames.ElementNames
			if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison

			if ALTsearchPARAMS.zpet = 0 then  
				ReverseArray(TMPPOLE) &apos;fix: bug #59  set order of textframes https://github.com/gitxpy/libreoffice-alt-search/issues/59
			end If

			for i = 0 to Ubound(TMPPOLE())  &apos; for all objects - array of names of frames

				&apos; the substring is found or find all
				if (instr(1,TMPPOLE(i),HLE(0).hled,bin)&gt;0)or(HLE(0).hled=&quot;&quot;) then

					&apos;ascertain the anchor - to oAnch
					oTmp = ALTsearchDOC.getTextFrames.getByName(TMPPOLE(i)) &apos; object of frame
					oAnch = getAnchorOfFramePicture(oTmp)

					&apos;is anchor inside the selection?
					if isInsideOfSelection(oAnch) then &apos; found, zamenit
						prCURS = oTmp
						info = prCURS.Name  &apos; information box under the Find
						curinit = false &apos; refresh the cursors after found with CursorInit(true)
						redim ALTsearchSKUP(14) &apos; delete the array with groups
						ALTsearchSKUP(11) = prCURS.string  &apos; text content of frame
						ALTsearchSKUP(12) = prCURS.Name  &apos; name

						nastavSkupiny012(ALTsearchSKUP(12), HLE(0).hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found

						nastavVKurzor(prCURS, curinit, info) &apos; set visible cursor to found object
						REPLCOUNT = REPLCOUNT + 1 &apos; counter of exchanges
						ReplDo  &apos; execute the exchanges
					end if
				end if &apos; the substring is found or find all
				if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval
			next i

		case &quot;[::TextTable::]&quot;
			&apos; load helped array with the names of objects (tables)
			TMPPOLE()= ALTsearchDOC.getTextTables.ElementNames
			if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison

			for i = 0 to Ubound(TMPPOLE())  &apos; for all objects - array with the names of tables
				&apos; the substring is found or find all
				if (instr(1,TMPPOLE(i),HLE(0).hled,bin)&gt;0)or(HLE(0).hled=&quot;&quot;) then
					&apos;ascertain the anchor - to oAnch
					oTmp = ALTsearchDOC.getTextTables.getByName(TMPPOLE(i)) &apos; object of frame
					oAnch = getTextRangeOfTable(oTmp)
					&apos;is anchor inside the selection?
					if isInsideOfSelection(oAnch) then &apos; yes, found, replace
						pom=oTmp.CellNames(0) &apos; the name of 1st cell of table
						oVCURS.gotoRange(oTmp.getCellByName(pom).getStart(),false) &apos; visible cursor to the start of 1st cell
						selectWholeTable(oVCURS)
						prCURS = oDOCcontrol.selection &apos;getViewCursor()  - for definitive selection
						info = oTmp.getName()  &apos; information box under the Find
						curinit = false &apos; refresh the cursors after found - attention probably it will cancel the iniBlok for the search in block!!
						redim ALTsearchSKUP(14) &apos; delete the array with groups
						if REPL(0).textobs=1 then
							ALTsearchSKUP(11) = Table2Text(oTmp)  &apos; if the conversion of text content of table is needed
						end if
						ALTsearchSKUP(12) = info  &apos; name
						nastavSkupiny012(ALTsearchSKUP(12), HLE(0).hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
						nastavVKurzor(prCURS, curinit, info) &apos; set visible cursor to found object
						REPLCOUNT = REPLCOUNT + 1 &apos; counter of exchanges
						ReplDo  &apos; execute the exchanges
					end if
				end if &apos; the substring is found or find all
				if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval
			next i

		case &quot;[::Picture::]&quot;
			&apos; load helped array with the names of objects (pictures)
			dim oTFr, names
			oTFr = ALTsearchDOC.GraphicObjects
			names = oTFr.ElementNames
			if ALTsearchPARAMS.kcase=0 then bin = 1  &apos; bin=1 instr(,,bin) ignore lower/uppercases; BIN=0 binary comparison
			dim alttext
			alttext = false
			rest = HLE(0).hled
			if left(rest,2) = &quot;\\&quot; then  &apos; find in alternative text
				for i = 0 to ubound(names)
					&apos; replace the array of names   Alt. texts
					names(i) = oTFr.getByName(names(i)).Title
				next i
				rest = rightpast(rest,&quot;\\&quot;)
				Alttext = true
			end if

			for i = 0 to Ubound(names())  &apos; for all objects - array with the names of pictures or Alt. texts
				&apos; the substring is found or find all
				if   ( (instr(1,names(i), rest,bin)&gt;0) and (rest&lt;&gt;&quot;&quot;) )   or ( (rest=&quot;&quot;)and(not Alttext) )      or ( Alttext and (names(i)= &quot;&quot;) and (rest= &quot;&quot;)) then  &apos;(instr(1,TMPPOLE(i),HLE(0).hled,bin)&gt;0)or(HLE(0).hled=&quot;&quot;)
					&apos;ascertain the anchor - to oAnch
					oTmp = ALTsearchDOC.GraphicObjects.getByIndex(i) &apos; object of picture
					oAnch = getAnchorOfFramePicture(oTmp)
					&apos;is anchor inside the selection?
					if isInsideOfSelection(oAnch) then  &apos; yes, found, count it
						prCURS = oTmp
						curinit = false &apos; refresh the cursors after found with CursorInit(true)
						redim ALTsearchSKUP(14) &apos; delete the array with groups
						ALTsearchSKUP(11) = prCURS.Title  &apos; text content of frame - alternative text
						ALTsearchSKUP(12) = prCURS.getName()  &apos; name
						info = ALTsearchSKUP(12)  &amp;  chr(13)
						if ALTsearchSKUP(11)&lt;&gt;&quot;&quot; then info = info  &amp;  &quot;&gt; &quot;  &amp;  ALTsearchSKUP(11) &apos; information box under the Find

						&apos; fulfilment of groups for replacement
						pom = HLE(0).hled
						if left(pom,2) = &quot;\\&quot; then  &apos; searched in Alternative text (Title)
							pom = rightpast(pom,&quot;\\&quot;)  &apos; cancel the slash
							nastavSkupiny012(ALTsearchSKUP(11), pom)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
						else &apos; searched in name
							nastavSkupiny012(ALTsearchSKUP(12), pom)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
						end if

						nastavVKurzor(prCURS, curinit, info) &apos; set visible cursor to found object
						REPLCOUNT = REPLCOUNT + 1 &apos; counter of exchanges
						ReplDo  &apos; execute the exchanges
					end if
				end if &apos; the substring is found or find all
				if FINDCOUNTER &lt; 0 then exit for &apos; cancel, end
				StatusInfo(i) &apos; show statusinfo after set interval
			next i

		case &quot;[::BigBlock::]&quot;  &apos; bigBlock
			resetPrCurs &apos; set prCURS in the dependence of selected block and choice of block

hledejdal:
			j = FindNextInBlock(HLE1(), prCURS, ALTSiniSEL, false, false)
			if j &lt;&gt; 0 then goto vratcurs
			FO1 = nastavKurzor(prCURS)  &apos; remember the start
			FO2 = FO1.text.createTextCursor()  &apos;nastavKurzor(prCURS)  &apos; same region for FO2

			j = FindNextInBlock(HLE2(), prCURS, ALTSiniSEL, false, false)
			if j &lt;&gt; 0 then goto vratcurs &apos; no found
			FO3 = nastavKurzor(prCURS)  &apos; save result to FO3

			if nastavRozsah(FO2, FO1.getEnd(),FO3.getStart()) &lt;&gt; 0 then
				prCURS = nastavKurzor(FO1) &apos; in the case of bug of region search farther behind the FO1
				goto hledejdal
			end if

			if ALTsearchPARAMS.zpet = 1 then  &apos; inverse bounds for backward search
				if nastavRozsah(prCURS, FO1.getEnd(),FO3.getStart()) &lt;&gt; 0 then
					prCURS = nastavKurzor(FO1) &apos; in the case of bug of region search farther behind the FO1
					goto hledejdal
				end if
			else
				if nastavRozsah(prCURS, FO1.getStart(),FO3.getEnd()) &lt;&gt; 0 then
					prCURS = nastavKurzor(FO1) &apos; in the case of bug of region search farther behind the FO1
					goto hledejdal
				end if
			end if

			&apos; found, ulozit retezce
			FO1S = FO1.string
			FO2S = FO2.string
			FO3S = FO3.string

			ReplDo  &apos; zamenit nalezene
			REPLCOUNT = REPLCOUNT + 1 &apos; counter of exchanges
			nCOUNT = nCOUNT + 1
			goto hledejDal
vratcurs:
			goto konec
		case else   &apos; standard regexp
			&apos; normal regexp, with presearch
			if not Zamenuj(true) then goto chyba   &apos; the procedure for EXECUTING OF ALL EXCHANGES via find -- replace

		end select
	end if  &apos; search with regexps
konec:

	if TEXTFIELDS then update_fields  &apos; if it need to actualize the field &apos; actualization of values of text fields in document to show correct values after paste
	nastavVKurzor(ALTSiniSEL, false, &quot;&quot; ) &apos; refresh original selection
	HledamDisp(false) &apos; accessible search
	batREPLCOUNT  = batREPLCOUNT + REPLCOUNT  &apos; the counter of the changes of batch processing
	if oUndoMgr.getCurrentUndoActionTitle=sUndo then oUndoMgr.leaveUndoContext()
	if ERRPROP &gt; 0 then  hlaseni1(16, true, false, MSG(23) &amp; ERRPROP &amp; MSG(15)) &apos; the count of unsuccessful set properties: &apos; style: 16=stop 32=? 48=! 64=info; may suppress; cancel the activities
	if iREPLACE&lt;REPLCOUNT  AND ERRPROP&lt;&gt;REPLCOUNT then hlaseni(8)  &apos;ok statistics: searched expression ... was found ...
	redim TMPPOLE() &apos; reset the array used for search the frames, notes, footnote, a text field
	REPLCOUNT = 0
	exit sub
chyba:
	if oUndoMgr.getCurrentUndoActionTitle=sUndo then oUndoMgr.leaveUndoContext()
	HledamDisp(false) &apos; accessible search
end sub


Function BubbleSortList_(ByVal SortList()) &apos;,optional sort2ndValue as Boolean)
	&apos;This function bubble sorts an array of maximum 2 dimensions.
	&apos;The default sorting order is the first dimension
	&apos;Only if sort2ndValue is True the second dimension is the relevant for the sorting order
	Dim s as Integer
	Dim t as Integer
	Dim i as Integer
	Dim k as Integer
	Dim dimensions as Integer
	Dim sortvalue as Integer
	Dim DisplayDummy
	dimensions = 1

	i = Ubound(SortList(),1)
	sortvalue = 0

	For s = 1 to i - 1
		For t = 0 to i-s
			Select Case dimensions
			Case 1
				If SortList(t) &gt; SortList(t+1) Then
					DisplayDummy = SortList(t)
					SortList(t) = SortList(t+1)
					SortList(t+1) = DisplayDummy
				End If
			Case 2
				If SortList(t,sortvalue) &gt; SortList(t+1,sortvalue) Then
					For k = 0 to UBound(SortList(),2)
						DisplayDummy = SortList(t,k)
						SortList(t,k) = SortList(t+1,k)
						SortList(t+1,k) = DisplayDummy
					Next k
				End If
			End Select
		Next t
	Next s
	BubbleSortList_ = SortList()
End Function


sub CursorInit(vynutit as boolean) &apos; initialization of positions of cursor and block
	if (FINDCOUNTER &gt;= 0)and not vynutit then  exit sub &apos; not actualize if the search
	if NOINIT then exit sub  &apos; hard ban of initialization
	if NOT testViewCursor then exit sub &apos;test if Visible cursor isn&apos;t in Comment etc.
	FIRSTPASS = true

	on error goto problem
	&apos;beep &apos; debug
	vypisFoundInfo(&quot;&quot;) &apos; delete information array

	oDOCcontrol = ALTsearchDOC.getCurrentController()
	ALTsearchDOCCONTROL = oDOCcontrol
	oSELS = oDOCcontrol.getSelection()

	INITimplNAME = oSELS.ImplementationName

	oVCURS = oDOCcontrol.getViewCursor()

	If not oSELS.supportsService(&quot;com.sun.star.text.TextRanges&quot;) Then exit sub  &apos; goto problem

	&apos; uschovat pro případ chyby regionu
	ALTSiniSEL = oVCURS.text.createTextCursor() &apos; new cursor according to current area
	ALTSiniSEL.gotoRange(oVCURS.getStart,false)
	ALTSiniSEL.gotoRange(oVCURS.getEnd,true)
	FO1 = ALTsearchDOC.text.createTextCursor()
	FO2 = ALTsearchDOC.text.createTextCursor()
	FO3 = ALTsearchDOC.text.createTextCursor()
	prCURS = oVCURS.text.createTextCursor()
	prCURS.gotoRange(oVCURS.getStart,false)

	&apos; in order that the BtReplace has a certainty that there is correct choice of found object and
	&apos; there was preceded the call of BtFindNext, there is set at every return to dialog the code of result
	&apos; found=10. But probably it causes that only at click from dialog to frame of window
	&apos; and back to dialog, at previously found result of search, then at next
	&apos; use of BtReplace doesn&apos;t replace currently selected block,  but there is found next occurence
	&apos; Inbuilt OOo search behaves that there is selected some block
	&apos; then one is considered as correct previous search and is rewritten with replaced string.
	&apos;(this sentences were inapprehensible already in Czech for me)
	if oVCURS.IsCollapsed then ALTSlastFOUND = 10  &apos; the code of result of last search to no-found

	if ALTsearchDIALOG_end then exit sub &apos; if the dialog isn&apos;t then end

	INITerror = 0  &apos; counter of repeat bugs
	exit sub
problem:
	&apos; style: 16=stop 32=? 48=! 64=info; may suppress; cancel the activities
	hlaseni1(48, false, true, &quot;CursorInit:  Unsupported selection. &quot;) &apos;&quot;This selection not supported. &quot;

	INITerror = INITerror + 1 &apos; counter of repeat bugs of area, after 3 end the dialog
	if INITerror &gt; 2 then KonecTm &apos; end the dialog
end sub


	&apos; set visible cursor according to range
sub dbgVcursor(zac,kon, msg1)
	on error goto chyba
	&apos; set visible cursor according to unvisible
	oVCURS.gotoRange(zac,false)
	oVCURS.gotoRange(kon,true)
	msgbox msg1
	exit sub
chyba:
	msgbox &quot;dbgVcursor:  Asi chyba regionu, kurzoru.&quot;
end sub


	&apos; show the array with groups
sub dbgVypisSkupiny
	dim i , ms
	ms = &quot;&quot;
	for i = 0 to ubound(ALTsearchSKUP())
		ms = ms &amp; i &amp; &quot;:  &gt;&quot; &amp; ALTsearchSKUP(i) &amp; &quot;&lt; &quot; &amp; chr(10)
	next i
	msgbox ms
end sub


sub evDialogKeypress(oEvt)
	beep
end sub


	&apos; the procedure searches according to set global parameters
	&apos; hle0(), HLE(), ALTSiniSEL,
	&apos; in ALTSlastFOUND stays the code of result of last 0=found
sub FindDo
	dim curs
	dim info, curinit
	dim max,  bin, i, j, oTmp, pom, hled, rest, mode
	
	ALTsearchPARAMS.find=removeZero( ALTsearchPARAMS.find ) &apos; bug #74
	
	if ERRcontrol then on error goto nejakaChyba
	curinit = false &apos; refresh the cursors after found with CursorInit(true)
	HledamDisp(true) &apos; not accessible during search
	FINDCOUNTER = 1  &apos; general counter for status entries; minimally 1 for the possibility of interruption
	&apos; reset the parts of bigblock
	FO1 = FO0 :  FO2 = FO0 : FO3 = FO0
	FO1S = &quot;&quot; :  FO2S = &quot;&quot; : FO3S = &quot;&quot;
	FOUNDcaseTYPE = 0
hledejZacKon:
	if ALTsearchPARAMS.reg &lt;&gt; 1 then &apos; normal search without regexps
		if not isSelTextRange(1) then goto konec  &apos; non-text selection would do a bug
		prCURS = oVCURS.text.createTextCursorByRange(oVCURS) &apos; working according to visible
		ALTSlastFOUND = FindNextInBlock(HLE(), prCURS, ALTSiniSEL, false, false) &apos; presearch without groups
coDelat:
		select case ALTSlastFOUND
		case 0  &apos; found - without report
			&apos; if the hyperlink was searched then write info url
			for i = 0 to ubound(SRCHATR())
				if SRCHATR(i).Name = &quot;HyperLinkURL&quot; then info = &quot;\u =  &quot;  &amp;  prCURS.HyperLinkURL
			next i

			&apos; if the mark of register was searched then write the name of label
			if (HLE(0).atr = 10) or (HLE(0).atr = 9) then
				info = &quot;Index label \O =  &quot;  &amp;  ALTsearchSKUP(12)
			end if

			&apos; the style was searched so write the name
			if (HLE(0).atr &gt;= 3) and (HLE(0).atr &lt;= 8) then
				info = &quot;\O =  &quot;  &amp;  ALTsearchSKUP(12)
			end if

			nastavVKurzor(prCURS, curinit, info )  &apos;set visible cursor according to work one
			FOUNDcaseTYPE = getCapitalType(prCURS)

		case -1,1  &apos;
			hlaseni(0) &apos; search inside the block finished
			nastavVKurzor(prCURS, curinit, info )
			FIRSTPASS = true  &apos; next search from start of block again
		case -2
			if 6 &lt;&gt; hlaseni(1) then goto konec &apos;Start of document. Continue from end?
			nastavVKurzor(prCURS, curinit, info )
			goto hledejZacKon &apos; BtFindNext
		case 2
			if 6 &lt;&gt; hlaseni(2) then goto konec &apos;End of document. Continue from start?
			nastavVKurzor(prCURS, curinit, info )
			goto hledejZacKon &apos; BtFindNext
		case 4
			hlaseni(4)
		end select

	else  &apos; search with regexps
		select case HLE(0).cmd
		case &quot;[::Comment::]&quot;
			hled = HLE(0).hled
			ALTSlastFOUND = getNextComment(hled, prCURS, ALTSiniSEL)
			info = &quot;&quot;  &apos; info box under &quot;Find&quot;
			redim ALTsearchSKUP(14) &apos; delete the array with groups
			if ALTSlastFOUND = 0 then
				info = prCURS.TextField.content  &apos; text content of note
				ALTsearchSKUP(11) = prCURS.TextField.content  &apos; text content of note
				pom = prCURS.TextField.SupportedServiceNames(0)
				ALTsearchSKUP(12) = right(pom,len(pom)-18)  &apos; uno name of note
				nastavSkupiny012(ALTsearchSKUP(11), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
			end if
			goto coDelat

		case &quot;[::Field::]&quot;
			hled = HLE(0).hled
			ALTSlastFOUND = getNextField(hled, prCURS, ALTSiniSEL)
			info = &quot;&quot;  &apos; info box under &quot;Find&quot;
			redim ALTsearchSKUP(14) &apos; delete the array with groups
			if ALTSlastFOUND = 0 then
				ALTsearchSKUP(11) = prCURS.string  &apos; text content of field
				pom = prCURS.TextField.SupportedServiceNames(0)
				ALTsearchSKUP(12) = right(pom,len(pom)-18)  &apos; uno name of field
				info = ALTsearchSKUP(12)  &apos; info = uno name of field
				nastavSkupiny012(ALTsearchSKUP(11), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
			end if
			goto coDelat

		case &quot;[::Bookmark::]&quot;
			hled = HLE(0).hled
			ALTSlastFOUND = getNextBookmark(hled, prCURS, ALTSiniSEL, mode) &apos; there is object of bookmark in prCURS, no text
			info = &quot;&quot;  &apos; info box under &quot;Find&quot;
			if left(hled,1)= &quot;\\&quot; then  hled = rightpast(hled, &quot;\\&quot;)  &apos; delete the slashes

			redim ALTsearchSKUP(14) &apos; delete the array with groups
			if ALTSlastFOUND = 0 then
				ALTsearchSKUP(11) = prCURS.anchor.String  &apos; text of bookmark
				ALTsearchSKUP(12) = prCURS.getName()  &apos; name
				info = ALTsearchSKUP(12)  &amp;  chr(13)
				if ALTsearchSKUP(11)&lt;&gt;&quot;&quot; then info = info  &amp;  &quot;&quot;  &amp;  ALTsearchSKUP(11) &apos; information box under the Find

				prCURS = prCURS.Anchor  &apos; set cursor on anchor, to the text according to anchor

				if mode = 1 then &apos; search in the names of bookmarks
					nastavSkupiny012(ALTsearchSKUP(12), hled)

				else  &apos; search in the text of bookmark
					nastavSkupiny012(prCURS.String, hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found

				end if
			end if
			goto coDelat

		case &quot;[::Reference::]&quot;
			hled = HLE(0).hled
			ALTSlastFOUND = getNextReference(hled, prCURS, ALTSiniSEL,mode)
			info = &quot;&quot;  &apos; info box under &quot;Find&quot;
			redim ALTsearchSKUP(14) &apos; delete the array with groups
			if ALTSlastFOUND = 0 then
				ALTsearchSKUP(11) = prCURS.string  &apos; text content of field
				ALTsearchSKUP(12) = prCURS.start.TextField.SourceName  &apos; the name of source mark where to refer
				info = ALTsearchSKUP(12)  &apos; info = uno name of field

				if mode = 1 then &apos; search in name of ref
					nastavSkupiny012(ALTsearchSKUP(12), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
				else  &apos; search in the text of anchor
					nastavSkupiny012(ALTsearchSKUP(11), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
				end if
			end if
			goto coDelat

			&apos; debug - experimental
			redim TMPPOLE() : redim TMPPOLE1()
			max  = &quot;GetReference&quot; &apos; All GetReference Annotation
			getSortFields(TMPPOLE(), TMPPOLE1(), max, true)  &apos;
			pom = max &amp; &quot; - loaded elements:  &quot; &amp; (ubound(TMPPOLE1())  +  1)  &amp; chr(10) &amp; chr(10)

			for i = 0 to ubound(TMPPOLE1())
				pom = pom  &amp;  &quot;[&quot; &amp; TMPPOLE1(i) &amp; &quot;]  &quot;
			next i

			msgbox pom
			goto konec

		case &quot;[::Footnote::]&quot;
			hled = HLE(0).hled
			ALTSlastFOUND = getNextFootnote(hled, prCURS, ALTSiniSEL,&quot;Foot&quot;, mode)
			info = &quot;&quot;  &apos; info box under &quot;Find&quot;
			&apos;   curinit = true &apos; refresh the cursors after found with CursorInit(true)
			redim ALTsearchSKUP(14) &apos; delete the array with groups
			if ALTSlastFOUND = 0 then
				ALTsearchSKUP(11) = prCURS.footnote.string  &apos; text content of note
				ALTsearchSKUP(12) = prCURS.footnote.anchor.string  &apos; name - text of anchor
				&apos; info box under &quot;Find&quot;
				info = &quot;[&quot; &amp; ALTsearchSKUP(12) &amp; &quot;]   &quot; &amp; ALTsearchSKUP(11)

				if mode = 1 then &apos; search in the text of note
					nastavSkupiny012(ALTsearchSKUP(11), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
				else  &apos; search in the text of anchor
					nastavSkupiny012(ALTsearchSKUP(12), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
				end if
			end if
			goto coDelat

		case &quot;[::Endnote::]&quot;
			hled = HLE(0).hled
			ALTSlastFOUND = getNextFootnote(hled, prCURS, ALTSiniSEL,&quot;Endn&quot;, mode)
			&apos;        curinit = true &apos; refresh the cursors after found with CursorInit(true)
			info = &quot;&quot;  &apos; info box under &quot;Find&quot;
			redim ALTsearchSKUP(14) &apos; delete the array with groups
			if ALTSlastFOUND = 0 then
				ALTsearchSKUP(11) = prCURS.endnote.string  &apos; text content of note
				ALTsearchSKUP(12) = prCURS.endnote.anchor.string &apos;  textovy obsah kotvy
				&apos; info box under &quot;Find&quot;
				info = &quot;[&quot; &amp; ALTsearchSKUP(12) &amp; &quot;]   &quot; &amp; ALTsearchSKUP(11)

				if mode = 1 then &apos; search in the text of note
					nastavSkupiny012(ALTsearchSKUP(11), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
				else  &apos; search in the text of anchor
					nastavSkupiny012(ALTsearchSKUP(12), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
				end if
			end if
			goto coDelat

		case &quot;[::ReferenceMark::]&quot;
			hled = HLE(0).hled
			ALTSlastFOUND = getNextReferenceMark(hled, prCURS, ALTSiniSEL, mode)
			info = &quot;&quot;  &apos; info box under &quot;Find&quot;

			redim ALTsearchSKUP(14) &apos; delete the array with groups
			if ALTSlastFOUND = 0 then
				ALTsearchSKUP(11) = prCURS.string  &apos; text content of note
				ALTsearchSKUP(12) = prCURS.Start.ReferenceMark.Name  &apos; name - marks
				info = ALTsearchSKUP(12)

				&apos; edit hled for the settings of groups
				if left(hled,2)= &quot;\\&quot; then  hled = rightPast(hled, &quot;\\&quot;)  &apos; delete first 2 slashes at start
				if left(hled,2)= &quot;\\&quot; then  hled = rightPast(hled, &quot;\\&quot;)  &apos; delete second 2 slashes at start

				if mode = 1 then &apos; search in title
					nastavSkupiny012(ALTsearchSKUP(12), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
				else  &apos; search was in text
					nastavSkupiny012(ALTsearchSKUP(11), hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
				end if
			end if
			goto coDelat

		case &quot;[::TextTable::]&quot;
			max = getIndexTextTable(1,0,&quot;&quot;)
			i =  getIndexTextTable(0,0,&quot;&quot;)
opakTTable:
			if HLE(0).hled = &quot;&quot; then  &apos; go to next frame
				if not vyhodnotHledani(i,max) then goto konec  &apos; set also on next/previous object
			else &apos; vyhledat
				i =  getIndexTextTable(2,i,HLE(0).hled)  &apos; found substring
				if (i&lt;0) or (i&gt;max) then &apos; substring not found
					if not vyhodnotHledani(i,max) then goto konec  &apos; set also on next/previous object
					if i=0 then i = -1      &apos; next search is from start
					if i=max then i = max+1  &apos; next search is from end
					goto opakTTable
				end if
			end if

			oTmp = ALTsearchDOC.getTextTables.getbyIndex(i) &apos; object of table
			pom=oTmp.CellNames(0) &apos; the name of 1st cell of table
			oDOCcontrol.select(oTmp.getCellByName(pom).getStart())
			oVCURS = oDOCcontrol.getViewCursor()
			selectWholeTable(oVCURS)
			prCURS = oDOCcontrol.selection &apos;getViewCursor()  - for definitive selection
			info = oTmp.getName()  &apos; information box under the Find
			curinit = true &apos; refresh the cursors after found - attention probably it will cancel the iniBlok for the search in block!!
			ALTSlastFOUND = 0  &apos;flag of finding

			redim ALTsearchSKUP(14) &apos; delete the array with groups
			&apos; merge single cells to one string separated by tabs and Enters
			ALTsearchSKUP(11) = Table2Text(oTmp)  &apos; text content of table
			ALTsearchSKUP(12) = info  &apos; name of table
			nastavSkupiny012(ALTsearchSKUP(12), HLE(0).hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
			goto coDelat

		case &quot;[::TextFrame::]&quot;
			max = getIndexTextFrame(1,0,&quot;&quot;)
			i =  getIndexTextFrame(0,0,&quot;&quot;)
opaktextframe:
			if HLE(0).hled = &quot;&quot; then  &apos; go to next frame
				if not vyhodnotHledani(i,max) then goto konec  &apos; set also on next/previous object
			else &apos; vyhledat
				i =  getIndexTextFrame(2,i,HLE(0).hled)  &apos; found substring
				if (i&lt;0) or (i&gt;max) then &apos; substring not found
					if not vyhodnotHledani(i,max) then goto konec  &apos; set also on next/previous object
					if i=0 then i = -1      &apos; next search is from start
					if i=max then i = max+1  &apos; next search is from end
					goto opaktextframe
				end if
			end if

			prCURS = ALTsearchDOC.getTextFrames.getbyIndex(i) &apos; found object
			info = prCURS.Name  &apos; information box under the Find
			curinit = true &apos; refresh the cursors after found with CursorInit(true)
			ALTSlastFOUND = 0  &apos;flag of finding
			redim ALTsearchSKUP(14) &apos; delete the array with groups
			ALTsearchSKUP(11) = prCURS.string  &apos; text content of frame
			ALTsearchSKUP(12) = info  &apos; name

			nastavSkupiny012(ALTsearchSKUP(12), HLE(0).hled)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found

			goto coDelat

		case &quot;[::Picture::]&quot;
			max = getIndexPicture(1,0,&quot;&quot;)
			i =  getIndexPicture(0,0,&quot;&quot;)
opakPicture:
			if HLE(0).hled = &quot;&quot; then  &apos; go to next frame
				if not vyhodnotHledani(i,max) then goto konec  &apos; set also on next/previous object
			else &apos; vyhledat
				i =  getIndexPicture(2,i,HLE(0).hled)  &apos; found substring
				if (i&lt;0) or (i&gt;max) then &apos; substring not found
					if not vyhodnotHledani(i,max) then goto konec  &apos; set also on next/previous object
					if i=0 then i = -1      &apos; next search is from start
					if i=max then i = max+1  &apos; next search is from end
					goto opakPicture
				end if
			end if

			prCURS = ALTsearchDOC.GraphicObjects.getbyIndex(i) &apos; found object

			curinit = true &apos; refresh the cursors after found with CursorInit(true)
			ALTSlastFOUND = 0  &apos;
			redim ALTsearchSKUP(14) &apos; delete the array with groups

			ALTsearchSKUP(11) = prCURS.Title  &apos; text content of frame - cely alternativní text
			ALTsearchSKUP(12) = prCURS.getName()  &apos; name
			info = ALTsearchSKUP(12)  &amp;  chr(13)
			if ALTsearchSKUP(11)&lt;&gt;&quot;&quot; then info = info  &amp;  &quot;&gt; &quot;  &amp;  ALTsearchSKUP(11) &apos; information box under the Find

			&apos; fulfilment of groups for replacement
			pom = HLE(0).hled
			if left(pom,2) = &quot;\\&quot; then  &apos; searched in v Alternative text (Title)
				pom = rightpast(pom,&quot;\\&quot;)  &apos; cancel the slash
				nastavSkupiny012(ALTsearchSKUP(11), pom)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
			else &apos; searched in name
				nastavSkupiny012(ALTsearchSKUP(12), pom)   &apos; set the variables ALTsearchSKUP(0-2) according the find-substring parameter: 1=before found; 0=found;2=after found
			end if

			goto coDelat

		case &quot;[::BigBlock::]&quot;  &apos; bigBlock
			prCURS = nastavKurzor(oVCURS)  &apos; working according to visible
hledejdal:
			j = FindNextInBlock(HLE1(), prCURS, ALTSiniSEL, false, false)
			if j &lt;&gt; 0 then goto vratcurs
			FO1 = nastavKurzor(prCURS)  &apos; remember the start
			FO2 = FO1.text.createTextCursor()  &apos;nastavKurzor(prCURS)  &apos; same region for FO2

			j = FindNextInBlock(HLE2(), prCURS, ALTSiniSEL, false, false)
			if j &lt;&gt; 0 then goto vratcurs &apos; no found
			FO3 = nastavKurzor(prCURS)  &apos; save result to FO3

			if nastavRozsah(FO2, FO1.getEnd(),FO3.getStart()) &lt;&gt; 0 then
				prCURS = nastavKurzor(FO1) &apos; in the case of bug of region search farther behind the FO1
				goto hledejdal
			end if

			if ALTsearchPARAMS.zpet = 1 then  &apos; inverse bounds for backward search
				if nastavRozsah(prCURS, FO1.getEnd(),FO3.getStart()) &lt;&gt; 0 then
					prCURS = nastavKurzor(FO1) &apos; in the case of bug of region search farther behind the FO1
					goto hledejdal
				end if
			else
				if nastavRozsah(prCURS, FO1.getStart(),FO3.getEnd()) &lt;&gt; 0 then
					prCURS = nastavKurzor(FO1) &apos; in the case of bug of region search farther behind the FO1
					goto hledejdal
				end if
			end if

			&apos; found, save strings
			FO1S = FO1.string
			FO2S = FO2.string
			FO3S = FO3.string
			nastavVKurzor(prCURS, curinit, info )  &apos; show the result
			ALTSlastFOUND = 0 &apos; no found
			goto konec

vratcurs:
			if (j=-1)or(j=1) then
				hlaseni(0) &apos; search inside the block is ended
				nastavVKurzor(ALTSiniSEL, info, curinit)  &apos;set visible cursor according to working one
				FIRSTPASS = true
			else
				if ALTsearchPARAMS.zpet = 1 then  &apos; inverse bounds for backward search
					if 6 &lt;&gt; hlaseni(1) then goto konec &apos;start of document. Continue from the end?
					oVCURS.gotorange(ALTsearchDOC.text.getEnd(),false) &apos; cursor to the end of document
					goto hledejZacKon &apos; BtFindNext
				else
					if 6 &lt;&gt; hlaseni(2) then goto konec &apos;end of document. Continue from the start?
					oVCURS.gotorange(ALTsearchDOC.text.getStart(),false) &apos; cursor to the start of document
					goto hledejZacKon &apos; BtFindNext
				end if
			end if
			ALTSlastFOUND = 10 &apos; code not found
			goto konec

		case else   &apos; standard regexp
			&apos; normal regexps
			if not isSelTextRange(1) then goto konec  &apos; non-text selection would cause the bug
			prCURS = oVCURS.text.createTextCursorByRange(oVCURS) &apos; working according to visible
			ALTSlastFOUND = FindNextInBlock(HLE(), prCURS, ALTSiniSEL, false, false) &apos; presearch without groups
			if (ALTSlastFOUND = 0)and (ALTsearchPARAMS.reg=1)and not( (ubound(HLE1())=0) and ((HLE1(0).hled=&quot;$&quot;) or (HLE1(0).atr=4) ) ) then  &apos;found without groups - search again with groups, only during the regexp symbols a not during the finding of alone $ a not during the finding of character style
				Curs = prCURS.text.createTextCursorByRange(prCURS) &apos; helped cursor according to working one
				if ALTsearchPARAMS.zpet = 1 then
					Curs.collapseToEnd
				else
					Curs.collapseToStart
				end if
				ALTSlastFOUND = FindNextInBlock(HLE1(), Curs, ALTSiniSEL, false, false) &apos; search according to groups
			end if
			goto coDelat
		end select
	end if  &apos; search with regexps

konec:
	HledamDisp(false) &apos; accessible search
	exit sub

nejakaChyba:
	if left(HLE(0).cmd,3) = &quot;[::&quot; then
		if FIRSTPASS then redim TMPPOLE() &apos; reset the array used for search the frames, notes, footnote, a text field
		beep
	else
		hlaseni1(48, false, false, &quot;FindDo: Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error$ &amp; &quot; (line: &quot; &amp; Erl &amp; &quot;)&quot;) &apos;  style: 16=stop 32=? 48=! 64=info; may suppress; cancel the activities
	end if
	resume next
end sub


	&apos; return the text anchor of selected object
	&apos; if it will return null then the anchor is to page - the number of page is in oDOCcontrol.selection.AnchorPageno
	&apos; if the result is in OUTMSG &quot;tab&quot; then the link is on 1st cell of table
sub getAnchorOfObj() as object
	dim null as object
	dim nam, cur, pom, oSel

	if ERRcontrol then on error goto nejakaChyba

	OUTMSG = &quot;&quot;  &apos; public variable with the additional results of function
	&apos; in the nam is the type of selected object for example &quot;SwXTextFrame&quot;
	nam = oDOCcontrol.selection.ImplementationName
	select case nam  &apos; put prCURS to anchor (if possible), to put potentially pasted text to object
		&apos; text block
	case &quot;SwXTextRanges&quot;
		getAnchorOfObj = null
		OUTMSG = &quot;text&quot; &apos; flag of text object - let it be?

		&apos; pictures and text frames
	case &quot;SwXTextFrame&quot;, &quot;SwXTextGraphicObject&quot;
		oSel = oDOCcontrol.selection
		select case oSel.AnchorType &apos; according to type of anchoring
		case com.sun.star.text.TextContentAnchorType.AT_PARAGRAPH
			&apos; to the start of paragraph
			cur = oSel.Anchor.text.createtextCursorByRange(oSel.Anchor.getStart()) &apos; to the place of anchor, can be anywhere in paragraph
			cur.gotoStartOfParagraph(false)
			getAnchorOfObj = cur.getStart()    &apos; at null, set the start of paragraph

		case com.sun.star.text.TextContentAnchorType.AS_CHARACTER, com.sun.star.text.TextContentAnchorType.AT_CHARACTER
			&apos; as character, to character - directly the anchor
			getAnchorOfObj = oSel.Anchor.getStart()

		case com.sun.star.text.TextContentAnchorType.AT_PAGE
			&apos; ke strance
			getAnchorOfObj = null &apos; oDOCcontrol.selection.AnchorPageno
			&apos; return the number of anchored page
			OUTMSG = &quot;&quot; &amp; oSel.AnchorPageno

		case com.sun.star.text.TextContentAnchorType.AT_FRAME
			&apos; at start of text frame
			getAnchorOfObj = oSel.AnchorFrame.getStart
		end select

		&apos; tabulky
	case &quot;SwXTextTableCursor&quot;
		&apos; the name of 1st cell of table
		pom=oDOCcontrol.ViewCursor.TextTable.CellNames(0)
		&apos; start of 1st cell
		getAnchorOfObj = oDOCcontrol.ViewCursor.TextTable.getCellByName(pom).getStart()
		OUTMSG = &quot;tab&quot; &apos; flag the link is to the 1st cell of table

	case &quot;com.sun.star.drawing.SvxShapeCollection&quot;
		oSel = oDOCcontrol.selection.getByIndex(0)
		select case oSel.AnchorType &apos; according to type of anchoring
		case com.sun.star.text.TextContentAnchorType.AT_PARAGRAPH
			&apos; to the start of paragraph
			cur = oSel.Anchor.text.createtextCursorByRange(oSel.Anchor.getStart()) &apos; to the place of anchor, can be anywhere in paragraph
			cur.gotoStartOfParagraph(false)
			getAnchorOfObj = cur.getStart()    &apos; at null, set the start of paragraph

		case com.sun.star.text.TextContentAnchorType.AS_CHARACTER, com.sun.star.text.TextContentAnchorType.AT_CHARACTER
			&apos; as character, to character - directly the anchor
			getAnchorOfObj = oSel.Anchor.getStart()

		case com.sun.star.text.TextContentAnchorType.AT_PAGE
			&apos; ke strance
			getAnchorOfObj = null &apos; oDOCcontrol.selection.AnchorPageno
			&apos; return the number of anchored page
			OUTMSG = &quot;&quot; &amp; oSel.AnchorPageno

		case com.sun.star.text.TextContentAnchorType.AT_FRAME
			&apos; at start of text frame
			getAnchorOfObj = oSel.AnchorFrame.getStart
		end select
		getAnchorOfObj = null

	case else
		hlaseni1(32, true, false, &quot;getAnchorOfObj():  Unknown object:  &quot; &amp; nam) &apos;  style: 16=stop 32=? 48=! 64=info; may suppress; cancel the activities
		getAnchorOfObj = null
	end select
	exit sub
nejakaChyba:
	hlaseni1(48, true, false, &quot;getAnchorOfObj():  Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error$ &amp; &quot; (line: &quot; &amp; Erl &amp; &quot;)&quot;) &apos;  style: 16=stop 32=? 48=! 64=info; may suppress; cancel the activities
	getAnchorOfObj = null
end sub


	&apos; returns the anchor of text frame or picture
sub getAnchorOfFramePicture(oTmp as object)as object
	dim typKotvy, pom
	typKotvy = oTmp.AnchorType
	select case typKotvy &apos; according to type of anchoring
	case com.sun.star.text.TextContentAnchorType.AT_PARAGRAPH
		&apos; to the start of paragraph
		pom = oTmp.Anchor.text.createtextCursorByRange(oTmp.Anchor.getStart()) &apos; to the place of anchor, can be anywhere in paragraph
		pom.gotoStartOfParagraph(false)
		getAnchorOfFramePicture = pom

	case com.sun.star.text.TextContentAnchorType.AS_CHARACTER, com.sun.star.text.TextContentAnchorType.AT_CHARACTER
		&apos; as character, to character - directly the anchor
		getAnchorOfFramePicture = oTmp.Anchor.getStart()

	case com.sun.star.text.TextContentAnchorType.AT_PAGE
		&apos; to page - set visible cursor to number of page
		oVCURS.JumpToPage(oTmp.AnchorPageno)
		getAnchorOfFramePicture = oVCURS.text.createTextCursorByRange(oVCURS.getStart) &apos; find out the range

	case com.sun.star.text.TextContentAnchorType.AT_FRAME
		&apos; at start of text frame
		getAnchorOfFramePicture = oTmp.AnchorFrame.getStart
	end select
end sub


	&apos; it returns the structured variable like string name = value, separated with SEP
sub getStructValues(oSe as object,jmeno as string)as string
	dim OOoReflection, pom, i, struct, vysl, valu
	const sep as string = &quot; &quot;
	if ERRcontrol then on error resume next
	&apos; ascertainment of UNO name - struct or implementName
	OOoReflection = CreateUnoService(&quot;com.sun.star.reflection.CoreReflection&quot;) &apos; helped object
	pom = oSe.GetPropertyValue(jmeno)
	&apos; arrays with the names of variables
	struct = OOoReflection.getType(pom).Fields

	for i = lbound(struct) to ubound(struct())
		valu = &quot;&quot;  &apos; the null value is supposed
		&apos; if the value is struct again then service of bug
		&apos; will jump to next line and the empty string is used as value
		valu = cstr(struct(i).get(pom))
		vysl = vysl &amp; struct(i).name &amp; &quot;=&quot; &amp; valu &amp; sep
	next i

	vysl = left(vysl,len(vysl)-1) &apos; without last paragraph
	getStructValues = vysl
end sub


	&apos; returns array with the names of styles
	&apos; typ = ParagraphStyles, CharacterStyles, NumberingStyles
	&apos; InUse selects only styles used in text
sub GetStyles(typ as string, InUse as boolean)as array
	dim oParst,i,n
	dim pom()
	oParst =  ALTsearchDOC.StyleFamilies.getbyname(typ)
	n = 0
	for i  = 0 to oParst.count-1
		if InUse then  &apos; only used
			if oParst.getByIndex(i).isInUse then
				redim preserve pom(n)
				pom(n) = oParst.getByIndex(i).DisplayName  &apos; localized name - czech
				n = n + 1
			end if
		else  &apos; all
			redim preserve pom(n)
			pom(n) = oParst.getByIndex(i).DisplayName  &apos; localized name - czech
			n = n + 1
		end if
	next i
	GetStyles() = BubbleSortList_(pom())
end sub


	&apos; returns text range with the set table
sub getTextRangeOfTable(oTbl as object) as object
	dim pom, curs
	pom=oTbl.CellNames(0) &apos; the name of 1st cell of table
	oVCURS.gotoRange(oTbl.getCellByName(pom).getStart(),false) &apos; visible cursor to the start of 1st cell
	oVCURS.goLeft(1,false) &apos;before table
	curs = oVCURS.text.createTextCursorByRange(oVCURS.getStart()) &apos; start mark according to visible
	oVCURS.goDown(1,true) &apos; select whole table to cut one away
	oVCURS.gotoStartofLine(true)
	curs.gotoRange(oVCURS.getEnd(),true)
	getTextRangeOfTable = curs
end sub


	&apos; returns string value according to searched name
sub getValString(ret,nam$) as string
	const sep as string = &quot; &quot;  &apos; separator of single records
	dim pom, val
	pom = rightPast(ret, nam &amp; &quot;=&quot;) &amp;  sep &apos; the part immediately behind the name + &quot;=&quot;
	getValString = leftTo(pom,sep)
end sub


	&apos; make all choices un/accessible during the search, replacing
sub HledamDisp(Off as boolean)
	dim volba
	&apos; if ERRcontrol then on error resume next
	volba = not off
	if not ALTsearchDIALOG_end then
		with oDIAL.model
			.Bt_count.enabled = volba
			.Bt_find.enabled = volba
			.Bt_findall.enabled = volba
			.Bt_repl.enabled = volba
			.Bt_replall.enabled = volba
			&apos; zalozka davky
			.Bt_run.enabled = volba
		end with
	end if

	if Off then
		StatusText(MSG(7),100,true,ALTsearchDOC.ParagraphCount) &apos;  writing to the statusbar: &quot; (ESC in document for interrupt) - Founded paragraphs/loop: &quot;
		FINDCOUNTER = 0
		nCOUNT = 0
		&apos;service for the possibility of interruption from document
		ALTsearchKBD = createUnoListener(&quot;ALTsearchKBD_&quot;,&quot;com.sun.star.awt.XKeyHandler&quot;)
		&apos; ad service to current document
		ALTsearchDOCCONTROL.addKeyHandler(ALTsearchKBD)
		if not ALTsearchDIALOG_end then
			oDIAL.model.Bt_close.label = MSG(8) &apos; cancel, only if dialog is opened
		end if
	else  &apos; end the all
		StatusText(&quot;&quot;,100,true,0)
		FINDCOUNTER = -99
		if not ALTsearchDIALOG_end then
			oDIAL.model.Bt_close.label = MSG(9) &apos; close, only if dialog is opened
		end if
		ALTsearchDOCCONTROL.removeKeyHandler(ALTsearchKBD)
	end if
end sub


sub KonecTm
	&apos; save the position
	if ERRcontrol then on error resume next
	if FINDCOUNTER &gt; 0 then &apos; cancel the search
		FINDCOUNTER = -999
		exit sub
	end if
	ALTsearchINI(1) = oDIAL.PosSize.X
	ALTsearchINI(2) = oDIAL.PosSize.Y
	ALTsearchINI(3) = oDIAL.model.Ch_case.state &apos; case sensitive
	ALTsearchINI(4) = oDIAL.model.Ch_word.state &apos; whole words
	ALTsearchINI(5) = oDIAL.model.Ch_reg.state  &apos; regexps
	ALTsearchINI(6) = oDIAL.model.Ch_zpet.state &apos; backward
	ALTsearchINI(7) = oDIAL.model.Ch_styl.state &apos; search the styles
	ALTsearchINI(10) = oDIAL.model.Ch_preservecap.state &apos; &apos; leave uppercases
	ALTsearchINI(8) = ALTsearchPARAMS.find
	ALTsearchINI(9) = ALTsearchPARAMS.repl
	ulozHistorii &apos; save the history of F&amp;R from records to global arrays
	ALTsearchDIALOG_end = true
	ALTsearchDOCCONTROL.removeKeyHandler(ALTsearchKBD) &apos; end handler for keyboard
end sub


	&apos; load the options of search to work variable to prevent the potential changes in the progress of search
sub loadParams(fromINI as boolean)
	if fromINI then &apos; reload the values from array ALTsearchINI - ALTsearchPARAMS doesn&apos;t funct globally, probably bug
		ALTsearchPARAMS.kcase = ALTsearchINI(3) &apos; oDIAL.model.Ch_case.state &apos; case sensitive
		ALTsearchPARAMS.word = ALTsearchINI(4) &apos; oDIAL.model.Ch_word.state &apos; whole words
		ALTsearchPARAMS.reg = ALTsearchINI(5) &apos; oDIAL.model.Ch_reg.state  &apos; regexps
		ALTsearchPARAMS.zpet = ALTsearchINI(6) &apos; oDIAL.model.Ch_zpet.state &apos; backward
		ALTsearchPARAMS.styl = ALTsearchINI(7) &apos; oDIAL.model.Ch_styl.state &apos; search the styles
		ALTsearchPARAMS.preservecap = ALTsearchINI(10)  &apos; oDIAL.model.Ch_preservecap.state &apos; let uppercases

		ALTsearchPARAMS.find = ALTsearchINI(8)
		ALTsearchPARAMS.repl = ALTsearchINI(9)
	else  &apos; load according to settings of dialog
		ALTsearchPARAMS.kcase = 0
		ALTsearchPARAMS.word = 0
		ALTsearchPARAMS.styl = 0
		ALTsearchPARAMS.reg = 0
		ALTsearchPARAMS.preservecap = 0
		ALTsearchPARAMS.csele = 0
		ALTsearchPARAMS.zpet = 0
		if (oDIAL.model.Ch_case.state = 1)and(oDIAL.model.Ch_case.enabled) then ALTsearchPARAMS.kcase = 1
		if (oDIAL.model.Ch_word.state = 1)and(oDIAL.model.Ch_word.enabled) then ALTsearchPARAMS.word = 1
		if (oDIAL.model.Ch_styl.state = 1)and(oDIAL.model.Ch_styl.enabled) then ALTsearchPARAMS.styl = 1
		if (oDIAL.model.Ch_reg.state = 1)and(oDIAL.model.Ch_reg.enabled) then ALTsearchPARAMS.reg = 1
		if (oDIAL.model.Ch_preservecap.state = 1)and(oDIAL.model.Ch_preservecap.enabled) then ALTsearchPARAMS.preservecap = 1
		if (oDIAL.model.Ch_csele.state = 1)and(oDIAL.model.Ch_csele.enabled) then ALTsearchPARAMS.csele = 1
		if (oDIAL.model.Ch_zpet.state = 1)and(oDIAL.model.Ch_zpet.enabled) then ALTsearchPARAMS.zpet = 1

		ALTsearchPARAMS.find = oDIAL.model.Cb_find.text
		ALTsearchPARAMS.repl = oDIAL.model.Cb_repl.text
	end if
end sub


	&apos; procedure for universal calculating outside of special objects
	&apos; mark enables the marking of found text with BackgrounColor for following selection of all
sub Pocitej(HLE(), mark as boolean)as boolean
	resetPrCurs &apos; set prCURS in the dependence of selected block and choice of block
	if not isSelTextRange(1) then goto konec  &apos; non-text selection would do a bug
	Pocitej = true
	ALTSlastFOUND = FindNextInBlock(HLE(), prCURS, ALTSiniSEL, true, mark) &apos; presearch without groups
	if ALTSlastFOUND = -999 then goto konec  &apos; canceled by user
	exit sub
konec:
	Pocitej = false
end sub


	&apos; the procedure will replace according to rule REPL the block defined by prCURS
	&apos; if the block prCURS &gt;64 kb, then it uses visible cursor
	&apos; internal function OOo using dispatchHelper
	&apos; it supposes the prCURS is found text
sub ReplDo
	dim clipbMode as boolean  &apos; flag that activates inserting of objects/text from clipboard instead of only from text cursor.string()
	dim Bmark, markPrac, oSel    &apos; mark for the start of found/pasted text and work mark, selected object curentcontroller.selection
	dim markD, markH, markP, markC, markN, markProp, markK   &apos; work marks for the setting of styles and properties
	dim i, sk, pom, pom1, s$

	dim oFoot, oFootCurs &apos; for make of Foot/Endnote
	dim noTextOb, obnovVcurs as boolean
	dim mistochyby as string
	dim oriCurs &apos; original working cursor, at redirecting
	dim mode

	mistochyby = &quot;&quot;
	if ERRcontrol then on error goto nejakaChyba

	&apos; \ = search in the names of bookmarks
	mode = -1  &apos; -1 = search in the text of bookmark; 1 = search at the names of bookmarks; 0 = search any bookmark
	if left(HLE(0).hled,2)= &quot;\\&quot; then  mode = 1
	if HLE(0).hled = &quot;&quot; then mode = 0 &apos; find all

	noTextOb = false &apos; it supposes text object
	clipbMode = false &apos; inserting via clipboard
	obnovVcurs = false &apos; after the end of inserting set the visible cursor oVCURS according to prCURS, after use of clipboard

	&apos; redirect replacement (\R) to the window/frame ALTsearchPRINTOUT ?
	if ALTsearchPRINTOUT = &quot;&quot; then &apos; no
		oriCurs = prCURS  &apos; remember the original work cursor - it should be found text or object

		&apos; will the object be deleted? (or only the properties will be changed?)
		If REPL(0).smaz = 1 then &apos; yes delete
			if REPL(0).vloz = 1 then &apos; the replace inputbox contains the found text &quot;&amp;&quot;, if it is object or long text then delete to clipboard
				if (REPL(0).form = 1)or(isBigText_Or_NonTextObject(oDOCcontrol.getViewCursor())) then &apos; is it text over 64k or object, table?

					if (HLE(0).cmd = &quot;[::Bookmark::]&quot;)and (mode = 1) then goto stornoClipboard: &apos; turn off the transfer through the clipboard at the search of bookmarks - else bad detection of text in tables

					&apos; there will be next use - delete to clipboard
					clipbMode = true
					if HLE(0).cmd = &quot;[::BigBlock::]&quot; then
						&apos; only the middle for big block
						FO1.string = &quot;&quot;  &apos; marks away
						FO3.string = &quot;&quot;
						&apos; let middle
						nastavVKurzor(FO2, false, &quot;&quot;)  &apos;set visible cursor according to middle block
						DISPATCHER.executeDispatch(oDOCcontrol.Frame, &quot;.uno:Cut&quot;, &quot;&quot;, 0, Array())
					else  &apos; cut object
						&apos; put prCURS to the anchor (if possible), to put potentially pasted text to object
						&apos; return the anchor of object to text for setting of prCURS
						nastavVKurzor(prCURS, false, &quot;&quot;)  &apos;set visible cursor according to work one
						markPrac = getAnchorOfObj()
						select case OUTMSG  &apos; auxiliary result, indication of table
						case &quot;text&quot;
							Bmark = prCURS.text.createTextCursorByRange(prCURS.getStart())

						case &quot;&quot;  &apos; non-text object, picture, frame - it is possible to set directly prCURS, anchor to character, paragraph
							Bmark = markPrac.text.createTextCursorByRange(markPrac.getStart())
							noTextOb = true

						case &quot;tab&quot; &apos; must move cursor before table, anchor from table doesn&apos;t funct, so through the visible cursor
							oVCURS.gotoRange(markPrac, false) &apos;set visible cursor according to link - to start of 1st cell
							oVCURS.goLeft(1,false) &apos;before table
							Bmark = oVCURS.text.createTextCursorByRange(oVCURS.getStart()) &apos; start mark according to visible
							oVCURS.goDown(1,true) &apos; select whole table to cut one away
							oVCURS.gotoStartofLine(true)

						case else &apos; it could be the number of page at anchoring to page
							&apos;to the start of page, through the visible cursor
							oDOCcontrol.ViewCursor.JumpToPage(val(OUTMSG))
							Bmark = oVCURS.text.createTextCursorByRange(oVCURS) &apos;  start mark according to visible
							oDOCcontrol.select(prCURS)  &apos; select the object again

						end select

						DISPATCHER.executeDispatch(oDOCcontrol.Frame, &quot;.uno:Cut&quot;, &quot;&quot;, 0, Array())
						&apos; prCURS to the start of Bmark - anchor
						prCURS = Bmark.text.createTextCursorByRange(Bmark)
						Bmark = prCURS.getStart()

					end if  &apos; cut object

				else  &apos; delete like text
					&apos; pokud je nalezeno samotné pole tak upravit prCURS posunout doprava aby se vybralo celé pole
					&apos;    if isObject(prCURS.TextField) then prCURS.goRight(1,true)
					prCURS.string = &quot;&quot; &apos; delete like text
					Bmark = prCURS.getStart()
				end if  &apos; delete text &gt;64k or object, or delete like text to 64k

			else  &apos; not use &quot;&amp;&quot; - there will not be pasted cotent of textobject in replacement
				if isBigText_Or_NonTextObject(oDOCcontrol.getViewCursor()) then &apos; is it text &gt;64k or is it object,table?
					&apos; delete using Uno to don&apos;t block clipboard unnecessarily
					if HLE(0).cmd = &quot;[::BigBlock::]&quot; then  &apos; delete big-block
						DISPATCHER.executeDispatch(oDOCcontrol.Frame, &quot;.uno:Delete&quot;, &quot;&quot;, 0, Array())
					else &apos; delete general block
						&apos; put prCURS to the anchor (if possible), to put potentially pasted text to object
						&apos; return the anchor of object to text for setting of prCURS
						markPrac = getAnchorOfObj()
						select case OUTMSG  &apos; auxiliary result, indication of table
						case &quot;text&quot;
							Bmark = prCURS.text.createTextCursorByRange(prCURS.getStart())

						case &quot;&quot;  &apos; non-text object, picture, frame - it is possible to set directly prCURS, anchor to character, paragraph
							Bmark = markPrac.text.createTextCursorByRange(markPrac.getStart())
							noTextOb = true

						case &quot;tab&quot; &apos; must move cursor before table, anchor from table doesn&apos;t funct, so through the visible cursor
							oVCURS.gotoRange(markPrac, false) &apos;set visible cursor according to link - to start of 1st cell
							oVCURS.goLeft(1,false) &apos;before table
							Bmark = oVCURS.text.createTextCursorByRange(oVCURS.getStart()) &apos; start mark according to visible
							oVCURS.goDown(1,true) &apos; select whole table to cut one away
							oVCURS.gotoStartofLine(true)

						case else &apos; it could be the number of page at anchoring to page
							&apos;to the start of page, through the visible cursor
							oDOCcontrol.ViewCursor.JumpToPage(val(OUTMSG))
							Bmark = oVCURS.text.createTextCursorByRange(oVCURS) &apos;  start mark according to visible
							oDOCcontrol.select(prCURS)  &apos; select the object again

						end select

						DISPATCHER.executeDispatch(oDOCcontrol.Frame, &quot;.uno:Delete&quot;, &quot;&quot;, 0, Array())
						&apos; prCURS to the start of Bmark - anchor
						prCURS = Bmark.text.createTextCursorByRange(Bmark)
						Bmark = prCURS.getStart()

					end if
				else  &apos; delete like text
					&apos; if the aloned field is found then edit the prCURS move to right to select all field
					prCURS.string = &quot;&quot; &apos; delete like text,
					Bmark = prCURS.getStart()

				end if

			end if

		else &apos; don&apos;t delete, only the properties will be changed
			&apos; the try to put prCURS to clearly defined place: to the anchor of selected object
			markPrac = getAnchorOfObj() &apos; it tries to return the anchor of selected object in text
			select case OUTMSG  &apos; auxiliary result, indication of table
			case &quot;text&quot;
				&apos; only single text. filed is found so edit prCURS: move to right to select whole field
				Bmark = prCURS.getStart()

			case &quot;&quot;  &apos; non-text object, picture, frame - it is possible to set directly prCURS, anchor to character, paragraph
				oSel = oDOCcontrol.selection  &apos; link to selected object
				noTextOb = true  &apos; flag of non-text object
				Bmark = markPrac.text.createTextCursorByRange(markPrac) &apos; texts to the anchor
				prCURS = Bmark.text.createTextCursorByRange(Bmark) &apos; insert the next after the object

			case &quot;tab&quot; &apos; must move cursor before table, anchor from table doesn&apos;t funct, so through the visible cursor
				oSel = oDOCcontrol.selection  &apos; link to selected table (cellRange)
				noTextOb = true  &apos; flag of non-text object
				oVCURS.gotoRange(markPrac, false) &apos;set visible cursor according to link - to start of 1st cell
				oVCURS.goLeft(1,false) &apos;before table
				Bmark = oVCURS.text.createTextCursorByRange(oVCURS) &apos; start mark according to visible
				prCURS = Bmark.text.createTextCursorByRange(Bmark) &apos; insert the next after the object

			case else &apos; it could be the number of page at anchoring to page
				oSel = oDOCcontrol.selection  &apos; link to selected object ukotveny ke strance
				noTextOb = true  &apos; flag of non-text object
				&apos;to the start of page, through the visible cursor
				oDOCcontrol.ViewCursor.JumpToPage(val(OUTMSG))
				Bmark = oVCURS.text.createTextCursorByRange(oVCURS) &apos;  start mark according to visible
				prCURS = Bmark.text.createTextCursorByRange(Bmark) &apos; insert the next after the object
			end select
		end if

	else &apos; redirect replacement (\R) to window/frame ALTsearchPRINTOUT

		oriCurs = prCURS  &apos; remember original work cursor - it should be found text or object
		prCURS = prCURS1  &apos; redirect prCURS to the file of report
		Bmark = prCURS.getStart() &apos; set base mark of start in file of report

		&apos; bude potřeba schranka ?
		if (REPL(0).form = 1)or(isBigText_Or_NonTextObject(oDOCcontrol.getViewCursor())) then &apos; is it text &gt;64k or is it object, table
			if (HLE(0).cmd = &quot;[::Bookmark::]&quot;)and (mode = 1) then goto stornoClipboard: &apos; turn off the transfer through the clipboard at the search of bookmarks - else bad detection of text in tables
			&apos; the clipboard will be used
			clipbMode = true
			if HLE(0).cmd = &quot;[::BigBlock::]&quot; then
				&apos; copy only the middle for big block
				nastavVKurzor(FO2, false, &quot;&quot;)  &apos;set visible cursor according to middle block
			else
				nastavVKurzor(oriCurs, false, &quot;&quot;)  &apos;set visible cursor
				&apos; if text filed is found then extend the cursor for copy
			end if  &apos; some non-text object
			&apos; copy
			DISPATCHER.executeDispatch(oDOCcontrol.Frame, &quot;.uno:Copy&quot;, &quot;&quot;, 0, Array())
		end if

	end if &apos; redirect replacement (\R) to window/frame ALTsearchPRINTOUT

stornoClipboard:
	&apos; set all marks to the start of found text/object???
	&apos; ensure the non-conflict position of prCURS!!!
	markH = Bmark :  markP = Bmark :  markC = Bmark :  markN = Bmark :  markProp = Bmark
	markD = Bmark :  markK = Bmark

	for i = 0 to ubound(REPL())
		select case REPL(i).cmd
		case &quot;$&quot; &apos; insert string
			if REPL(i).nahr &lt;&gt; &quot;&quot; then
				select case FOUNDcaseTYPE &apos; 0=no modifications, let it be; 1=first is uppercase; 2=all are uppercases
				case 1
					pom = lcase( REPL(i).nahr )  &apos; insert with lowercases but 1st is uppercase
					if i = 0 then pom = ucase(left(pom,1)) &amp; right(pom, len(pom)-1)  &apos; transform 1st to uppercase
					prCURS.string = pom
				case 2
					prCURS.string = ucase( REPL(i).nahr )  &apos; inserted with uppercases
				case else
					prCURS.string = REPL(i).nahr  &apos; insert text without changes
				end select
				prCURS.collapseToEnd
			end if

		case &quot;b&quot; &apos; insert start mark of big block
			if FO1S &lt;&gt; &quot;&quot; then
				prCURS.string = FO1S  &apos; insert text
			else
				prCURS.string =  ALTsearchSKUP(1)
			end if
			prCURS.collapseToEnd

		case &quot;e&quot; &apos; insert final mark of big block
			if FO3S &lt;&gt; &quot;&quot; then
				prCURS.string = FO3S  &apos; insert text
			else
				prCURS.string =  ALTsearchSKUP(2)
			end if
			prCURS.collapseToEnd

		case &quot;i&quot; &apos; insert counter of replacements
			&apos; initial value
			if REPL(i).nahr = &quot;&quot; then pom = 0  else pom = val(leftTo(REPL(i).nahr,&quot;,&quot;)) - 1
			&apos; the format of number - count of places
			pom1 = String(val(rightPast(REPL(i).nahr,&quot;,&quot;)),&quot;0&quot;)
			prCURS.string = Format(REPLCOUNT  +  pom, pom1)  &apos; insert text
			prCURS.collapseToEnd

		case &quot;I&quot; &apos; insert number of page
			if ALTsearchPRINTOUT = &quot;&quot; then &apos; the redirect isn&apos;t
				nastavVKurzor(prCURS, false, &quot;&quot;)  &apos;set visible cursor according the work
				&apos; if it is block of text then detect the page of start of block
				select case prCURS.ImplementationName
				case &quot;SwXTextCursor&quot;
					oVCURS.collapseToStart  &apos; page with start according to original visible cursor
				case &quot;SwXTextTableCursor&quot;  &apos; select text of 1st cell
					oDOCcontrol.select(oVCURS.Cell)
				end select
			else
				nastavVKurzor(oriCurs, false, &quot;&quot;)  &apos;set visible cursor podle puvodniho prac
				&apos; if it is block of text then detect the page of start of block
				select case oriCurs.ImplementationName
				case &quot;SwXTextCursor&quot;
					oVCURS.collapseToStart  &apos; page with start according to original visible cursor
				case &quot;SwXTextTableCursor&quot;  &apos; select text of 1st cell
					oDOCcontrol.select(oVCURS.Cell)
				end select
			end if
			prCURS.string = cstr(oVCURS.getPage())  &apos; insert the number of page of start
			prCURS.collapseToEnd

		case &quot;@&quot; &apos; insert the middle of big block, group
			sk = val(REPL(i).nahr) &apos; numebr value of group, 0 = whole group
			if sk = 0 then  &apos; insert whole found text
				if clipbMode then  &apos; insert from clipboard
					if ALTsearchPRINTOUT = &quot;&quot; then &apos; redirection isn&apos;t
						goto vlozZclipb
					else &apos; redirected
						goto vlozZclipbRedir
					end if
				else  &apos; insert using strings
					if HLE(0).cmd = &quot;[::BigBlock::]&quot; then  &apos; insert the middle of big-block
						prCURS.string = replace_(FO2S,chr(13) &amp; chr(10),chr(13))   &apos; insert text #13#10 is paragraph, so there will be line break after insertion
					else &apos; delete general block
						prCURS.string = replace_(ALTsearchSKUP(0),chr(13) &amp; chr(10),chr(13))   &apos; insert text #13#10 is paragraph, so there will be line break after insertion
					end if
					prCURS.collapseToEnd
				end if
			else &apos; insert group 1 - 9
				if sk &lt;=9 then
					prCURS.string = ALTsearchSKUP(sk)  &apos; insert text
					prCURS.collapseToEnd
				end if
			end if

		case &quot;u&quot; &apos; insert url of link
			if (ALTsearchSKUP(10) &lt;&gt; &quot;&quot;) then &apos; and(isString(ALTsearchSKUP(10)))
				prCURS.string = ALTsearchSKUP(10)  &apos; insert url
				prCURS.collapseToEnd
			end if

		case &quot;o&quot; &apos; insert text content of object (comment, frame, field...)
			if (ALTsearchSKUP(11) &lt;&gt; &quot;&quot;) then
				&apos; #13#10 is paragraph, so there will be line break after insertion
				prCURS.string = replace_(ALTsearchSKUP(11),chr(13) &amp; chr(10),chr(13))  &apos; text content
				prCURS.collapseToEnd
			end if

		case &quot;O&quot; &apos; insert the name of object (comment, frame, field...)
			if (ALTsearchSKUP(12) &lt;&gt; &quot;&quot;) then
				prCURS.string = ALTsearchSKUP(12)  &apos; name of object
				prCURS.collapseToEnd
			end if

		case &quot;p&quot; &apos; insert paragraph
			prCURS.text.insertControlCharacter(prCURS, com.sun.star.text.ControlCharacter.PARAGRAPH_BREAK, false )
			prCURS.collapseToEnd

		case &quot;t&quot; &apos; insert tabulator
			prCURS.string = chr(9)  &apos; insert text
			prCURS.collapseToEnd

		case &quot;n&quot; &apos; insert line break
			prCURS.text.insertControlCharacter(prCURS, com.sun.star.text.ControlCharacter.LINE_BREAK, false )
			prCURS.collapseToEnd

		case &quot;S&quot; &apos; insert nbsp
			prCURS.text.insertControlCharacter(prCURS, com.sun.star.text.ControlCharacter.HARD_SPACE, false )
			prCURS.collapseToEnd

		case &quot;v&quot;, &quot;V&quot; &apos; insert clipboard, insert clipboard without format
			if ALTsearchPRINTOUT = &quot;&quot; then &apos; redirection isn&apos;t

				nastavVKurzor(prCURS, false, &quot;&quot;)  &apos;set visible cursor according the work
				if REPL(i).cmd = &quot;v&quot; then &apos; insert normally
vlozZclipb:
					DISPATCHER.executeDispatch(oDOCcontrol.Frame, &quot;.uno:Paste&quot;, &quot;&quot;, 0, Array())
				else &apos; insert without format
					DISPATHARGS(0).Name = &quot;SelectedFormat&quot;
					DISPATHARGS(0).Value = 1
					DISPATCHER.executeDispatch(oDOCcontrol.Frame, &quot;.uno:ClipboardFormatItems&quot;, &quot;&quot;, 0, dispathArgs())
				end if

				&apos; detect the type of inserted object and set oSel object for potential change of attributes and prCURS
				select case oDOCcontrol.selection.ImplementationName  &apos;
				case &quot;SwXTextRanges&quot; &apos; text block or table
					&apos; inserted table?
					markPrac = oVCURS.getEnd() &apos; save the mark after inserted text or table
					if oVCURS.goleft(1,false) then &apos; visible cursor to table
						if isObject(oDOCcontrol.viewCursor.TextTable) then
							&apos; inserted table
							selectWholeTable(oVCURS) &apos; select whole inserted table
							oSel = oDOCcontrol.selection  &apos; link to selected object
							noTextOb = true
						else
							&apos; normal text, field or object or character - select
							oVCURS.gotoRange(prCURS.getEnd, false) &apos; to the start of text
							oVCURS.gotoRange(markPrac, true) &apos; end of inserted text
							noTextOb = false
						end if

						prCURS = markPrac.text.createTextCursorByRange(markPrac) &apos; insert the next after the object

					end if

					&apos; picture, text frame,  (vector graphics - misbehave)
				case &quot;SwXTextFrame&quot;, &quot;SwXTextGraphicObject&quot;  &apos;, &quot;com.sun.star.drawing.SvxShapeCollection&quot;
					oSel = oDOCcontrol.selection  &apos; link to selected object ukotveny nekam
					noTextOb = true

					&apos; vector graphics
				case &quot;com.sun.star.drawing.SvxShapeCollection&quot;
					&apos; misbehave, write the bugs - after inserting it is not possible to get correct visible cursor oVCURS
					oSel = oDOCcontrol.selection  &apos; link to selected object ukotveny nekam
					nastavVKurzor(prCURS, false, &quot;&quot;)  &apos;set visible cursor according to work oDOCcontrol.select(prCURS)
					noTextOb = true

				case else
					hlaseni1(48, true, false, &quot;ReplDo:  \V \v - insert unknown object:  &quot; &amp; oDOCcontrol.selection.ImplementationName) &apos;  style: 16=stop 32=? 48=! 64=info; may suppress; cancel the activities

				end select
				obnovVcurs = true &apos; set visible cursor oVCURS according to prCURS after the end of inserting, after use of clipboard

			else &apos; redirected
				nastavVKurzor(prCURS1, false, &quot;&quot;)  &apos;set visible cursor according the work to goal place
				if REPL(i).cmd = &quot;v&quot; then &apos; insert normally
vlozZclipbRedir:
					DISPATCHER.executeDispatch(oPOFILE.getCurrentController().Frame, &quot;.uno:Paste&quot;, &quot;&quot;, 0, Array())
				else &apos; insert without format
					DISPATHARGS(0).Name = &quot;SelectedFormat&quot;
					DISPATHARGS(0).Value = 1
					DISPATCHER.executeDispatch(oPOFILE.getCurrentController().Frame, &quot;.uno:ClipboardFormatItems&quot;, &quot;&quot;, 0, dispathArgs())
				end if

				&apos; detect the type of inserted object and set oSel object for potential change of attributes and prCURS
				select case oPOFILE.getCurrentController().selection.ImplementationName  &apos;
				case &quot;SwXTextRanges&quot; &apos; text block nebo tabulka
					&apos; inserted table?
					markPrac = oVCURS1.getEnd() &apos; save the mark after inserted text or table
					if oVCURS1.goleft(1,false) then &apos; visible cursor to table
						if isObject(oPOFILE.getCurrentController().viewCursor.TextTable) then
							&apos; inserted table
							selectWholeTable(oVCURS1) &apos; select whole inserted table
							oSel = oPOFILE.getCurrentController().selection  &apos; link to selected object
							noTextOb = true
						else
							&apos; normal text, field or object or character - select
							oVCURS1.gotoRange(prCURS1.getEnd, false) &apos; to the start of text
							oVCURS1.gotoRange(markPrac, true) &apos; end of inserted text
							noTextOb = false
						end if

						prCURS = markPrac.text.createTextCursorByRange(markPrac) &apos; insert the next after the object

					end if

					&apos; picture, text frame,  (vektorova grafika - zlobí)
				case &quot;SwXTextFrame&quot;, &quot;SwXTextGraphicObject&quot;  &apos;, &quot;com.sun.star.drawing.SvxShapeCollection&quot;
					oSel = oPOFILE.getCurrentController().selection  &apos; link to selected object ukotveny nekam
					noTextOb = true

					&apos; vector graphics
				case &quot;com.sun.star.drawing.SvxShapeCollection&quot;
					&apos; misbehave, write the bugs - after inserting it is not possible to get correct visible cursor oVCURS
					oSel = oPOFILE.getCurrentController().selection  &apos; link to selected object ukotveny nekam
					nastavVKurzor(prCURS1, false, &quot;&quot;)  &apos;set visible cursor according to work oDOCcontrol.select(prCURS)
					noTextOb = true

				case else
					hlaseni1(48, true, false, &quot;ReplDo:  \V \v - insert unknown object:  &quot; &amp; oPOFILE.getCurrentController().selection.ImplementationName) &apos;  style: 16=stop 32=? 48=! 64=info; may suppress; cancel the activities

				end select
				obnovVcurs = true &apos; set visible cursor oVCURS according to prCURS after the end of inserting, after use of clipboard

			end if &apos; redirected


		case &quot;M&quot; &apos; page break after paragraph
			prCURS.BreakType = com.sun.star.style.BreakType.PAGE_AFTER &apos;after paragraph = 5

		case &quot;m&quot; &apos; page break before paragraph
			prCURS.BreakType = com.sun.star.style.BreakType.PAGE_BEFORE &apos;before paragraph = 4

		case &quot;c&quot; &apos; column break
			prCURS.BreakType = com.sun.star.style.BreakType.COLUMN_BEFORE   &apos; before = 1; after = 2; both = 3

		case &quot;r&quot; &apos; cancel the column break - for current paragraph
			prCURS.BreakType = com.sun.star.style.BreakType.NONE  &apos; = 0

		case &quot;D&quot; &apos; set all properties to default formatting
			prCURS.gotoRange(markD, true)  &apos; range from the end to the last used postion of this setting
			markD = prCURS.getEnd()  &apos; save last position for next use
			prCURS.setAllPropertiesToDefault()
			prCURS.collapseToEnd

		case &quot;d&quot; &apos; reset the properties to default formatting in the place of use = like Ctrl+Shift+space
			nastavVKurzor(prCURS.getStart(), false, &quot;&quot;)  &apos;set visible cursor according the work to goal place
			DISPATCHER.executeDispatch(oDOCcontrol.Frame, &quot;.uno:ResetAttributes&quot;, &quot;&quot;, 0, Array())
			prCURS.collapseToEnd

		case &quot;h&quot; &apos; set entered URL = create or cancel the hyperlink from text
			prCURS.gotoRange(markH, true)
			markH = prCURS.getEnd()  &apos; save last position for next use
			&apos; enable the use of parameter \0..\9, &amp;, \u, inside \h{}
			prCURS.HyperLinkURL = SubstValue(REPL(i).nahr, prCURS, oriCurs)
			prCURS.collapseToEnd

		case &quot;H&quot; &apos; replace substring found in URL (HLE(0).pstyl) by set string (in REPL(i).nahr)
			prCURS.gotoRange(markH, true)
			markH = prCURS.getEnd()  &apos; save last position for next use
			pom = prCURS.HyperLinkURL
			sk = instr(pom,HLE(0).pstyl)
			if sk &gt; 0 then
				pom = left(prCURS.HyperLinkURL,sk-1)
				pom = pom  &amp;  SubstValue(REPL(i).nahr)  &amp;  right(prCURS.HyperLinkURL, len(prCURS.HyperLinkURL)-len(HLE(0).pstyl)-sk+1, prCURS, oriCurs)
				prCURS.HyperLinkURL = pom
			end if
			prCURS.collapseToEnd

		case &quot;P&quot; &apos; set paragraph style
			prCURS.gotoRange(markP, true)
			markP = prCURS.getEnd()  &apos; save last position for next use
			prCURS.ParaStyleName = REPL(i).nahr
			prCURS.collapseToEnd

		case &quot;C&quot; &apos; set character style
			prCURS.gotoRange(markC, true)
			markC = prCURS.getEnd()  &apos; save last position for next use
			prCURS.CharStyleName = REPL(i).nahr
			prCURS.collapseToEnd

		case &quot;N&quot; &apos; set style of list
			prCURS.gotoRange(markN, true)
			markN = prCURS.getEnd()  &apos; save last position for next use
			prCURS.NumberingStyleName = REPL(i).nahr
			prCURS.collapseToEnd

		case &quot;A&quot; &apos; set entered property - properties
			if noTextOb then
				&apos; non-text object - change the properties to oSel
				&apos; enable the use of parameter \0..\9, &amp;, \u, \xhhhhh, \#ddddd inside the \A{}
				pom = SubstValue(REPL(i).nahr, prCURS, oriCurs)
				if not setPropeties(oSel,pom) then ERRPROP = ERRPROP + 1 &apos; the counter of incorrect settings of properties
				&apos; if there isn&apos;t next command \A then cancel the setting of object properties
				if i &lt; ubound(REPL()) then
					if REPL(i+1).cmd &lt;&gt; &quot;A&quot; then noTextOb = false &apos; next replacement is text, return to text regime
				end if
			else
				&apos; text range - change the properties on prCURS
				prCURS.gotoRange(markProp, true)
				&apos; if there isn&apos;t next command \A then save last position for next use
				if i &lt; ubound(REPL()) then
					if REPL(i+1).cmd &lt;&gt; &quot;A&quot; then markProp = prCURS.getEnd()  &apos; save last position for next use
				end if

				if not setPropeties(prCURS,REPL(i).nahr) then ERRPROP = ERRPROP + 1 &apos; the counter of incorrect settings of properties
				prCURS.collapseToEnd
			end if

		case &quot;F&quot; &apos; insert footnote
			&apos; create new footnote
			oFoot = ALTsearchDOC.createInstance(&quot;com.sun.star.text.Footnote&quot;)
			&apos; add to document
			oFoot.attach(prCURS.End)
			prCURS.collapseToEnd
			mistochyby = &quot;F&quot;  &apos; identification of the place of bug
			&apos; fill the content of footnote
			oFootCurs = oFoot.createTextCursor

			&apos; enable the use of parameter \0..\9, &amp;, \u, \xhhhhh, \#ddddd inside the \h{}
			oFootCurs.string = SubstValue(REPL(i).nahr, prCURS, oriCurs)

		case &quot;E&quot; &apos; insert the endnote
			&apos; create new endnote
			oFoot = ALTsearchDOC.createInstance(&quot;com.sun.star.text.Endnote&quot;)
			&apos; add to document
			oFoot.attach(prCURS.End)
			prCURS.collapseToEnd
			mistochyby = &quot;E&quot;  &apos; indentification of the place of bug
			&apos; fill the content of endnote
			oFootCurs = oFoot.createTextCursor
			&apos; enable the use of parameter \0..\9, &amp;, \u, \xhhhhh, \#ddddd inside the \h{}
			oFootCurs.string = SubstValue(REPL(i).nahr, prCURS, oriCurs)

		case &quot;B&quot; &apos; insert mark and text for reference mark: mark|text
			&apos; create new mark
			oFoot = ALTsearchDOC.createInstance(&quot;com.sun.star.text.ReferenceMark&quot;)
			&apos; add to document
			pom = SubstValue(REPL(i).nahr, prCURS, oriCurs) &apos; parameter
			if instr(pom,&quot;|&quot;)&lt;1 then pom = pom  &amp;  &quot;|&quot;  &apos; if there isn&apos;t separator then take it like mark
			prCURS.string = rightPast(pom,&quot;|&quot;) &apos;insert text
			pom = leftTo(pom,&quot;|&quot;) &apos; mark
			oFoot.Name = pom
			if ALTsearchDOC.ReferenceMarks.hasByName(pom) then  &apos; this name already exists
				hlaseni1(64, true, false, MSG(39)) &apos;  style: 16=stop 32=? 48=! 64=info; may suppress; cancel the activities
			else
				prCURS.Text.insertTextContent(prCURS, oFoot, True)
			end if

			prCURS.collapseToEnd

		case &quot;K&quot; &apos; insert bookmark of entered name; parameters w = whole block,  b = only at start of block, e = only at end of block
			&apos; detect the parameter
			pom = SubstValue(REPL(i).nahr, prCURS, oriCurs)
			pom1 = trim(leftTo(pom,&quot;,&quot;))  &apos; parameter
			pom = rightPast(pom,&quot;,&quot;)      &apos; name

			prCURS.gotoRange(markK, true)  &apos; set work cursor to last mark (firstly the range of whole found string)
			markK = prCURS.getEnd()  &apos; save last position for next use of the same parameter

			&apos; create the variable of bookmark
			oFoot = ALTsearchDOC.createInstance(&quot;com.sun.star.text.Bookmark&quot;)
			oFoot.Name = SubstValue(pom, prCURS, oriCurs) &apos; parameter with inserted values &amp; \0-\9 \i and the like

			if oFoot.Name = &quot;&quot; then  &apos; empty name = delete bookmark if it is on the place of cursor

				&apos;confirm that cursor was on some bookmark, if yes then delete
				if FOUNDbookmarkNO &gt;= 0 then
					ALTsearchDOC.Bookmarks.getByName(ALTsearchSKUP(12)).dispose
					FOUNDbookmarkNO = -1  &apos; search again after delete
				end if

			else  &apos; put bookmark to document
				&apos; prCURS has set range of found or still replaced text
				select case pom1  &apos; 1st parameter - w,b,e = type of inserting of block
				case &quot;b&quot;
					prCURS.collapseToStart  &apos; insert to start
				case &quot;e&quot;
					prCURS.collapseToEnd    &apos; insert to end
				end select

				prCURS.Text.insertTextContent(prCURS, oFoot, True)
			end if

			prCURS.gotoRange(markK, false)  &apos; restore the position of cursor to end, if the parameter &quot;b&quot; was used
			prCURS.collapseToEnd

		case &quot;L&quot; &apos; insert cross link
			&apos; create new mark
			oFoot = ALTsearchDOC.createInstance(&quot;com.sun.star.text.TextField.GetReference&quot;)
			pom = SubstValue(REPL(i).nahr, prCURS, oriCurs)
			oFoot.ReferenceFieldPart = val(leftTo(pom,&quot;,&quot;))  &apos; 1st parameter - type of displaying of link (page, chapter, ...)
			pom = rightPast(pom,&quot;,&quot;)
			oFoot.ReferenceFieldSource = val(leftTo(pom,&quot;,&quot;)) &apos; 2nd parameter - type of source (mark reference, )
			oFoot.SourceName = rightPast(pom,&quot;,&quot;)

			&apos; add to document
			oFoot.attach(prCURS.End)
			prCURS.collapseToEnd
			TEXTFIELDS = true

		case &quot;!&quot; &apos; bug, end
			iREPLACE=iREPLACE+1
			goto konec
		end select

pokracuj:
	next i &apos; end of loop of all records for replace

	&apos; redirect of replace (\R) to window/frame ALTsearchPRINTOUT ?
	if ALTsearchPRINTOUT &lt;&gt; &quot;&quot; then &apos; redirect yes
		RestoreFrameName &apos; after write it need to restore the identificator if the file isn&apos;t saved
		&apos;set visible cursor in report according to work one
		oPOFILE.CurrentController.select(prCURS)    &apos; select end

		&apos;set original prCURS for next F&amp;R
		prCURS = oriCurs
		&apos; prCURS report to the end
		prCURS1.gotoEnd(false)

		if noTextOb then goto preskoc
	end if

	&apos; set prCURS for next F&amp;R
	if ALTsearchPARAMS.zpet = 1 then
		prCURS.gotoRange(Bmark, false)
	else &apos;for now, after replace the cursor should be afer last inserted character
		mistochyby = &quot;nastavPrCurs&quot; &apos; there was bug during use \R to notes
		prCURS.gotoRange(prCURS.getEnd(), false)
nastavPrCurs:
	end if

	if obnovVcurs then nastavVKurzor(prCURS, false, &quot;&quot;)  &apos;set visible cursor according the work
preskoc:
konec:
	exit sub

nejakaChyba:
	select case mistochyby
	case &quot;F&quot;, &quot;E&quot; &apos; error during the creation of note
		hlaseni1(64, true, false, MSG(38)) &apos;  style: 16=stop 32=? 48=! 64=info; may suppress; cancel the activities
		mistochyby = &quot;&quot;
		goto pokracuj
	case &quot;nastavPrCurs&quot; &apos; bug
		mistochyby = &quot;&quot;
	case else
		hlaseni1(48, true, false, &quot;ReplDo:  Error &quot; &amp; Err &amp; &quot;: &quot; &amp; Error$ &amp; &quot; (line: &quot; &amp; Erl &amp; &quot;)&quot;) &apos;  style: 16=stop 32=? 48=! 64=info; may suppress; cancel the activities
	end select
end sub


sub reset_klv  &apos; there was some problem with keyHandler - uninstall
	on error goto konec
	&apos; global variables; if ones are defined then keyHandler is removed
	ALTsearchDOCCONTROL.removeKeyHandler(ALTsearchKBD)
	ALTsearchDIALOG.setVisible(false)
konec:
end sub


	&apos; set prCURS in the dependence of selected block and choice of block
sub resetPrCurs
	&apos; set the start of search if the search is only inside the block during 1st search
	if (ALTsearchPARAMS.csele = 1) then
		if ALTsearchPARAMS.zpet = 1 then   &apos; for search from the end of block
			prCURS = oVCURS.text.createTextCursorByRange(oVCURS.GetEnd()) &apos; working according to visible
		else
			prCURS = oVCURS.text.createTextCursorByRange(oVCURS.GetStart()) &apos; working according to visible
		end if
	else
		if ALTsearchPARAMS.zpet = 1 then   &apos; for searching from the end of document
			prCURS = ALTsearchDOC.text.GetEnd()
		else
			prCURS = ALTsearchDOC.text.GetStart()
		end if
	end if
end sub


	&apos; on the base of entered text object belonging to any cell of table
	&apos; select whole table by visible cursor
sub selectWholeTable(TextBunky)
	dim OTmp, pom
	if ERRcontrol then on error goto konec
	if not isObject(TextBunky.TextTable) then goto konec
	oTmp = TextBunky.TextTable
	pom=oTmp.CellNames(0) &apos; the name of 1st cell of table
	oDOCcontrol.select(oTmp.getCellByName(pom).getStart())
	oVCURS = oDOCcontrol.getViewCursor()
	if oTmp.getCellByName(pom).string &lt;&gt; &quot;&quot; then &apos; if cell is empty then select immediately the whole table
		DISPATCHER.executeDispatch(oDOCcontrol.Frame, &quot;.uno:SelectAll&quot;, &quot;&quot;, 0, Array()) &apos; select all
	end if
	DISPATCHER.executeDispatch(oDOCcontrol.Frame, &quot;.uno:SelectAll&quot;, &quot;&quot;, 0, Array()) &apos; select all
konec:
end sub


sub setPropeties(oObj as object, prop as string)as boolean
	dim nam$, pom, valu, s$
	if ERRcontrol then on error goto konec
	setPropeties = true
	nam = leftTo(prop,&quot;: &quot;)
	if nam&lt;&gt;&quot;&quot; then  &apos; type of variable is record
		pom = rightPast(prop,&quot;: &quot;) &apos; only the part of string with values
		valu = oObj.getPropertyValue(nam)
		select case nam
		case &quot;BottomBorder&quot;, &quot;TopBorder&quot;, &quot;LeftBorder&quot;, &quot;RightBorder&quot; &apos; Color=0 InnerLineWidth=0 OuterLineWidth=0 LineDistance=0
			valu.Color = getPrValue(getValString(pom,&quot;Color&quot;))
			valu.InnerLineWidth = getPrValue(getValString(pom,&quot;InnerLineWidth&quot;))
			valu.OuterLineWidth = getPrValue(getValString(pom,&quot;OuterLineWidth&quot;))
			valu.LineDistance = getPrValue(getValString(pom,&quot;LineDistance&quot;))

		case &quot;CharLocale&quot;, &quot;CharLocaleAsian&quot;, &quot;CharLocaleComplex&quot; &apos; CharLocale: Language=cs Country=CZ Variant=
			valu.Language = getPrValue(getValString(pom,&quot;Language&quot;))
			valu.Variant = getPrValue(getValString(pom,&quot;Variant&quot;))

		case &quot;DropCapFormat&quot; &apos; DropCapFormat: Lines=0 Count=0 Distance=0
			valu.Lines = getPrValue(getValString(pom,&quot;Lines&quot;))
			valu.Count = getPrValue(getValString(pom,&quot;Count&quot;))
			valu.Distance = getPrValue(getValString(pom,&quot;Distance&quot;))

		case &quot;ParaLineSpacing&quot; &apos;ParaLineSpacing: Mode=0 Height=100
			valu.Mode = getPrValue(getValString(pom,&quot;Mode&quot;))
			valu.Height = getPrValue(getValString(pom,&quot;Height&quot;))

		case &quot;ParaShadowFormat&quot;, &quot;ShadowFormat&quot; &apos; ParaShadowFormat: Location=0 ShadowWidth=176 IsTransparent=False Color=8421504
			valu.Location = getPrValue(getValString(pom,&quot;Location&quot;))
			valu.ShadowWidth = getPrValue(getValString(pom,&quot;ShadowWidth&quot;))
			valu.IsTransparent = getPrValue(getValString(pom,&quot;IsTransparent&quot;))
			valu.Color = getPrValue(getValString(pom,&quot;Color&quot;))

		case &quot;Size&quot;  &apos; Size: Width=4140 Height=2138}
			valu.Width = getPrValue(getValString(pom,&quot;Width&quot;))
			valu.Height = getPrValue(getValString(pom,&quot;Height&quot;))
		end select

		oObj.setPropertyValue(nam,valu)

	else  &apos; normal simple property, it should be set
		nam = leftTo(prop,&quot;=&quot;)
		pom = rightPast(prop,&quot;=&quot;)
		pom = getPrValue(pom)
		select case nam
		case &quot;Name&quot;
			oObj.setName(pom)
			
		rem Libre 25.2 https://wiki.documentfoundation.org/ReleaseNotes/25.2#API_Changes
		case &quot;CharStyleName&quot;
			s=getRealStyleName(&quot;CharacterStyles&quot;, pom)
			oObj.setPropertyValue(nam, s)
		
		case &quot;ParaStyleName&quot;
			s=getRealStyleName(&quot;ParagraphStyles&quot;, pom)
			oObj.setPropertyValue(nam, s)

		case &quot;NumberingStyleName&quot;
			s=getRealStyleName(&quot;NumberingStyles&quot;, pom)
			oObj.setPropertyValue(nam, s)
			
		case else
			oObj.setPropertyValue(nam, pom)
		end select
	end if
	exit sub
konec:
	setPropeties = false
end sub


sub subInsertReference(nRefType as integer, sRefname as string, nPart as integer, oCurText as object, oViewCursor as object)
	dim oRefField as object
	oRefField = oDoc.createInstance(&quot;com.sun.star.text.TextField.GetReference&quot;)
	oRefField.ReferenceFieldSource = nRefType
	oRefField.SourceName = sRefname
	oRefField.ReferenceFieldPart = nPart
	oCurText.insertTextContent(oViewCursor, oRefField, false)
end sub


	&apos; merge the single cells of table to one string separated with tabulators and Enters
	&apos; total length of table is limited with the length of string
	&apos; it hasn&apos;t the more complicated marking of columns for now (with more letters for example AB)
sub Table2Text(oTmp as object) as string
	dim pom, max, i, rest, j
	&apos; merge single cells to one string separated by tabs and Enters
	pom = &quot;&quot;
	max = 0
	for i = 0 to ubound(oTmp.CellNames())
		rest = oTmp.CellNames(i)  &amp;  &quot;.&quot;
		rest = right(rest,len(rest)-1) &apos; 1st character away !! it will not funct correctly if there will be more columns than Z (AA, AB...)
		rest = leftTo(rest,&quot;.&quot;) &apos; return only 1st number
		j = clng(rest) &apos; main number of row

		if max=0 then
			if i = 0 then &apos; new row, firstly not put new line
				pom = pom  &amp;  oTmp.getCellByname(oTmp.CellNames(i)).string
				max = j
			end if
		else  &apos; continue the row of table
			if j = max then  &apos; same row
				pom = pom  &amp;  chr(9)  &amp;  oTmp.getCellByname(oTmp.CellNames(i)).string &apos; insert tabulator between
			else  &apos; it belongs to next line
				pom = pom  &amp;  chr(13)  &amp;  oTmp.getCellByname(oTmp.CellNames(i)).string &apos; insert enter between
			end if
			max = j
		end if

	next i
	Table2Text = pom
end sub


Function testViewCursor() as boolean &apos;test if Visible cursor isn&apos;t in Comment etc.  https://github.com/gitxpy/libreoffice-alt-search/issues/30 (situations A, B)
	on local error goto bug
	dim oSel as object
	oSel=ALTsearchDOC.CurrentController.Selection
	if isNull(oSel) then &apos;there isn&apos;t correct selection of visible cursor in document
	
		rem fix: situation A, AltSearch dialog still isn&apos;t run
		rem simulate press of Esc - it moves ViewCursor to document, but not &quot;updated&quot; its properties in all cases
		dim oWindow as Object, oToolkit as object, oKeyEvent as new com.sun.star.awt.KeyEvent
		oWindow=ALTsearchDOC.CurrentController.Frame.ContainerWindow
		oToolkit=oWindow.Toolkit
		with oKeyEvent
			.Modifiers=0
			.KeyCode=com.sun.star.awt.Key.ESCAPE
			.KeyChar=chr(27)
			.Source=oWindow
		end with
		with oToolkit
			.keyPress(oKeyEvent)	
			wait 10 &apos;1 seems enough, but 10 for sure
			.keyRelease(oKeyEvent)
		end with
		
		rem situation B, AltSearch dialog is ran, but visible cursor is put to Comment (again and again)
		rem check .Start of visible cursor
		&apos;xray ALTsearchDOC.CurrentController.ViewCursor   &apos;functional and property .Start is readable in xray window
		&apos;xray ALTsearchDOC.CurrentController.ViewCursor.Start   &apos;but this is NOT FUNCTIONAL
		rem so it seems the visible cursor is &quot;updated&quot; if some new dialog window is shown (like xray window) and probably focused some part of one (or something like this)
		dim oStart as variant
		oStart=ALTsearchDOC.CurrentController.ViewCursor.Start &apos;if cursor hasn&apos;t property .Start then cursor is in bad object
		
	end if
 	testViewCursor=true
	exit function
bug:
	msgbox( MSG(51), 16 ) &apos;show mgsbox to click cursor in document
	testViewCursor=false
End Function


	&apos; save history of search and replacements from records to the global arrays
sub ulozHistorii
	dim tmp
	&apos; save history of search to array
	redim ALTsearchFIND()
	tmp = oDIAL.getControl(&quot;Cb_find&quot;) &apos; list of history
	ALTsearchFIND() = tmp.getItems()
	&apos; save history of replace to array
	redim ALTsearchREPL()
	tmp = oDIAL.getControl(&quot;Cb_repl&quot;) &apos; list of history
	ALTsearchREPL() = tmp.getItems()
end sub


	&apos; the procedure for EXECUTING OF ALL EXCHANGES via find -- replace
	&apos; &quot;presearch&quot; determines if the two-steps search will be used (firstly according to HLE(), then according to HLE1(),
	&apos; for speedup at search of groups (note of translator: I think the groups are expressions in brackets in regexps (...))
sub Zamenuj(predhledani as boolean )as boolean
	dim Curs
	resetPrCurs &apos; set prCURS in the dependence of selected block and choice of block
	if not isSelTextRange(1) then goto konec  &apos; non-text selection would do a bug
	Zamenuj = true

	ALTSlastFOUND = FindNextInBlock(HLE(), prCURS, ALTSiniSEL, false, false) &apos; presearch without groups
	if (ALTSlastFOUND = 0)and (ALTsearchPARAMS.reg=1) and predhledani and not( (ubound(HLE1())=0) and ((HLE1(0).hled=&quot;$&quot;) or (HLE1(0).atr=4) ) ) then  &apos;without groups was found - search again with groups, only at regexps and not at search single $ and not at search the character style
		Curs = prCURS.text.createTextCursorByRange(prCURS) &apos; helped cursor according to working one
		if ALTsearchPARAMS.zpet = 1 then
			Curs.collapseToEnd
		else
			Curs.collapseToStart
		end if
		ALTSlastFOUND = FindNextInBlock(HLE1(), Curs, ALTSiniSEL, false, false) &apos; search according to groups
	end if

	do while ALTSlastFOUND=0
		FOUNDcaseTYPE = getCapitalType(prCURS)
		REPLCOUNT = REPLCOUNT + 1 &apos; counter of exchanges
		ReplDo  &apos;substitute the found
		ALTSlastFOUND = FindNextInBlock(HLE(), prCURS, ALTSiniSEL, false, false) &apos; presearch without groups
		if (ALTSlastFOUND = 0)and (ALTsearchPARAMS.reg=1) and predhledani and not( (ubound(HLE1())=0) and ((HLE1(0).hled=&quot;$&quot;) or (HLE1(0).atr=4) ) ) then  &apos;without groups was found - search again with groups, only at regexps and not at search single $ and not at search the character style
			Curs = prCURS.text.createTextCursorByRange(prCURS) &apos; helped cursor according to working one
			if ALTsearchPARAMS.zpet = 1 then
				Curs.collapseToEnd
			else
				Curs.collapseToStart
			end if
			ALTSlastFOUND = FindNextInBlock(HLE1(), Curs, ALTSiniSEL, false, false) &apos; search according to groups
		end if
		if ALTSlastFOUND = -999 then goto konec  &apos; canceled by user
		if FINDCOUNTER &lt; 0 then goto konec
	loop
	exit sub
konec:
	Zamenuj = false
end sub


	&apos; set disable access at change for search of paragraph style
sub zmenaChstyle
	dim i
	dim pom()
	if oDIAL.model.Ch_styl.state = 1 then &apos; deactivate all instead of backwards and reg symbol
		oDIAL.model.Ch_case.enabled =  false
		oDIAL.model.Ch_word.enabled =  false
		oDIAL.model.Ch_reg.state =  1
		oDIAL.model.Ch_preservecap.enabled =  false
		oDIAL.model.Cb_findReg.enabled =  false
		oDIAL.model.Cb_findExt.enabled =  false
		oDIAL.model.Cb_findAtr.enabled =  false
		&apos; load to search the list of used styles
		pom() = GetStyles(&quot;ParagraphStyles&quot;,true) &apos; used paragraph styles
		ulozHistorii &apos; save the history of F&amp;R from records to global arrays
		oDIAL.getcontrol(&quot;Cb_find&quot;).removeItems(0,oDIAL.getcontrol(&quot;Cb_find&quot;).itemCount)  &apos; delete previous
		oDIAL.getcontrol(&quot;Cb_find&quot;).addItems(pom(),0)  &apos; add
		oDIAL.model.Cb_find.text = pom(0)
		pom() = GetStyles(&quot;ParagraphStyles&quot;,false) &apos; all paragraph styles
		oDIAL.getcontrol(&quot;Cb_repl&quot;).removeItems(0,oDIAL.getcontrol(&quot;Cb_repl&quot;).itemCount)  &apos; delete previous
		for i = 0 to ubound(pom())
			pom(i) = &quot;\P{&quot; &amp; pom(i) &amp; &quot;}&quot;
		next i
		oDIAL.getcontrol(&quot;Cb_repl&quot;).addItems(pom(),0)  &apos; add
		oDIAL.model.Cb_repl.text = pom(0)
	else &apos;enable all
		oDIAL.model.Ch_case.enabled =  true
		oDIAL.model.Ch_word.enabled =  true
		&apos;     oDIAL.model.Ch_reg.enabled =  true
		oDIAL.model.Ch_preservecap.enabled =  true
		oDIAL.model.Cb_findReg.enabled =  true
		oDIAL.model.Cb_findExt.enabled =  true
		oDIAL.model.Cb_findAtr.enabled =  true
		&apos; delete the list of style for find
		oDIAL.getcontrol(&quot;Cb_find&quot;).removeItems(0,oDIAL.getcontrol(&quot;Cb_find&quot;).itemCount)  &apos; delete previous
		oDIAL.getcontrol(&quot;Cb_find&quot;).addItems(ALTsearchFIND(),0)      &apos; load history
		oDIAL.model.Cb_find.text = ALTsearchFIND(0)
		&apos; delete the list of style for replace
		oDIAL.getcontrol(&quot;Cb_repl&quot;).removeItems(0,oDIAL.getcontrol(&quot;Cb_repl&quot;).itemCount)  &apos; delete previous
		oDIAL.getcontrol(&quot;Cb_repl&quot;).addItems(ALTsearchREPL(),0)      &apos; load history
		oDIAL.model.Cb_repl.text = ALTsearchREPL(0)
	end if
end sub


	&apos; if the text of search is changed and the object is searched, in need reset and actualize TMPPOLE()
	&apos; assigned to the event input field changed
sub zmenaHledani(oEvt)
	if oDIAL.model.Ch_reg.state = 1 then
		if leftTo(oEvt.source.text,&quot;::]&quot;)&lt;&gt;&quot;&quot; then
			CursorInit(true) &apos; must reset to reflect the potential changes
			redim TMPPOLE() &apos; reset the array used for search the frames, notes, footnote, a text field
		end if
	end if
end sub


	&apos; disable access for change Uppercases
sub zmenaMachCase
	if oDIAL.model.Ch_case.state = 1  then
		oDIAL.model.Ch_preservecap.enabled =  false
	else &apos;enable access
		oDIAL.model.Ch_preservecap.enabled =  true
	end if
end sub


	&apos; disable access for change Preservation of uppercases
sub zmenaPreserveCap
	if oDIAL.model.Ch_preservecap.state = 1  then
		oDIAL.model.Ch_case.enabled =  false
	else &apos;enable access
		oDIAL.model.Ch_case.enabled =  true
	end if
end sub


Sub AltSearchDlg_disposing(oEv)
End Sub

Sub AltSearchDlg_windowActivated(oEv)
	&apos; why false ??? - maybe at loss and restore focus without the intervention to document will not rewrite the borders of original selection?
	if NOT ALTsearchDIALOG.isVisible then CursorInit(false) &apos;initialization of positions of cursor and block; visible dialog hasn&apos;t initialization because of testViewCursor()
End Sub

Sub AltSearchDlg_windowClosed(oEv)
End Sub

Sub AltSearchDlg_windowClosing(oEv)
	KonecTm
End Sub

Sub AltSearchDlg_windowDeactivated(oEv)
End Sub

Sub AltSearchDlg_windowMinimized(oEv)
End Sub

Sub AltSearchDlg_windowNormalized(oEv)
End Sub

Sub AltSearchDlg_windowOpened(oEv)
End Sub

function ALTsearchKBD_disposing(oEvt)
end function


	&apos; key pressed
function ALTsearchKBD_KeyPressed(oEvt) as boolean
	if oEvt.KeyChar = chr(27) then &apos; cancel the search
		FINDCOUNTER = -999
	end if
	ALTsearchKBD_KeyPressed = false &apos;false = let original service; true = don&apos;t call original service
end function


	&apos; key released
function ALTsearchKBD_KeyReleased(oEvt) as boolean
	ALTsearchKBD_KeyReleased = false
end function


</script:module>